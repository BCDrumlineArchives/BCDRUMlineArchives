<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>BC-Drumline-Archives</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #2873ff;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #2873ff;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #000000;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">BC-Drumline-Archives</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"2d627843f1dae429beb4fd3b348508da46484279fe3b42aab8258217ef6cfd814c540fd1000871a3fe4fb085a90bd49cc403870a58c8f7344afea45a43d7d85969ce0d29791444b9615fefb071deac0d3857e456d644cc047ee3729924a97c0eb3d1153ecb698e64c32113e861ebcb8169e250061490db41d56881b629073d3c35f29ddcf5fe688ebcb5c06b2fd4597100a4c568c9c077ced185663639315931fd003d48e0382c11dfce54e373fc71bb59605084deddfdc0bfb823f987108cf11315c6e5498f202bacfe19b48ff366a1408cf7a0068f4dca9374b207bc66767841c72c49b7fe2854660f80e9926426ad1223a0ab38216db8aa359f7948a74c3227b9e619e4f241a3a51b8faa1053acf76cca44790571be1ae52fd01db3e211691f5d70c1246259e35d44b5b8168458cdbae43104502291d974b951e1d1ab0df9f49ab263b1053800e239bf728c5851ee6b68bf890560bac675c9a9059c1ab1260796c90da991cd8404f3c5d820c93a7d147eb138a80f2a8a14de47cb0fda6d339023aa6576d47ae10ee43f112e73db63dc675d43a3ff3b96419670ab64f16722de0576c0a7325d8cdd908170cd59f450a6d09c11b377eea30847100ff88d39cccbf56b7e26de2c775759e15e55e90d18aa34436f39412252ee43a7a5f7a3a524ed4287da66baa6bb7427d3b1c67bb36cd729508c660596990f1dc744fb8c75d0c4fa441987f351532ccd8250846ca1106542a25a9653a1c6ecb3a6c63bd45e9c793bdc3aef4fe44cddfb65f6fc95049916b1aa53d9727e9f2a9f895fff625ee651d5fc1dbc1aebfa4b6de92d1a292a80224fd5a73f2903902d3ae5925a5ce3569a36d2960aff72af12c6e99e3a471d92dc4877bd060503a7d6bf781e3a7d85a389212710a41b9e486db0aa0a588d7492e036f81dcf703ece912bac3fe6a65947a22b27cba17be431a9fcaf80dc0fdc2962e2d20a95f91be21c5f15ace976cc095fe1befa2befcb29dacb42eee5e19bdcc93d7cc42865ac82815754380e6e6fd78765b7c5d95c161b690329d0233b1f14189f29ca43471e858d1f89b99aa19a7811d8523210e402c060c13ac1c7a29155913b58a6d3fde82873c1f230cfacd294fcd71cdf10c9a9ab3017c3b44d4e1d4479ca16f2fa35c9deb8723424a59c27ae15d57f9735b15086d5dce445454325824af08c11cbbddf39dfbb02ddbd6a3e50cae004276b6879b0072c8a3e3fa71b7731c924d7c2fe303083344283d5c75ffa42d8cf87cc2f51347ea0405d84e47f00723d1bc7cb73ce8412cdcef7cfa38a1594f8cd61d5011ba771634bbf55433dcb889901b49cdd5b5d76544dd29b6c83a09450041ddcab335c055b38bd2542fe4ec96a03fcab6730d46346b89beb67f8425d9e8ef107267f8601e9ecaf77000263a5f52a06052492e1f97d6fd0558c9c56ae1f3da46bd98b8d7e0c8498acfd98ec44074eef80e51f979882788288aef880234724c43a3fdd77bde32b00bcfd31b3d2b2bad478e432e0e901fa10eb2f5be7c13b1d032a9751e030f3621e5d9cf75696366b95dc7be3f43be101ff31a56fbf576f834a68f54efba6c3ebffe1e8d3930757eac8fe6c31a705b24beefe1e905c457580976a158fbc7c320598db992d15b7a2d66003539f3909f539ac719d6db96ded5ba117423876283992a33b17c878429608c79b452b933d0bc37f30aee6c7a59a2b745913aa7a165cffb8c66ae6912417363806ba818891b34a5c54fedb2d624bf5a0a787a5336bbb0c4907ebf8e51277a90993d711e06a43cce9d2da86b2e2de9dbbe359b557e669d8f73221cdfc55ddbf1ac09aa0c0e7acd0a5c878894addfc3d72e1febcc38dc65df0dc68cc374ca361e041060e11da26aab74bb6fa5ba3c395ea406e54652676c45eb8ee8610497dbd9c9dd5faeb8a861fb88568078ee8ea2381a01e9c6990f6b95c4aace4fad40ba420d41774f9e9561f09900115b42fbe2ba027be731c36a7bbffb7ed8ccc635b37b42a6997c1ec688249743d74e91be5b9d25926e9159ca8cb6448fc536e74ab54df0f3bac96d5c22596f2c21208e737f0da5504ef2f73a7c597908fa1f2054b207db2b1c7864c94ae55ae8f699aabfbdb5c0f8de7197c87c782c11f8723418c0df94cdd81d05323021ff80c3d7ecb0f7e97f7e4cd284efb7c8f279abbe53b598ba5a9a3eae0d7fd2a6f642f3814b74e2175127b676b0c86cab5491d58a63d9cbc0aabf738d17e72e75eedc25c4a77c7f0dfa5bdd554af3200d539c614d00c21aee7ca92510cb1dceffcdd892b4f0e596d47a8dec269168fe808c2324f2a4dc9a2917c5ebae6d5023fcf4af81c8a01ce43646ee69f82d06d1fd410c66d0140cb3086e8d359ff648f1004a067cb786bfa2e24e235e3ffdfd0e4df990ce8717c73426cfdfe4cf525887973525468edb1a134fe4d414cfdb31c9edc45a500e95cf9545e706844928973e1371705db24732400fbb5939c303c3b28267d5f6e3a109ea6ab53e50f9894fec2d4e5f0ec5275ccacfd1e2d4663ee206f1273150aeb8a50a2549fccd6ae6cb6a2c17aedb9f578ad676bbdb92c7df006fafcd1450eadaa83ec801c2df2c763a76a0f45442539faabc017d551b18a5a5f1f45b6ae96fabd95a80d0fee9b1ba6a350e6f88a906c0cf6d0b5dba154a7bcf3f4da5c851dd0d543cd99045b15fb338b1176bfaaf10514a72fd193550361a4d7fd117c83d99cd45bfef00ad5488470042b346f5bd920829e20903b76c65cdb619e56a6475aaef2b2b38113c6ed4174c293e8ded388a2e103a62ecba9db2cfaf5c9c00c1bb203aee18f2a3a54343d1ec0ba3f06bb5b4313a03eff468c2686e9ca107d8586f1d16f8aa71dcb75e0328c3d6eafcf01eebf3f9456b40c55c89082a73aa29d9a77ed9cadcef80afc57a074eb4ecb2eff45e4aafcd38150db6441e9e7b3cd40292649064fec1dc60ccf8c5ac22e3cd27be48b18970efe3adeecf45ce571f6b41a4f06bfa27b848953b65ca6da2d851c848cf945dc14b2845c4f10245f51500a6aa0e67ec63684285c21201f821dc5fdf69b41b1591e467b48dc5096f8fe368fe261ba00e0fa9246f9f5bafde1591f88fca8ef23e8dea60b484aa5a735a4ce02c58f781e3440a1c444a2eb4e998e555baf5a5d4cea454622cace1d6f344a4dd9bc1d43e4371caea1c0d7b8bd84f8d5e3dd1351560d3ee9c0fe93a24fb423a8f4017b13bdc5a20340b66650966b51988361efbee0bda4034069cd061639d68b1009119aa5244f5074072fde0f5fbfbcc10a022508f8d373c7c3e1207b2d3da1655a6a6d47ea7ef30f487f7d3a85f36d962bbd74e4f2dcb5be0b18c4a61a220349d9b2869dde74a58a28044158a97ace881e2ed2c56ca81ca22c5ef4e98a1b6038619ad1a8faabbf0c5983ad445b463446503dd4d484515032dc6c0a347c0539e007cb9e5cce5b52bb635d6e85f9824372299017d10b80e0cabaf221b3e86df4a103c0a550fa1c421691f23db571c911f37c19e223581918c82ae252c9b01ae768bc69b8f9757d963d9b495e43512390943f8a30aa620edb3036b114f53c1daab0effeb78fb4aa7df0677ea5eab751b410273464c2ff18729eaecb618b62945d3a349f801ba6406ee990fd33b3389d98afe0fb5abc10c220ba9ff69ef8a65677aebb8869b7e76df76707ac094b54de05d9a70787fae547cd322be68aef165f6e3df6b7519b69440f46f4914229a292a28ed3963fcc87f9a84923c903efcc975f519a5ecd476c844a0493d6e594ba520dad068881eca6974efcbb4f783741b13c853cc09545398d9457536cd0b3ac8b3f2b483f5c08786fd20ee7febe78bc0985b957eac1bb867bf5c1316ea4777d2bae9a75f82ba3bb2ffa26a08b4413419b3bf0700d0046b093412d45bf5eae8a9a9708a16176ca5ae29d4bb31781acd3418da8fbdf1a9f1bc785a22d51ff4e5f3d94eea81096a402af3125d7eaacb5ecd97a0e9835f4251e21f4433ccf6a4e44bc43420589a2f031649fef08ce315f62984c76ad552a1f7c71f1e7eb1eae209de3c0f7189f2045ee2ff929376e2300f872fc14baaa3367676c4590c126ac0fd7d0b281898fb02cfdd8f68a734c4e5ec59159983b67a49e1af9c3f64f644273aa1417ad31c01219f19161b4141e0ddcd9593cbdf17b3621ba9260d3b5dbcc8efc2e53a9535902e63711c1131febdba9d1130b7720017616bb36a8628b09e90b09e2966d9979d25300d61835b96d5d6167711fbbbf54aaaab650f954ec118c20d9c425b72b642542de8895cfc758a8ec472e37c548dc8b730bcb1b39c90b295e83171be6aa1eb16c15fd930290eac76c12527b6e89614677418fe387ae8161b736386fff024b12c6fe22b47c00fa3297b2889f25ddaa59dbe0400faa4efe9cdb9d5d9a73cb82fb74ddc3a672665f080d148b20bf945f6ef2e1c4d6a1956566d92b07dd56b1f1b9ee70f3da37026950af3f133740417c04fafe03f20b1d65cc5aa5d9947079c42d686722e24c193ce8aef4149c4c0d40cc5ef7958fccca85d430654ee21680f54cae1893664d8fca63f44289dfe1ec6fc6129faaff3ebbf852392fb7e34b45d7285f3a57bace3e89d39e6b8337da6baa02c6b2ea40fd7e0b8fba5a33d6c13033f3926e2fe40c527a387436e6a1447d6bb0203c7cd569f07950d4d69e9994e0e945d20cc51603ceec3900d69661676e1847eeadb10a6448b62abc0747e566337dd27abdfe0ed8bc0977c851c957364ff9e0d6a6df9ea4676a895056ad9e3de219fe224eaa40226c7b1564f05a9d03e7333b5f8cfe0f1dfdf74c3f324ca3587750e6833bf0bd244e48531c55a17eaad94794b9ad0dc82984f48572aafcdfbd401f2a873d04e16d77d42785fb0f2634b477693c28b40abb9f3d61dafbce3e29eeba705a229f3c380e6e3edc10bb72987568261a69e155710cfb446ef12853f8f9369d70e2114e2a612fd4af147c723a4712219eeacee79e2da536ddbc5a63d5522dc37b31ca4218e454b62d100b3b38f39a748e3102e31f6f2d81956d16135c406d9f21203b98374bb3f314ff43e7efadcbe01752a655d6aad33296894467ccd922ef30e436c0878d6925cba5a490d389f9cecfdd851a413a5ad9f43db39cc6e07909d266de0f1217dd3847d1f2e1b41f2aafbc6daf8790980ff0f87b09cf9cac3ea60f931f580e1f62974519f94e8927ca7e006190517eba6e86dee84a6905e54f496fb4f56ccae3ee79b1aefcd35ebe6175b793cee0fcf5ba1f9600ffaf0a936d901b2c71fee0db25435185e25f7e3eafe5f83e2d182bf17153537390e634ac0feae11de41dd68c117cf28b648f1b3ab5df976d7240203c429ecf10a7cc82c99c9f3194158e584659e1fd84b1d45db3d1565bd2e0c3dd9753508b1cc7fa6e22561c52158a58a8a5dd4c2883eca05d6fc1b3def2561753efc4cc88d99e324946e1170acda9368c749f247d12d71e3f367ad87aecee102daf57a414f05d1b640ccfc0c174bd8222f34d54480cc331d0ecb8f7ae2fb0bc1e2abc597309020eee1cc053ec1c767703103fba5a4808c84527e164a572b61a29e480d0ccfe9418bb23ff8d2ced82b491a00dab0d81fc0227c75934fa3bcec46bc89d0f630a8500bf22fecbb264ea8945d68871e246cc6af457c3e1581c33a2104a3634453b68e13ea15a1c8891a40e37dc62cede5209d6c7f16bfa4eee01f80274894262b46e23c85ed972cfd32c9d2c3130c1bf0c0f46f7cd91638bcfb56cde4abe01af7d9ea1659853759f74fc0d2a490f711c3098e5a3ede7ea309745d18990805515f1175a38b0efacf7a0fc929fb32ee370f2424e2ed199d552cb1c158a7c4e5535b17b4e9cf77dc33b8541fe3a21e06fac638524253ddc82ed9f8dd16610c4013f9e0e0944602f08e593bd61dff9f92c88ece0108844230c126bfacf68c2daf67255dd40d462404729f2498902c71b9f809d76d9ec908ea7bca5a7628a0980109720f89b6da89df03484a21d8acfd57a571557d91de3261bb46216def82f02e401e97927643af734d59932c182b3a5f83d29e59514bd2cedb4ef50fa1744e87813db01ceab4e1ab10780b19a04745a4f9a7a4611fa5e15fc71ad5d684579fdbaa8cef83084823624b3d51d0689405aaac737df250d6ac417a604056c1a15ffb771b28563aabdf0de57e0cc638e05655b8e1f7d5db962aaf83a58b4d1e22cbbb68d31cde9bfd5f6fabe447695634718cb43711c626b8ae52e0183368a75728b0760d53b6a834ac454f809e7daf4467c6511acd6db335f6e1c6769f1c8134522834d54da1568a330ed8c951617047e3e0126c94f13a16f2a478b9c590fd76de43f1e2391df71d0b40ab1c5a6e003257b33d693935131c95c1cdf9687e6575b6a89cefa63c3007eb3de9a91e81ce91ac6782e9bde637ed541f426e2caa1344ba5563e571cebdb3ef8e8a216f92fe6e394e53aaf2797e770b1c5aa7c9c71cea2932131a5e56ce10357f30dae35927b3a0fb7d65a68fdcfcd77bb472c73563c21f5a98b99a683dade09c8af41b159fb2d05e997462bbc03fce70cebfe4cf5b9ae42ab5aee2348c95eb4f01e71bb5b2d21625fa7536ad37af52b5cfa30b13b5310ce0e8605c244a33d7ae2fd2befd914a1bb73f740c77f9a52b272e1988f4c5beb2ef722553341e1bd6d1bbff88c69072188891718873a6552be36b2845c4a732b5b82df009caeaae08cce981721c4820fafb960fadd0b201a51c55164a9cef0899104928bd04b9c8eff2a7284bd2243dd8eece508b0bc51dbdefbe52344deac793dda83c9cc5f5420b98ac8cd28dfe27e3fcc6924498168940a2bafa7d07b96c9475b31d08b09c0ca8e163943fa2f6579522600a580070f6c05014a0bfcb40b73ecc16ae0bd433b795dbf01abcc8528db2e27ecf73e1b7407f782f705e59435442308691c16677e836f186450671976f2a55189e963eb09f6e3879307e488f0924ad5ded8065d21407c76a40b50f5a592082ca2efdf3f296b123193666c2dee93283fd34b131dd6cc9661aac8302b7a80d2c910ffa44a10b17405fd3cf6e310fd78b7cc637bb5c8645530caf00873ab89c38291afd8381cf6646dae9fcb7478b56918f082bc50ed891478289c50b181fe6dc90776f8163e0868a44f1b7a7851c79ec98f2e2161d25720b4380e3577ecb126a6e04c014fe9ef5da07e5805178f55fdb4506efdf839f1aa0235a1e532b53c645f7cacf56f8eee0acf87120c6fa78d3eedea287cb19c0c4ca1e4cd48c0d4dcc4451c0820f00b1f5251c5a4ebfb8ae8f42d32ea8de27cbf0dce877288df3db73df78ed182e13f6f39d8b46640ac4daa016e3f3550fc5cf9c002ef9388af38d90cce124e88f7095e5806f71a35b7927ba8a1997f4d99a67f2d0cf0c831270ebe791499e30536e7401f220da91e43e3ab25eeaf522be6c28ef4235b7bc00495841a1a97e8300752f99d8571c9ed9fa91b0df1d18817ed1ea9d767fad010e706242561424ac730df6705fb943402b6560fc37cb9702945094d109c0543ecd62e21e2e5d2554e4bc80d3c83b3e7b85c1a514393dd620307cf59f69ea79123c1a0658c40cb23b8f08a10a5a77f8af9d9680c1ebacf7df55c98654aa846a440fbe0898f1a06829fa8d2b6a35ef2e5da3278822cc4b7dc7dd543909335d3f3509f7feee72c1244d92d62e16fb1dbcaf150e5cf198d25d00d8f92a9f5aaf2f3aa13d41399f86724ef90f855052f7f502b3b48451576adf0260b7219ac5e519d95837468ca3b2ea67669ea04cc59057ed88641fa73f10bac04dfb13d03437d02546e4f16d6b70c3a778face7a4ac8e68dad060c94d97a27c1bac98d8cf0df25169245d5d597c3c0059c47985df720746187f1505a9402e93994f535fcb396dbb0f45efbb59a16cfb32936a2be0a70774423868fd1c8a986d6ee5832c7a1ec2f0be0fd516a3cd6848067e38f058a93f43065a9011a52a629e688c8c68df42b8b8e574403272197efe9c404628d2382feb1f2d0106179a06721421e7ad664ba988367cfa59c4b858845f1779b9bb1981e3abf8e9d287d41497170599d0facbb6486ca96c5d25b51d4e2a12e49e49bbcb6ef66b04ff62beafabe9a3ce1bcb812fff2fa3a3d68c23947b7d9aa2272035f0a7b124e04323a0029a4c45d814b465e7ee4368ee2d31c9926ba5a517afffd08ce2efbce0d8cc92341ddb5b87eca4065b0c29ae962ea71b11d773f8b1e3940199580464babd261b33e0f0d6753ffe8c9af2b853220a700411b6cb061a8f6a22cd2649532a6281b743552fa825ed91bdf5d8333d6a4c5a98b618b79dd67ecc1205816a112ed39fa7d7bfaf67e5564d2a7699e8266676cb935d297aed1ccffd6e66501657d7f5f5b8a167ec17d6b2f31f49cdd6c101fa1fb53141770fdfda34aac8f7aa334406ba5b305f8c1f29db59e3bcbab46d0e10b59bdd808877c904a0eab708fc6b1ad72618477de071462896003a4c8bc244842dfe2676adab82157eb5fd95047bda9e3b0d1ea5f7850d8c1350076d6a018425c94ce3e3291e9f14194f7a9d439d480e63f8a0bae5fc79b339bcb07ad014375f7884723ebda55308b3b1c3c0fa342cdb043faa923ad7a7a0398ae9a95745d6e5771b0a64f584a83739292c03ee3030ea9b2b02a70b105552aac40e20a57229fde77123664778a5e14eec0f74333bc73965fb6d53663038c4bd1271ff2789ba9634483fa5b639e8b84ef5dc32507aa9540c70525f7ded51484300401db04aed96730aad3b935d17734a155b22d3a99e3efed3f887872e319a34684ac4a2c1323ea8ba10c6a037ab6ecdad075db6fd2842e763235bca9eef4c8350854dc3af4f5c4a295f28566ce83c083c59997d60e78b9be37388ec9315383f1dd3c9781dd5172e063ff5cb0af8bf19e7267be3f759df1eda8aa257ec29450d448472d78396361b572579cdd0447be49c35301d2ae0ea5c5467af9b2a5203af8e0e429199966174885073c6b9c7d8efeff57dc0981c319d71c1b5eb763f13a9bccd970a8c7c6a8e52b12fee0c60c228bd0c5279cdff6a225dfad7d5779a54f7abb6237252c12676519c2dce59bf1c534ae0e67e5b8b1a99b599527407bff65cb7571ab8eec367fd2aba4e9e52267a0f24becdffa442367169498944766a234547855441a8644d1d35b83dc7db1bc0c7a78d4f5f7e296eae0a94d0aca5a5c244d17914ebf3c1a3b1a45ebf8ed772e545fa46ac1967dd5c3af73844084232fb6c8181ef8d270c3720d8080c1ff9f9b3e6968435d08d60c077e86b597d5bc0563cca1141dc6736889524c072e34ff959ab7a22fca59554ae56fe27abab8c14d482eb2a7c2e71a03dafb8b3603bb1d336b2bf070c0c07f7d39636f4cc8a00dbe74aa92e3fc2c69cb41e368edc0a8937f8b2bd6272532f10ed254115e26bf6210e4b531bf68410020208c18dc4dd6f4758a8c0e6e5d35e83898570f65d07a856fe46e0b2ef5461686e757210e2debff0d9d728d19cce6c9517fd00cea1ad43c5cfd3ca8e8be98c690a6293519c9d7bba822a557793699928e7d2178108c18dff466c7c0746200b9be6211a71c62871a8d4d2865fbde0582c2bbd6dd3c83efea592d74fc38c9dd62292e75b6d55aee31505b332f98b76000f48d726d1d7b41a9c44fd594abb2ce5cd43499e6f1f75825957a608040bccb3efc01496204eda848aac5eaf9c9f478693cdb0ad812100026a95a165cc3c8744446a46467d28f1d3d009b27fb5c01da714785e29d838a34dff781617221c79ab4a43def0fc0fd1e153d5ab66d9b9552c8c5d4d1d04a725c5373ec670ae263d9d2293d769c21ad4854fba1be9f296031a9bc1ff4b61213e93f9df19b546f95aa96a1657d139502b4547e12afd4d287591f68c70f7f9a079cc4b82d535ffa2f07a2b418d59ef3ad6415fc7c3730456e69907a6c0fba76a121a7a650987b9105e49bb2fda30e6d72586576fa205c8b41b714bcf21cbed81dc6edd4e92e98d8f5a26f63bd7404f300baf6f97b9040363160265124ea0fbb212dbd36a3788306e1c99c254af6bba32491f37bfcd1ddde97d35d3eea67cd4f780679c24e2e7b33499ca655ebd6ca653fa00de0b07dec3baf1e1c46c54ed860dae2d6d548299010967c3307f3fcc1dacaebb16e9464d7b9016838fc23371dcdf00eec0c47f128108703eff7cf6c155a1f99c240cea6e35423b1772590be431d89d343ac7d1735ab67e58e410d12d933f3ffc5c1c058a7161d7d6d6754393ad9405950222a10022e56fe34e04ebaedf6afe4f429b1143f872f19ec7567b493c5cbda2b8ee4bb2b17e5d8562694f6c2740c3564e216da5909976a1e1d3faf0e0ed0b847ae97b5626379f755dbc83e91aff4e50b36c727c6210485e9402a65ae8e6d96ffa3e3df770e022511505ac1a850ff6ac72aed7a545fba765f45834e44d6b063b2b91a7dfdf8a1ef278658e2e79cbe7d0aeedee36fd01b77c5f18b308a79d078e5289e99373683de5a2815490041a02306d79b7670caffc27110bb91bb548633e08223bdcf29d11e5c8ca3ee0046c51bfc57ed6c4eb83f74262b574981f0d8b566a262ae22ddbee47bb8599ed06bee7e45964037b1718b186aa490a99cf579f3f01db0807a79fc23cc275e9812de3f43f488b212b0a432132fe48c36c5e6a7062a27ac59fb7a697b4f3d24c68f287383a94d296d2fadcf7bdee5e4c986dc5b7a9798b52b84552a029bf2b47415ed309a8e9eb72ef89cb43e7cd3e36f48589d70655dfe423916c568aab8ea9915c3660424b2e930b64abe8ce09f02ecc227b868ef0589b667835001e8d6268977b8a0f61745741842b496d6879e8bfa369d933775e90b48e4b99b3ce8cd130cb05f351e1640c48124df32299ff92705c843cf049b82d702170597cd72e424664cb6d2d1fb5aea1a1e14fce54b07b74bf5f2053abfc049554b87e88a21cfc3d85c67e064bfddf726bc7dc72bf7ca8ca617127f06c4b795db81d60e13bc973fa90a29b9229a612b50be660c61f0ff615d979eedd90eb53fd42c78b24e91ecd9e97273f9ee42edb8ffbbc6c71c7d1a5973c9ed97752bdccdf7cee827154f1999e419290db81a2960c8ebcdee1b98c7a7fee326740e74450fc9d09daa1e07f5fd77b82440ec32b72571ed6ca8e57f1a5d897b69b2ce74d17215f27238eb1a808010f53ba596bbfa477fb4aca84865a295862cb3e2d80ac5bffa525a0dadcd1bfbccdae7daa5649b212abca786aab5c232873f2893b8440e02764a27ef567d836b25b4fa094d915b7341e6d4acabfb898a91a5ed00c51d5e3a3048736b620aba01cda1a047a83f228e7804ea16f72b3aae655ba261efc8202d5c4a4e3fffe9289a329a84b7b5e11c5662573d6beae75b045d2f0e1d127104e06b48487b9424382d45b43259cddaf8cd4fb29bb2c3dc99570703565954bb19b81b27982f20389c686358e750b8404d249b5531faa78469a33ceb32c3851f57674ff68f8723bd4f69327e79f899c00ff65026ebd481e3015877691739c7033d98cd561aa77912782c3f9f1b6b2679731760eb57ea7af42b4cb476499b87946c6f9dfab4d77e16a40272b8269aa0a6d2e5f64af180f16da580ca592196c088da81cd07aa2a93479507ba87084b479a3b92138c2f15140e57a1156f570ee23573d73242994619165ba8be96b46809de29daf4a3fa21e42e79cedfec7d286458a6b7f285bacda907527b86e46e7200a8c39973608fcc6e85495a007f7aca00a0006b7cf83ba68f928574264f58d99a5805bb20660173647c4f202e0eeab523ee9ab8ea36ad5c85fd1215906885d883f763bb389a996ec2de520049d08b73706f02c7720207047ed0c93552cf745782f290c690d14782508ab5ddb688128f42114ac7504b15a7a11c972889bad1d9fd39cf59c55a5496a9ab1f096151511fefeab455ea03524d60fbe5f4a1d60429ff3d09aab99717c444612e6a7dde25ac2b8a462171b4ee120862488055d4641b1701c8aa45a854a3a6f7a0e23cce91a706e3298e6ee245d3a0655f68dbe929ecde4f92fd437a822daea5b30f51a56928027529c4f482594d54edbe207b0aae6c495935441c4ff3f5495d56fbbcb911b8b47688c6f86ed6c36448bcb9e26ac3c234938f6fdb0eb453759b5f4580447b9853685dd02573b53349c0903cf0df4d035b919deea8d920b700c000a3f0fe7855927f36cd57d09faa7f5a323e084bff6df96163d82f3b8fd8bfeb8f41cc932b82c0a2f31d14666047b381ae881048ca0b77066241d23c4de474b2cc3f666a6f3f1a87fd1d35a59eb76c9a583cfd57aad9da57682a5e3e636b790b2aad5800e0f21bf9885e94d89ed17fed69da8d926d06052f3eb3554d5d809436230f05feb88a457b7d37aaa37c16e1fe318cb8ba1f74cdd837d1b61b88339320c5764d2e9646aaf3b40b0f6ed5104381103c5d7d7cd3da4bdaa1bd985ef197d1bb4726e600f60a89cf54bdc5158a8a8c61fe14d55b814e0469e8f8b9877ce7dfcd89e992aa608b42999f08d08b1b80df5b6f31c24280069eb18aad78252c391b2c0b3247ecfd665aa233f2a3418372e22db6250125851cfab4c4bb25f09cd03d96b702ade1b98681ad53cf674115550f6a53748ab6d8bbd74f76c9916f7db978ef1522d5e69e400b1ce4aa130be72603aa553162303390d96b030a8f42330d0dbaeb2e86bbec5eeece2de399a622f96ca1e23fa8657518d25f77023b0c9beaa040730937d96c6b54de0c1411c57970c86e8b1147b866bcacde739c3361e8175e820dd54a415c042d34f4abd8220384c5b24454361e0ce56f4ccab45aacfa04502b5616fe7aabcb484b70f85cdb392223273e2b5f1effb787e7e501567cf7478dfe15b9725a169d3df6e6686560073a0b99f0be0b847f64f2f072ecf409b17ff8816c6922b4a3a57d6c352c9309645f82b0b91523cefb469ffd0b6aac80e3eca252e104305f263b274c72daf31b77c9d192d7259de77585ff8deff7f22d2d7b16210ee04e089929a89934b39a4c9b869a2815b539a2099b90c3ee092249893d87a33188e85a231b6b7c6ff8d051719827991ec5a60da1c6f5f0fd435d99bc47ed7d2cfa6c3f6b64b0da92db9c39f2623cc6250981134578506f97e6fd34f886602888194c96c7af751308cbb565d5834fd9103fc60d33a8b45fd275f851a229af36f7b3bfe87ff1cdc44aba1a6be124dc2bb0e3d16c982c43a703eca686ff006071a1a2bf6a3d3a33d88200f473b97cb6b4ebb495c5c0eb3ab7be5063e81b0e17045695ede4cccb398386e3ceda082f65410fca140c20ed909e5a1d2bcdca7d0a8c568184cea1d19b9f42b410d879cc7dba1aea4186df1501fc128193a98fce10f1eeaced87052a4f31b88a61b3bd9636910e57a60beecd041d0655abd9c5a6c6a7faa85ff229c3c43d0ac22c0e930c8babe87c4d448f938a228ce12219c3e0222c83ff35f5118103540fc2ded49a20b484bd38890c3844c659ecb1aa723c25f4937ef8abef04022d9bbf504f22742073a8ee2a0fa821ea0c0cc87e745379f2ddcd65876a800227fd764e213f51fb24a3e0b53356e6c7aca3b7eadcb5c6ec48dc7dbe6124780ec90a799e415ccb6b8e7e036397b9d9e4a6866bae4eae6daac09f353652c1dd0771939a25405ea9710951d7fb36ece9918d89a6aebc9744101f6ed6fce30700e3a2c6bf020dfdc3ced926c30c47c09ed72a5e5a99308f3b45fda9e46a10e9992c9140da10cded59a48d8ee420d47c0af066e597a6222124e027a2c42254cd3a0f46710f6fbd16a13b0cbfb4e24c58fa6007d7fe6da3e96adfffd623fde8a3ddea450b5528caf77eb56ad48e256ac2cd9cf73ffd69d430318192b83b878fc5eb6a3fc1dfaa0189fac8b7a91c15cd06a3b6011f2812ed51717017881aae82be2366155e80989bfc3a6cc676764c8e0027412bc0a3fc2a3aabbaeb1489759000d02837ebcbb3810a4e184c4779ceafdf51b8737d33ffc1a68ea910a1786d124799d4e28aeecff7458225e71c3b6f0256062e48df1af0486bd6bed22d7c0b5d39205880b165519cbf33ea4535ea162a67d4c10c4425ff3ebc205d3bde77a19221852621430b7ba1857af0e9444d273dd1e0169b0e66fc64da43a108dc105280260110e50ec2b3de86f5483c4e314aead0d5a927420a704159b0c37086405ea4e8b6427fbfb3e9d30916b34212c8db09f038f1fa7926a1e10efaa02a4d3f4d595dc79043b2302e6b9416711a146258bdd1277fbb82da91bce98a4d2379452b0c93468b1b811e579d5639043c1630c3bc032ab46bdaf0866c19a239d71d4262b10ce3d52b6490bb5f02a0ddda8da74461f3f987f051a53e8483765fa12e18cf0470b0061eda2e62c07898660c425d1f5637367a8709be61d16e92423081e25f082ff2ccb761d13e36879a17be528cc4e4fec4d529b7b08b0bcc3daed6d73c8edc3a279323e14d524005d3ec502701b90c0281bf88d05c6ceb69983ced11756e4647e733afbcdf000d47d06c7434f48a24313f40f8e4b0b0a0eed38526cd51317a5255df99af4a8e52f6df4c1b414cc7ad8ba966af33a5b8369ed28f70d6088abf6466466e6fb3b88c2964502dbb696c1026a12a1e6c95d08d8acd560be92116fe57484bf0a6d283f2b1be076d3ef8947ec061800c53525b46884a85ed0b94bdd3a0cf3107c9de4acd915b0588ded4dfa61c74c500ec8a71f769ba092f867495f8bd0d0fe63351367e5b32def9116d40cdac2f0e914e28f39e81fc226809595c67271207f7527752460be3d7072b0a650b41114a773a97c70b72c25916eb93b28f5c2c649140354c16ff191231f5fa59940b880e1d1095c226c691c7cb97b4d506395015e6764c5f78b928920838817508641e6229222f28c0b520d69acb6d11284d4db1ebec81f275689e7c412b796590293ce781c8d56033bdeeb78271fc0782aad7ce1f426d020cc22fa33f0416b7177e9acead8d64648c7b4f05da4ce0953b9e3ee662ae01dd921576bb2169fa1b1c9cb6c4debf0694a90c1b0af7bab4e92473246f4156930186ca20b337f07d23d1d30ccff4f2e33d4adf8f31e35743d5635d2afbea13232caa9675ff538b25e9352160d4db09138351245f5f1012cd4779bd4d2ba8e27d36a6d9c13583ec1190ba21e347c415941eeaf050b2642508f3650f690eec67d88f60a11d1f427c27dcdaee797231d492d333b05a88c4eb24ff22963be0c93d724f8d6904ff7a1b71c5c04c75b904069324c11dc89fe810742dead30aeb3fb776301ebbcff1a6838a0a938ff3d50d8a4580504cd01ab7ca4cef402fc05466aa1d409c789a19ab70af819a2c4cc2ec9acdc95c1b0a19910918b3c55b64130860d09308f8f1106ab3a803c7bc2f80a82e70cc963e2a6b4a4aea153aca2e495295d9aa64ddc3c9eec83e33a86148ea51a959ea5d1f91bf76ae678dc2a7e5534355103def28e378d08863df4b9249e581a3b8afd597d48403886e8ce6290e03d1a430fee5302eaec03d3bc2e0e7869580617fb27f2755f8ae4b8d2bce6f9ea4b84cf0094f52d9eaa81a2d7b603413c7d33e5b828c7867bf3aae81917273b223eb71150873101813f6c8e98c4e8673a112977ef02cc01f441c6ff02217f9f825fd43df82e721dad33365cca2ff16b8a27eff498b2f6b68f33a08df79d2a251499e62b297353c5e29eca1808c55eb5cdf25066febe2aee89344fae5dc8d82e3f4b899efb72e8810b6779541208dc12782c9c70d5013afe1a7cb1c0dd680d19caeedb3f128639c973633ae89311e8235a23f501fe154791432211d99ddbdf9995b32378c9f2f5ecc255fd39f7852be2d7d9768129f30036f833311776d9429b049aea3e7ddaf5d06bab70b975dad5a848dc8034afb0ca40d193cf385ffbc127816c08720093c025d500bbc323873437bcd3956d44f881c9d3cc75424e5daa0c8c6645fa4526af09d7d03d3f6be1c9ff8d160a71edb9681c953c690513df80946098591695f024be2e20e60504080cba9068ce930b507f2f2df21d5f2103fab985dd427d6c4ca7b686b288ea21969507d0abd41ee629da202d9ef9862b874d02a4787f5f7cb2ac048a69d92f0290fbf103d6698442a12c252a4e079c368e298517442ca6d6c08573a86177f70af0d8817c0ed8552b43729711f2e9b8663ffa8848b3a421a6d9038998086d6838e3502193162b10fb1c680be8f7a8b7f21fab068bc35df664a8dbaf1f6ac0a22bebe97afe9937efcc2cb7a45e5f42d9789b1e5e813013f498d6307d2e84edc8a677286a0e70899696c7f271a8f38e6b39e229cd0de72e488559536e84f417d899bd767d49af53b3f460b976eacc0a56ef2e06620beebf8c5440a326cf19f009111c66480bb82bb6228816e5be566de89dc6788e2ea26d3a231001d191d679679972b11a888fb1083242c110518403723539f97f344d52f755272f52242d2f7f5d140d432f3a35a72fd4c13bf062eaceca14a4eda64170aab34e23dbf5ffb7d203fabf565396f65aab7b8f7709c18c099bf537e20013e372a354ce455bf411f40fccd3de46330960c83f4eb5028d747e0c19c36b0fc61863f4b64ddf633be229973bb5d92b2454a8101e286e969b3518b3f622afe1290388236ae686c9350666a83a3b47ecebf5b9e599551dda66e9244e4cab8c7de032570b5b9666fb569a0108b04da2727f2067863ead5f43cbc21f3b37732b18c0c8d5041c559abfa54baa02f09af3876970b3428d306bac59f6f3ac0067312deb3899e30a2a9dfd135f784af6b637cd71e3883d59005aaad0a430270b3826a39d18a3e7fc24afdd4dd323f1aa1bf3e3e53d44437f8d7ce21ca429a9e766268bbfb48c0eda373690bc0738869183ed3d7e114a46ef33a2a1d8e4156a5018987eda0c48cbaabcbc139eb107da6df36b76443f8982fb29feb2708e7b866642e348da7493c81d840881817a6900720cbd165a7804e68e03dfbf3e611ef433591c8247d3fdd8370f732e82d1294df01d837122b2bf54135dc28768bfa7a5426cabfe652e9fe1d97ad5fc46650ffb18bfc606f20ddd50675dad1da5335548ae7555205c46577d480aee1b5bdd9baea9d683fa3938cafee971d94729e5469bc3596ca7b0439fe4106796f965c802de38a96ed88460d9b15f81108dbc1dda822f171e2ee6fe06137b597bb0f56964a3ab2bd1301b40d56aa7c0576a5de5794f296fab93996540aa5ecca9a1712aae5ed1d5f06454b5a5564d26ed5cfb5e9c0fb174055cabacfa5cbb539e4453e445fabeaf32132464a9c10e21adab02e78a31499bc9887b97f09a48c82958c099c77a707edd0acd65a86c793acdd0aea3d69993e64f4b4ae6ad42a0b5988a91fad3f903de37e33c87db26cf2da8df273a7191facb1a84eef8ef308a46d6a013564cad5bc1abaf65fc4cb73e170e0be9f2fdbe56a2ab5373e26f80c99fd237b931a0e72028ce695b9421ef8f09593298a6829861887946f2fd9e1d956ca256b339fa5993394c6d8dfa9ff238e257a63d76151d688015ca1b29754d39924dd0fcc15a4111422ab15ad40581f84b2a70965722977c4bc5c5b39ed1ae48772fec487c0d43266bebd0c7173d89df6b","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"866d10a5c8fa1421f11baa3a03887662"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
