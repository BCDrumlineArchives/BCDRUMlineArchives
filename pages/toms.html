<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>BC-Drumline-Archives</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #2873ff;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #2873ff;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #000000;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">BC-Drumline-Archives</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"d3659f9eb3fbbc626f49cded25809bf4a863764205be9e4ff8e7715750e243e0eb819835c999fd1e870f754d52b7d0e323d19db9a4ca6fbcefb1899956c381f3eefb484e318eaf54beb21fee77350b50034d8e34e912b24b8337279b72cc78c415ea528c5bced87a63d475c5e6847020bd40e9c4fb6ed5ee1d20eb7bb5f584e5e71d5bfa191c6115919d42694507a1ab8d04718ca996c86bcbbbda3cc5439fe0854e7a151025ac26de2b69b5602ca751468a8fa2aa6c82de843f9c1ccef235cc47d8d57dae427f495007822c318c5ca8aab5efdfb4fad0d6431a3de25f08863a3c19fbddd3fca8b7bac66eacdc1e4b3884be78498912fa436f15b032cc6a655d66ccc08b8430abf3c9519d9f6a1279715f57b72b00062dc35d0c531bf3c2f997156adaae258ab34d8c6ada2d800ca68430874621806c38fa287d4a625b5fdcedd012baa4a5432358bdc7bbb7658640c6eef29c3dcdf0a220befd20b3ba3aa6c05a0da2c2c4dced40f51fc5b9600b6c4de089108ed50f3220ed2775fd57a54721603dfb1d124a65d631428c9c3b33ed2f852840c0dae2bded68a21e4b7446c77b6d83ff71045bd4ec8d33ab1134e762700d454b70db461f14abb4ccb00293038abe9c67ecb6a87873ecd5f606dc624bfe93f88b05c38e99e10dbd59e86f6df6a758759260552467c057948114fbc9e5d948c3e71c8bb3878884cdb79f85be7a6140fa3a4c8b4b7c7a309d933c7574609fb79c84b882a6a98805f99e26910f91e7beb6e51bd0e17a410c6fa81fc0545d7a11d0d2a9296fda473eac1efbc782b900f44973d3ffe5d7c88ed18324ddba9bf4ad1413b0afe530a9520cfcfb73c6981f37c43cb20639236c8b2c0ced437441afc904af0beabf463ee2a02cb72bd4166d9932f4b7fefb2e058eaea4628cea9bd1ebb32d944f7ae043ff90c43b2242e92edf1103162cfc38afc7a646308ce1a10a51d5bd1f122838fc6f53482fefd0898effb34c16fc3df33f2b361bba1a6f9edee19e50b810fcdfdb34a59e713a8421a124ad5e07a7ecb476b69a459513defed2f96c63588b3cc7d574e8a8401109b8d67f3a9c58904d2f98e94dd2a4e95e9d7493a1cef5ee069257b0e308b4aeb0023226bb9418be790665b9cc45efac8a626ccd7ca01744e64ca1d5c2ec262205496a06c791078ae7b4cdd811acae7bcd4c850c686d69a4ad23ba036dce6dea7c3cd65a7fa181f68c43a0e6fc20d502bb1c5b0adc5a345995dd27a3e9f8b34097a43771d93edc91a9f0c93c0c2f1c483c91abfefd9e1591f7a2a0f01a729577d20592ad8752b631d37afa5239337ba165f7828034d374a5b18587a84a6379f43e536bd250b642d77c1ea259d3993bf477c45cb71f8ad2d931202b0a54d04dcafe094c05fa67c931cc5c79325ab59332e4aa6bf265fd5c1ad61b28a35c511e9c9acccec7d0d9f69be17a9c0d09138c829c232ba29b6c1c9c9ea53961f893ac950727ae89350d5751ef854e9b08807b1a519e897476812381d3e64a009e5e005cf5b0a2552bd0fb1782ae278064b0c02baf9db34015369af14bcc44c164b441444b29bec565238428c0bf2d6273ac59187b60c54787b1848e8bbd59c38034fa0a576beea521cdb067cfecb1e9ace92de78696e7e2ac4f5190fe2c290fbd48776f1872fe92a090977b4e872fc69c5b2bafdb46c40467aa8c44f96f63cb08309cda7dff918d11fee5d089c4d32b2d257e395b3e87e0bbb8d8e9c731487789ba28f741a36213cea0bd94ec6b12ed93c6a8c23c482075aeedc917cf05c3890c752b41101f6dee158c47b552048adbd8a68cf04cdf6b60535973f178a1477cfc605c5555bd56e13bc6babaecd3dbc666098ae473f4ab37ba191f3429ba565b4bd5ceeb87854730717fa718986568acaf19d02ac10308ec8cd0b41e5838a7e66fb76e76d7212da73dc7c18578a8b4e3922aac3e9f51d0a34d71493d7e8f971d96f86d5f8142c7db535cfac99904687409985cec79992643bf3c8ee96767d5028223b3e94101de2704582c35ca38c54dca1fea4733be62eb0807f07a7967537c5144a357fc626eac4c8ce897e8e0cfe707a4db9150593549f9f8f4a62aaeee3f8128c031ac0974a945b33761a7abdb1cb510adc9d31f04a544650885f81b9627cba5258046a59281244ff2d4c7cf7beeb5a13bbb61d378138713438d4218c2045955e71e2aa25f29bf1bf8bdc9baa655dbde6257efb9a5ef38bfa9c766a77036234d580f7a59e1e3d6b983e24c36120abb67daa1495491de785c432f40886464359dbabd595b5b4243f2ef2a7bd9f01c7512b2a33214a101fdc1c185d1ff1ec6bd640c92867202ae2f66e2cdf8105db8c6102e6a3a4b9478f9c47078e70660f3e8adc4fd1b6a5ebb2e106fbbf59f999711496bdc9625f836db159fd4f6407d4061e199ce0749568b0ea4b1bdae98170b809ac20e3f4daf902181a6b76bccd0d268ed97748372eaf6bd233a925b2e077827a776d92fe67872b08254aab500c8bead966b32127ac15fdd89016311fd86fb36088bcbef3c00a170a9f08681ddd95e1e44ebb8e77409acabbde97b8af108ffeed8b8b07535dd64110cfa3a85d43b54b38b5d26f8fe48f8a7bc65e02c181af78b566f01317355e069f0afc969f79a4413f3c611a210192a3ffcf9d6bdde5cc51a8ace0d56c032b585f7b36551cb671b27c25f1bab35bdfed086f37f81f5ee4d9836ba0c457d1f85a982cf43c24720e647b65618d8ddda57fdc9182de5b7690ef22a7c198412ed22fe651bf197146e25c409aa5ed4a54f884f50efe8d1ddf7a3c5703cca1cd9c4948fe040b84ba6aa42fa6bc19803cf5f13f6ded6dba2d129b49f9fda4aa4ef56adee37fa1b22243ce783bbd414bede1a8e7b335a9b0b245d7d329e42410e240e8e68ebee914035e12297a9e3f4c5352c5b51d661740b988085d45134a22d3e74ac1d50a02446ba008c35a9a08df8ffc4a3e3a1f58167cf9a5e5330160dccf2d38641946bc820dabec7be0eaa22901e899ff0060b822c7937f4fa903c8ae2b74cd85d960eec4eb0f3daffd474cdc8cae0c41333856c48b3208a5c62e7f1f001978d08a0176517f36806259360537144bd7fa281ddbf4c2cac53a6880d4d5352ac7efecbdd8c8e51e81b9808efb4c9390117ba8279bc5f1a70c4cf59d900e47dd3e30b391a78560fd0dd53095b96acd633f8be1dfbd421dd5ec1c09d763929da64ec9d7bd871fc39fe30be60519136758b47a84d0ed07fd6ad2e46efafbd4d95de0db4eb6df75c3f588b471bb64bb5d3e666cf3c45f4f2aaf77b3cadad1493d654488ff79e23cb5ca72d821a00bdefe09003d086b12496873ec4b9db7f61dfe630fae9735f4d73c31fcfbfba8d278c95faa46ee77e287b6857c0a3e3547b617cf9acffb9e8476470a57f945023ac8ede4d53f3085125b16a2ac5d0209ac913b433a90b0b59be6a82b115bde748f432cb917634574346b7c8ec61f9fba5b68960462f551a22c5b18192cc4cc12ffe2db70c62fdba33fbe67221de72409deef559e8914af798a4b32e4dba9e655455869c020e72ab25b41f22045bda34d2a0d3ab73526ec8aa079a499e84f8723081f57f6c111e22a1933b6f754b1e01422f6e7f94780942e3352be6847820b9641756902b10c8bc25fac0427cda8969379b697bbb52b4becbd53c06e796ea34eb27f3df34059a02675e6970e314ad2533973f61c50b7ca357cc8282c7b5083db885b8353bb88a87e9364b4c535b925f90c8575ec2ad8e237355576228e38715c6654f6aa071e51f2b46bf80e766c88881743e3b41026bdc893ff29fba5c531fa5ea1acaf188efd1d8383962a26c7e136bb386429dc652df3b8776e7b72d85c8a7ccb520595cb78c7b7447316d6d95f8aa906ea27e660f100219e79f9c7c404684f84babc518efee4a3344ebfd583d9101091c31ecb7258a6222a511e1f8a6deeee8075c03cb038ba9aca242719fa1bf596a002a08aa0efb2c67c61ece7f36fc710b6476af9928e7da2e8f235ba75f7b7e1298a27de1f0eb4034821de9e413d3281ec82d600e3c8007c7e63b431935b48c46e2d5438cb9ebad7812ba1489756d3172e46f50bc52f0820cdc855bfba9035dac391115fc1869902f867313d0a43414800b85e5abb470d519536ccede08546cfc88ee8f03bae2188cde175bda1573ab9e0dd31f874d7f3f544f7f3f9c44636e588affe8c9cd8af004521bfb8cabd7bcdb7fa1a072221654f08efe0ed703e6e98f94fbe882240ebf5122a15169c7b3abbd39ca690656be6274bf7c557376fd6de1efd931f5757fcdafd31ec161f2ecd5975bc8cd6d2e1ace52e5e3c1ebf428427f114e0c09b9b63d5647be42b4042ac42ae1c964d7abaf97c9d6de7b623b9401023c8e48f3e38cd07c66a34cd549ecb83ed11ee90246472fd6186e4bfd17201ff84e519b69697b3f059c0fc6a4b65c04fe2eb6323a156556fcfa9763576d0fc2144af6ea09243985a6cd961cd56214ef9d5c77bdedcadfb2c14c6d7f7a5c547d4b00f10a99a731cb3fdd0021d41d7f65a98f115494f8d917f9f45a7a32e90558533817f52487831949cd1d0d470e1fd7107a1a3059f267f2bf246e984de589a253b91cf4d5a9e4f8bf6533eab98788099ba6cb4e02b8b85dadb34306c24ba9866ffb396eb8f546572cdc54a60fdbaf2c55a8b19dca8cc8e03d5f1af600c8731453a3600af2c983daade6ab762b3e5d5e563cbf7fb145c7b76ff95b06724f63edd947528befe6bd3f12f6927e4c8cec72f39da5454712ee712251ad9d91e1262803fd8c1a0f60b9701b6b95971d8ce8d4d32b6a4a5bbc07518ad6f72896019d2520bb7c5b9b92a39d6bde13abc8ac8b20279221d06c2c7ba26583e7a893d472ec499a3bffe38f056a885f0b29f2bc4e6fd3e98e31097e7ec2d04173768bcc9aa972a825313c161a248f07ff7e4d14e84c48427f6c2d128ba8582b6ea01a0663ca00824e1a340ebf0688c09e19642993f496518b761c87f14f08ead96fd29463bf53dd121ae7a0dbe9ebd18406bddef80dabe35f31e0a1b0c45e8e5f888085ba1b970654f9622f8cc3d48f944a728a31bd690bd79e3b4b1a69112c4add7a4dd23f61034c1daefffeda3c9a794fa7d259356d86d8b4b3b6eaef549aec2a68ebe95b46a3dd75300c1b7c6d76f6bda5cad037f0a8d94b562bdb531270a6348bf0b3db931ce1c0771d317b1b3505bfc4f8cf240a85813ec090435242acc4a341703f60f4491f7935571309363f3173702272991ad96b1ed295d4f8dbbefe21f604c2943c1e68e04d3977c372c9d6b3b3c2569322e22492a25b4329759e10b370a2f7453a9c35c165d2fd80a7ace56d37c8adb3873ce9888306dd7dcb5c6ef1848317381dcd4b41f47b5131faec36734d6af8f9f8968858b4aa45473f34a70d83f532f85b1daf8d2761c1b001e349acfd9fbb61f4d12a77aa4cb3756d0d68af30b99d9589e761614d5ad96f280ede43514b0110d012ecdb4f259b02679baae6021add56e81f671cd9d6cc3fada863c7cbeff05a5e0a3f2352b74f9edf927f623b3181b8ff85765365becab802a764d05a3cb9cccda3483570a12a204877dd2859e5498a7adbe5addc148f5b3d7f1b6357cc11c7bebe3c787b1796f1e20679fe2c7d2497f104b9fa7d8dfee347664a606dd8834dacc019977cb082160483ea13bb41a795d1c7cfae319206f17b0c3e4f2c45dff5ae66e179c7ab4da8846b379d0ef514eca99ab30ba463c74e1474571d72ecfc47c0cad20588d36d2cc7a6ef24038680dd9cf1210999ef57ab5514e0e1080b13ba83d65c3dc66f8d5326d3c26efd5a1873c7be539549804005b42c9d1b40d1db12c7e6ec35643623775bfed1c92a9f3d0270ebadb3cfdd8e8fae65eabf98eeae725ff7a3d186f3d3f9a5c7c2e0934b03625b515692cc532219a8b6b56f83158e9463481b651971fa703fa4deb459b69434faed4ae34adec670ffdfe1bd2f8e5b73fb572fc60679a782f2f1524852703c42df5148b50624ca336746b53b7867724e97a13e42fe397865d31dd1a022068389e4d0b3be4bb046c4981a4bdef28cec2c55e174185cad304344c83afb1e601519b537e22fd3e729ab76ad586ab8efe6854f65c1dd20b28f05b434a6875a8497c72673d47a165d8777551456a4f463ad792dd0967a81f1947d7890a960482c149c1aed101cf8e787815dcf79b846de0307811b15dcd12a9b6c3fba78f4ec8612702011cad6f3fa02c5462d41de19c4bc76c603739466e0051e243914835c6d4834a87cb928fed7a1fa771ece892edfc7841e4d8d7e797c6a19df272d923c2fce7fdd32328fdf5d5e56f53aa0c43e767375530a1bcc6f769bc11d3cd4297e0b58c1c9f47b978517da7f914ffcdd45f3644a422cf7ffc5372205c1afe866c45f3c31f1e9e218c776b8d2d14d06373c440d3aede8ab37c37eebe8991f3e0adfb70f115b5e0282754e6ee9690e47d7381848879d911af03ddc2aefd1392b14aefbc93c30145fef99cbd1c60e475342fdd713fd8a67d2959b5f538dba9a6d3f91be6172688ed33c3f7f720c5e9b19d574219e6add076d84d2a3940e9ac02aba6bc39878de07a3b42d6b043edd1dae103f9036fda37ede93199aa9064aae6a168927593dc6b62023ba65b7312beed1265c4e84bf2f2d2d4fcebba7999e79a19ceca25fc826d0941977c3c16b3e7978158aa36bdd83b87cace6a0052c58803e446bd7e0afdecb4cda9bb89a3d341442c5772984409d2ccaddaa4599252e8de6932fedc374f064efe2676d8218b85e1a78d3c117e65b32d0fe8f95a53addd3462a5e0cf80d2eccfb8a70df8fed4257506d271b22ddd7f7e20d64b7c2d7829e8358a40dbff5ef033e8dc59014012dd3a4954fac88f9cd9b8e383a75b5920c3de9e80af9b593d669e74961c1f8946b63ccf0fe7f1af70aa630237f754e3abcc251807b6a58d1e11d59c8a19e2e69e3fd9782ffb1ed9ee8dc4d09899bd7e82df452560066a8d16dc9462c87da647e8be65bf264e287218bb605ea893abd58f4e17365edebb08a0493e527103731c78ec34c13132e8b9bc1fe7a00020d95693e535fa85877aab71c38d448a314ed26780b291bd134322dfe01958200ad7ea1c06afa0bddc1c30d7171b25b700e67afbe1b57f7df151674de5da1026d9c90025cd27948c1f29ea248f74e82ea391384b476cd70a5f8ceee2e568fa667e5fed48d64f3a8e26c76eeb09999def66565de96b3099aff1f4671b255974857eab715a0f786830dfdbec983e48dc7960b684b351f9cd8780875f01fe77ea2141435e6bf52117cfa7d01c3ee9152b43d1539ba0c775d342809ca20c46b1aa4976f7f82140da3d522ad4edd0930733e03f165c6b3a66315ff9af43b9f8bae611c87124f7ab5db2326baebfb96883fbf32a16251d04d47f85d6131efa87c1ce8beeb985eb9551076ef6b79f43611911cccedffb3b9774d07fd9b109837c996cc59527470bfc8db48be82290a4b61a910068a44e63e7077868041c686fe5dbce928fcd0791cb0218e04f63daf0b58fee00803925df698f38296c9f065d54497e36cf72b843f8fd5f2572a9f68b9af43117e6dec8a76e849396961c64841ad5067a23c890937512cd70baf5abc41f799dd0d17d18b21c0248464e4b6fd4cc87219851a61b32df666b2c492a38baa4e020e62e4eef26d4eb33dea2564edcad62f9adaae5acc975274662c9d543fcb0182bcacd489e7b2b2d10edf82a16ee872f9a5381dfc72184367dad4c0f5d4fdf5317fb696e0c1f087de507ec64e59ede42788f886aa9ce94f279cf0e17079ae3cda2c2f1e98c4ee4f3c1fbefce70d75ba511f8bf76fbc5e4ef0e4755409341228836b64f662fd3ff48a8777a44cde6ae8330941864f8ffc24231ec8e39fef7b868f6ecd379be58161792bc57880d4407778937392d06caf73cf7aecc03998e2e4423a35a2c14c15077a3a04038b175d98ef2db5111bad364cf3c7b23d699c62efdb22f515458c02c2c63dbf5530e088e601a736418d4fdd1c2af269d33ec2e32b1b5683e4f141eaf00f8d03f59c6f8e241f47eb089a284ff039ead52c3bc7c63729557b7085b63810cdef8400fc7ab7401613cd67d8e81a2fcd960fac8cb38f50ef20f4270d3ce0ae6306f7994dda486d20f0ab1b5877e4b4908b8bb2a503511c2449ca05d75f45a6c0b0aea2fb4376bff41358168ee076610a3aea941656f011c96a7411feadc3cab9b3c5f34bbacf92e8f1f4956f9c530e61bd6222442a222f5e2ba74061425918e7fcdab154ab8ace41f308ad4269e48974826eaf99aa1e97390d5f0f74c8038bc3e1ed96b4388e9bda2cd9b51f49d520466937258a1cc87f4579c18c70c8d52fdcfb154aee16abde057a3098e0ec358100ce6c8be075113f1ccd5361f3d35f3e0dea61722fd6e45084d478fb1f5adeb6e36dd90970c6a80ce56392a1179259eb36ed83c3bc1545f83a584bd71aaa3543d4f4a06f2e0fd3c1096cc3af7e845512f36cb93da65420f0abafc978ff168b9d6efd8f5655cbf5bdcb97c712dd39cdbe2ee010fe6f5dbe4f3592e9eac5101ccb54cf22e366fa72a3822e2c9cc0f42b1df3c50d132bee24074334ad9c3e91241ce7bdd0c19fe95c71331a6dd6c5fbd2a006e133c3169ef7f98efd15f06efa4840de19c36ac1c9a7786ee334bf516d94b0099f876b8e7dd79299cfe9aeda2aa9f4be25138637735771fcd6935a62d17cb27cde5b2ea7066193692226d81fee31cfa3c9e6a5596efc7b2a4aa6f61708660d32a7d6d4c5b021619ba9d20bc9ee188a67c93ba1a1c58fdf04f0bd9e31a79f3a046661dbb11b4956b106821e68ae5ed6dbca75a52bfc132434eb5ea6471015acdafdf5aec508ee7ef45df140dfe25913867f6388545b6c2d7b8624fa7856dcfc58a38d0748f53b06a36fe92dd0d0d12811dde40328726cbd0bac919d7efb00751a6baf87479a64bd7557d8a94d6170e1962b7499332e35b30c373f05d739dabd06069e4695d1d7a28c1a4666a6a7ba5803202fb8cc29b6f723d94cecf92010c4f7dd93a5dcdf9af23bc0624f8b03d43170fc9414d0f603e477fe63038aa0e1e2a1eca94cd3e28bd524b2fc734b723eda302f957f5c2cec771a87a159d0a70f032c5c46a889199c53d9b4605b7820c1b042419d345bf2fb8a72270da9c422f38f0a8669f28c152ea7c577dd5dd9ec488c2518d82ada174ab24a069b5f53589c611254af428a01e3a6ef452d1d0b9fe4ce500aac1989e09e3dd7fb667bdcb8eadb5a90246d6582029524076307b52dba233d89b0633bd45dcf565a9ab22df895b942d278109421459b895d10742c49cc20ccc422f5f8c052ecdd21b2c27b4c6cfd9f928c4f3e93a1b08fae749d792090c083c7d8b1ce9df431e80ef3008275bbe0b974123dd059046388a53c0d22e02fcb53020155fb42a21c2fb7060b0b24f536bc26768cee8b3e55ecb6f4fee0be70802dce04958426c85d56a344e8eef8bce96e4ca7e455af026d8336f75fd7f23982ec0171c60cfe43328f033304d8e31999807e11476b7a9b9f89f233c464f32708d84c86b1242a6d63775879a1f1521adfd5023b34f4d7ff96c52515ce533e8473fc53b6daca8a33223d634aa25a7a9de108e26444e7c9c5667ba8836d0a7d8eddc33dfd74090a1dc850415ea26ce6336897035532712dfa94af1f34783c97f1ef066d7a42f1a8b2f230b05476e9a5cadd839ee39665734a044d26ebc76a07b30bb116e4054dc0cfef1a640e7b1f684888ac643e07143ef45b506517a065d54fd4cb9b5222d3e31b26bdc38965449f7a4f475a63c996fb7366b9aff1de9bd144cde8c956aaaee5d52c17df8aef5684120842da3c7a02764ff8a027496faaa91dffa0a6f6b5d72d658ad1dd2c9398af094970f0e7dcfb838d5095d8248d6defeede125d5dfed587edaff1dc12697297e275268d08abdd0786969d20c1174c3d1c8f872fae61a500569d71937fe6c903bb43dd15eecda37604aecedce638ef2f2adb8df01768fb8e04e145da5720e2f354094faa59c8e402b4c101af07cf6fdbd399792ee43e4e76941c5d6026536fd745b144c0d80e8f6cf3812883fab56ca62a8f721d82154bad25ae9db6e6a2fc8c6bece222ad1971b8143cc38c0013edca8a5afdea496bb1c01840fb5b3f49a00e6f6ad0e7c43e1622b9acc969b914b018cb225d9a050cffdf9081694536ffdca811e96edce7652246f6ebaa0e07247e86e7f2dce932f82e948268a14dd85a9fc04af640d3171d8ed08184742929a36322f9d7c0af03b5cb030a5162b66e50058cc97952d110e25202d25d812c93c5b08e1dad5079e46f49b12ba896faf7e136c4d1349bd4bc46506c08dffe5526ab94b496f09f9365af9c9af4c6ffd5a68ef1be567c8dd56449a3395e487e3d35dc6d8e17c72ae55d995a8c8400bebb0f1fbeb7e2a334f0e19d8f077c61ba2b81b5f5979b27701a0b2a268192576e1be0c699d533db2863dab5d27826971a197d87acc5dbdf7943c14f91a2d6a895f80b703ea34dcae931255a76dc65900506d880d056aa24a0ebfaa3ecb3c038922919ad1edc22332d4877e6dce6941dd35ceab7dd5c1a1a7aa100f8847d65d55a5e9623fb2d9753a6e4262712a615e12c9aa2c0d988532088ae26a93b135332836cf16fff526f005a08ecd782c1d84871c2cda3106171224d55f823c2c3702f0532dd174bb0aef482fb6ed16ca6c436ccba466ca71e2ba029c51bacc2c85b7423fe87584dbfc9b22dc157ada8fe98b7189d7537088129e0819833e6b43cf463578b1ab6a1dad4fe8c4367239cf152d752a7f451246b2fb3357595b5cab7ad85167e4048c1a47f19c54fda375b5086c34cf32bd025a70581d458ffd54c6da6ff38f7039046e294f0544dd154f7ca71d4381c90b39dde58d94e1eab8f8a6607d704e345862038c3b4ac8bfd277c729f0d4735e7ffac648eafb7858806a3a10c92a7ba77d9202079017334e13ff6c194d50c3737b8732e7e9bc3c3e402937f74498fabdc8ebd6042de5dac32fe063149ad4818baf6a285802466dc52bf7cef8966b022e7805ca45bb020e9f78a463b7053534a390755c4a4fd62596a4d0fd8198f07ddb0d2e63d6c4650e5bf9a2e466ded2f8d7d1a83580ab981d6fed07e3387e7b3cff6267162735cad79ad19ba2fff5809a092549ec3b99ae25be00e6cc657a753638dce7b3b2faba1298dafe769c06ff9f99384fc0dbc618033601496f877b783e10668fa2618f07d8d44173059216da7d1a56005a8498d7f7ae97c165a35ab35bce5f1efcaed4214ac0c2cf2cea376504c1214a6419b8e2481cc3e12d339499b7f6022665005e8cce761305bc715be22ec01838dfe612de255fc1d31a29ad7c1ebe7eee7be552e83c12c6613d16cd5b567576d5901adc3e8ee110450037530a968e01acbd2f5738a8a40dc17bcc458690a64f59df96c71f779c56c3dea65674f1d77718a41786415bc7076b48208b591723dfc8b20055cf6cd120da6e5ddb92f35bb50a771a35232e7c2f4c73c894b70b1106341488baf2c853e8fdd39cf2f773e242bcb1ccb5fe8716fb43b5eaf19ddf84892e3a8a1281eaf7de0e47efc2d83cefb2208766d9561e4ebe86487509072d5399f97108e2ef582737569e8f7b15216db02c2cbb5fd924878649940b30000bf299926d90d997d7aa97db6f9bdc7a9f3f17690d4f917eef92b48835e0e17a766f798fde31f18baf1970b908638046427d4b802da9c2adf8a626f80012a3a0734f41c8865b384d5745edda899990ad87dfac13b22cf06a3b53008f8b0e6d095821567d378f2210f4a8220ee9a90d2e8bc1a699a9d2c247daabd31ff21b98ebb619177478e5a5e8cfb34a9bed87a889e75dfd451d8a49ed30dc7824904c930cc851768a662670896c5569e90e85b365f11c49e3ee29084b0eae26dd4818a3e567cdbfe53b728b4495c6a74ff58e0614a61de335819bc894d17065dc61b4a75bd4b0c1c1cd89fb551dd430f6f6d8547b594fb7d2dce723a64eef3cd6f8c5c8deec93063e5859bdee6729fe54313a9585d7bc03b7f821b1456203890f0682e074f9a104239a65a5f3ebe19f2933c6163e040db0f15e1fc79ce54303d21ffd75a89f7f95ceea6c652bf64be2cd04a986c71de74c03485dfa333c87aafd81a9f757eb5ed3c9b44155dcefe1b99a985fd3e3ee6c38aee3f85876f2e276a05575a4afe8f051a2fdc4a54fe22403e87c3dd45546f28be1a78fb5154a12bd7394ec29c141132ccd81f21ec20de43e98f70b53d886f002719592ae2caf52b3d0aee1f89aae3ec8ae8136deab0b753ed597caa4760e6cc564380010918634130e5602c405e48d9c97c6fa4f18eb93ba7f7f73765474a99173cf4ad9d609a8327fa78b79aaf7194233ac70418dc0add6ed64a4dbf672447e524719a221219551ffcba6bfbde3ffbe0a08d3c47a9d1f51f48e8377ccf5a3c0da6d38340af89e324e6db0cd522c790a8894b30422ef990ca60a775203d3e4b30b8326d1572a7c5ac71615b9e4d994596415f84749a48cc93e818fd5660dc31049005b426e6da837508d22de1df5029144d523a702324773cba5d62b364a0f54ec6a1a6ca1f6d702f608e835fb94325758d6c1dbd8780bd84e180c1c39b402f46dcc157b1e3a576124eb932c507d63ffb84bc0c68aeeae043c8a0727ca7e3d63e7c714be8206174b9ad5525e0a10637f66686ebcbd76705f6d4fb2e4bbcaeea010a530febc357ee01022b7e6f1e634de69fa622bb92147fd12efc544b59e99c77046cce5f920f5a746686233054b19186afa249bc14572aafddb2f9b789086a0b7d753798854bbd36716c43dcaf224352ffc03034aecbd2f09e526ee8df1e9e30b66c8b7ac2fece5a9beecebdcb98bb807269b8a9c96ee023a501bbfd8d1e7f6ff503c4c50888801848ea3e4cbadce1b9ec2ea869f7ac48c762097f55d50b15650547eba8537e8204298a75ef2c6107ed44fe9bb641f1cc9c95d09dd0982499b4bd054e5b452cb50bb8f3a0ccaca3ef9e7091f9e3825217daa33c14c49ce1311283c868d1eea532df92eb6909475ff3111af4a63834c46fdc040e15019aad4f00e2f1658cc892b4fc2b4b87ff62f1bcc44b20eb75b1a7feb7898f57ee49b57547af89670c39f04d07a75090c5a2937f2a18ca7cdcca8061143d69d8fac56f44891e894c403900191e032f8f6d9a4c90c1e9592dfc190b6eefbf85ed21b9381e5543431f08b58f42a3d58073fb07df0aaada33ab812d3e1b84e6f0f2814d190776a86eb31109c1f3aafc2f096303fb109b2f02909404e55526887ff8d36c6b03e048d43ca6d0b2bd441064467228db98d99b51cf1708c20338a8b82bc00f7af1b66c738b8c5462db18affc2d97ec156a51a91a5183a74c0ecdbd7be96094d7d469322e99a221bd478a977324a86a9653208ea2f9b7df11977720c7a9ab92a446b6a75565b4c4886e4590ed500c43a7e06f0ccb0d8c1c158655dbcc73e06015a0706e76124f23f8a25e2e93f296ff656277673d7b872d5e3c3db19b9fe468faade7d1fdce97c301b4d10cd6be18c5f5b3e15cd2dc2c117a9d8d6284fe2475b9e082d3d15133331812438f3168a5bde094e7d3fc3f359dedc1682fdbb32aa250eae864640476f16a6106e53dd9a9811422c5ea9850a4b3379bcb8e618d87573d4407593adb46daf43aef18fd83db0bf5e9195ad2855f19556bb54f847b72d47c399fec3a0967af46efd3271cb0968a7a2c27bcafaed04c61502c8ecf9a7b684b395162737881a61d25320bf803da85d973457f9f5d2a5b29f95bcec59166791d46d882a1ad37ba93668c7bc97dc73897e9008787cda18e7daa45cf8e00280d992b9d5a2dcf937aa99caa4af533868b94254cfeac9f9c1169847e373e3a765fe57dcd182ca12eaa66dba3ef9015d1ae565df523ca33a3c6a2bf5328f314ec440f6b6220f66032a0269da19f577f4aa50702c9c038ddac91036c14880e367d98a53692ea6dbebe858b1433d972bc8f60c5c22c3564201d0637f533ec3129b4a8b6f5841436c76de95ec49f31b29f6a2c58895ad4db0d04581b444832370b8039ae98979cfe78a9c30b29a4629a551c9139474d5a2f9e9391819756c523c9f58d1e0bbf9af497d505027c05b0634940bebdc099f0b6cdc8f2b1bc1ae868e4b6c8028d899e14ccf820bdbee157839d7b98e09902bf74600dc2f6858b957485ecd4a791e9e157f959daf7015a1ddf5d0d277b63c2cbc3ef15a2cceec6c0c43727b5ec2c9fb658e35890c09d95d77126340f6505c51c1ee61c0f18ec35b8ff8b28614d3b68c9138574a320136fe4b5c7bccb563bceb9eebcdc2c916beb779c4b35ed6bc59a01adeaf5782706d9b4518ce1e44f19734f7bc1ca39d6c792f0761bfbd2a40cb0e67f88994979a42371298cc412c9a45b0c8b45e9712999cdd163e41da3b62e6c518a60c9b7ac99b6c91b893d063a3b988cda5c056aaa9e3a8ebbb62bf5939f758a42fb653188f191d16a7e1967fb7999226bee0d02d29a36528df7a551f1a1ba16d3095f63ea7972149a22e94b8cd4ff1737c60d6d741f408a9f53628b935667f718db71d8861fb639a1395ae5d5699b8b57debafb65825f862af357621309795a85343d538e8797e365fd74d946afa066bfd94d094cc21b0539b450b63ec5d8c6c83a272ba42d9186de83a04777344313cfe9396b4695aa2541222f1e46b1f4bb15a9f2b3b29f87c4fc85331aae8e89ec198b18b143ec8b2f9d6ecac6dd9cd9767e237e0170a1917926fb6d3026b1773ecbd8052d60a3ddc08cc5e6a181442ac115d93461f606ab0703eeb34d5418de775bae1bc6f538c6c5a6e4cd0b86951edf1ebcaf518636d2f602500161c953d31068a02985a96006faf6ae3b92a6d55b2157426b3fd6fafdc4dfc594c22c58c9253dc08715976d606f969fe9bf8393efcf43f72b9068bd64a89d1f1495d2e2b6acf6366cc51b6be7b9edf4dfd19bf6f14217086e65549538e6a1c390ff5fc581cc7a07824c66823744f0466e7e3d6edf1a70392ee2f6e8817ac81e02c177efa6a2469831ca5b6f974f608247c304e9206e775e2bd751bac66487351b24c82d0283797895a7b221ff6d7bb54719389527e7a26a4a0abe1b21c6647791cf0be2e0afcf88c9bd85f8bf295000acff4ccf55bf99136edf10191b28804ef3dcbead017b2561e318787e51909e9d93547260914041d1a3f17922b4c4a8d3a12869110ff1c94fc6bc4e0e3a4e29894001e72b30a4a2b18d038f4683f7b252b13f0bd4fd48b66c42ed564e0ea2e9f4889987e7281f71e59f049fe1e158d6d2322ad076f0eeed583e86f7b5b1a584445c3b07ad167ffed38315754403b6910b2fd07d7136fcf1f80990a12517d8a7b3bf8b459fcb68c31d1710cf7d963351406fba979d548275cb955ef1c7f8629e8482b974ce069ee6c9c8c1e9dd2950acbc4ec68a67b593466bc3fdcb7b155fe6a5ebcde7c5db345aff89303aaad388809f2f424b1b6fdde2af38c09d1bcf10191f123cd8bef3fa35b960a905ad051e7c59f96d9cf617544f75b7a04c581372836f5b6fdc413dc43a8574c66f2da5d85ae76407b1ca9fa8939f43d5ecaf512d7e240ccfdb77e5a773cd66e7ba428a584473dfe9ba96d356730976a20415e290993dc53fb9c2bd12c0f8e8dcc69bf6ad63c837f0bf1e974a3c20b32e0f7e04004c2ac92e2168feafb111392c59d2139ce1d7b06524a5ba5c94651bb2a9f35236e2f1fd461eb77cf41cf12e797d2d07a3a1fad854ad0abce35351bceb6b8499c43c575037a981833453ef84ec4e129b9f591e77a36cf19d7b79a53a579e0e16a053659b47b2849b5d60c7eeb1c0cdcd9d8bc0637c91006db35d2fe1df7b876caa06f42b61e1af22c843ec934c56b6e0195d6292c21b7bba751c5534663a4ad561cc603b6c9bc3eed9d951951dd419a492486469342e3489de146224936727048849a3a3364511ace615d5f50ec3097e20ccf4033d7eb3ca8a867c0ca77c744f4ca7e7c0c92137f38c7f6c3165094710d9df7ebb6fbef100f1bfae065ed50a857f60f17835f71c6ded28a266b6efe881b92b33b802cbf1bf1f11e8ce592bfa294882ea424ce11e51805021f8f1c070ad685714116051550880c1854e670d3a566ab7572f9a5b50b9c0ab86f393292ed4995a8053eab4a3dfcbebe4a010c58b462126f9af68b01e3c7d622967cb6ec78bd4e9677cdbed1e7f0a88884db551d5c94710586492f3de05d6aad8a3fd0a675e97f050350f48084cf96dcd540c2e0b368e5a86c83886ea9c8c3acc74c8b70e1c9b08005d45c131ee9d86f96237bf5c92b37472221cffa29158063d2fe1e7a7d1661f1f909a8d27f8906a3cd160f61349e1ced30e2f47a7ddc9c1e37eee9511e802cfec5c05cfdef8d5ca1c4c04c3a2da73a7706ffdfaad9372f8c407814ab96fc0bb65d311dcb0a6f19171d0ae6760539f6950ac557970c0188a953d5bd3095083c9da07a2af8bbba83c387c536118b0043d790a7d67756bee515ee47d76e14dfddeed6f8532615fa759b77991ac356d27da0a1138aa70f361d190559987f286122b2de76267170514b2bac187d2b413ee684bc12ec74471897eb7603e8bb6b04483558981daaa3ca05f53a870d7bcce55860130cf97786aa6f63fe8974044b9948f5678b4f3723f8e5d552f47a321a3ca47a389e04a8d412450676895af480dfe93f835e9348358a484db4c2fd366a76cf37bc34ddd6416c12025f5138d785da79d34139cad664ea45546904dea75fd87f731a3abcda13b32c6b6a4b566205fa47639327da5e723f49b4dd99899465d6a15ca61600278181d168f704e3d36c64ef4dc19135bdae02accbac64f451a6b9a732b45d5ff809e84362e830b31a26237ab7ca7b9736d1a6785285d51554493ea12b1045c53a98a3fcee77247775ee0947dc1e6d16b50acbc2fa176e61a0a0581770abed8dbebbc917c428d51780a08ccf294d8768e969d4dda80584875c4209fe44af6370d9f6c9f959faffeab1a964bb426faf9f8fa49f21897e7993b27e6e817100153bbe59baa46a703bb42489463a03eb35655041285fd024feb8bd17fea716987328d4b4a9bfb911ed628f658a73a82ec0a4a79a836b1f93548a534f2fd39ccac30e0cb5f271ae22f11c8ff9c0630169375be992f2e14ae4e53ba44b9ae2dd28f92b23112397598a1e7ca82c746c3dd5eca7b13d4ab54671a87ef715703e3a16049bd0a0781065411f579cde584bbe9faaf37b1193cbf0192be39627b9b1d371acedcbbce7685a3f7c9376ac5aa44f552989b424f9bde242d155d9e24b3ae2ee757080d516ca1eb85d7877b598f00f9aaf2aa750fe4dac23750097f4a4cd8b541b949497846a2b6bdc3310bd8dd1cc9897b419cd85c1ec52d0cde3b1d91b4272ffded07b7ab19a54d41c1d558cd4b62f9686c6f67d26bdcb3efd682d6020a4faf064fc5060fe19c0141f8dc81a04e1d82b017c34f4f1a3907a93db1132906b7eb24759d3b3efd5fd24814dc01598057a036d5071f73e7fdff891ea3696ca11a559516b1a1f5c13ee846fc10c59010f4b52979","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"866d10a5c8fa1421f11baa3a03887662"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
