<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>BC-Drumline-Archives</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #2873ff;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #2873ff;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #000000;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">BC-Drumline-Archives</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"adbaabbbfdd37b742be75858259000d1033053d105e8dbc76cd1dd1fb1c7a51524ab7c612e5887fe1f8e4e0c3ce8f455b4d900d0987b07d14fa027e329b0ea06a64124e0e5eaf8a668c1e7b32d3c9b348a258be7682563986babd9b5c69752c40fdd3b2722077dfa27a90671aa06ad555001c8e0e15877abd66c8ca9cc2d2104e9b89a582703658e3c48b041f08951f372b2a7a70838d1fffee824dbfc19c3c4d035274ac6127977cf0514355c7fcfd56893e00b6a552e29914876dbb12940c899e54734a0f1f80ce745eddf76aa43b6fed80d91881e65230607b3980c75c3345f5e684ad7589420364bced00034e47c6c29a3af7fa7d4a0a3811ef19e74671e1f06aaaea3753c490075d4bd25fd42007db4c658ab34eea245738c6bee154509a13673989164acf41176769b2bbf999e6157291e4ec254b8a6153e4f80ff98d77887ff071796861a28442ed43f8b3ba0121e170485ace08275176b2479b90311e23c8798b234180a513601a8c3a1bc4ae89befe516bf2d7eb6f5b38b4cca996f7b1648307f8509fc82ea8e85972a8cd31159e0843b39dada27eb353307f8c76afee55ace05dd3cd49510719791c645cdc9834f9d2f5d467ab7a78abb607e5b5a1c4e5d8e937c512c1163b75ed45d47c31d4fd0dac180115710462754a1292f39b53d21c09e805f6c059dfc786064a785636f344ad1e93e885439f0cb9d1082bf666858fff5078c975d4960d08c39ed67ea08218dcb96fbb27fa78b67db9d8cfc4e1476940aa99a84c57690cc08b9f3ed6fb72f0b8d44845eb7690056dc30598dead45b61047aeeeedeb43bc371abbc159a6149b948b38b8556a958b9f16070448e9f53c58bc386cb4ba1884dfff1c8496579b501a77e74fece5d037712a984677bf235e8043d5f88aa5294ca6235e4ff31da611e897ba6a13ef619f9d1791f8cf89ace75a6f1d83d3033b1a4ba23109a2c911d0b53940085085f8eb7f4ea6a40a1bb01a53cdf32d6d598e961fcb41d0ba27907eb6030305cbf6b918592fe7a333268cb6f0b29333725ee8e6681419c80ccd030f4785217b98e05988f627bdb60a33d7029936c4e9d414fff48364e59f8c3a369cf02a502e9c4e921b63075d07a7785d95eacb98b7b89c65969d8e6c0f314ce4944a21ca3bcdc223f3ea7784931e7be3b7bc17ca05632812f12ed403f69fbb1b8025a9385ca66f0871919c8b9f12f85bd2df2d3cd0741493b44dcfe3c5765abbd2a7c15d4e94d33d02e44dc66cb7667d9a77b7c002df0c6f069c42c554308ed17cbf3995f1c446c38ddfd48daa2204ec09cc59a0dd08ab761f765b719e47b82e2f29181291be9005bc3de95fcaeb3994609d712f5d66782921c56ef0c681752622d775c9907a6c3aa12a6935714e1673ccd17bf06129e1b75b4c04218e100eda5345b61393093b62464f628930bae488f1a5e49923d1283f650016ab1d91514cc46846dd0e797649d50d8974556c1d050905335e2178b741bc9db2b01344a6e6431427b7da8536f343e66929d50c0c23af97db6afe8dfec20929320799c8e60642eb84d70dc093777d8db1fbdbea9c4439119bd18c7592d1f4a7417182202556275ce9499a2be56c7cb6d3b0eed8849d18b5f574270deb8054f1ed72db8fd99f67ae77d01515f26571d2776ed72f5006d85c481a0101859c8e2ed874161b444f5fc785a9e95319c9a03051b01b35fff9d98b99ab890766e0708e7f52456c4aad682530ef502d0b287408f2a58fc8ec0d3f3544956d9142accd916a3e312def6705301a29ae94fe305cf9719406adc4193cd69badb08849f216321c9eb56de1ef0aa5bf064c40413ea8fd2c03c17fdf3ec7a615782ccb4dfb4fb3de8dcd6e6837f58dc5bbd7dc7f6d081620d0f2a0751856301a9c2e25850809e73d169115f1084fed58b65750c63222f6b60e8e2f5c5f2142a10f0ca62b85dcaa081097894691d0a0443548057197dd16a9afaf11602cb3ecfa3f7e5bf1231e7fac68df08daac87cec392e3f82b77c6ded965d629cc1e36a31c672bb8bb220b8383a0474afc9e4c2c1144d2cc1de4195e30e782923b6744b61895a0c8a142ba696b331fb284e6c636fb0c02b8e4788873b5153687d286431954161d041d4fa20b8aa0571ca64cb554dac8458494b6682b460581e1806a2b3407a318b5bf459676f658a8543d61a0c19db2b980a7e7d3a8bef2a02a63fd27d0cd2f7c1873bd663a08e453ae128cc050509b04f624e2f82f9a94bb993a08c480ffdf5021d076c4066c9f87346966d51dfb5fb90ecb746aa2383d233b03e606509ad65640af7f91825ef7bdd18ef9f815b1950a916f91d9b8325232ae2e1d1d3d3ec9e1659a36988b5c86da39d471a7b810090238736fbbb5c1a5290525863cb81b9877fa7dc805cbf0192fd8f30fa1365d60a81bcf887c21da5181534dced338edc1938afc5c57a9d0c70da3f6070b9d4a58026e4cd7f622ba3a3951f3fdf4dbb61b3805ed0ef7d68ba13f4104895a11f017d6105e9b343a99c3695c8ae68fe2cf3dd48caf699f6c7ccb6b5b4f13c40d3b6a22dacaabe95ba203e4357a5fc39275ea192629bdd3e873e339390cbbef31bb518b342f2d1a2ae723df1132e5641b6ef596669e833182956200d4f36d0884ade9f08838ed9a6ea8ba8d7789e4a5d91755b9dc4d6d796c1379394bb3b0ed3f58d7834f85b61803d0c005fc3bbe3250a370447e3f5f2f2ebd086da8e1b57bbe607b291da5ae1f31db6dfec6c2b57268a606497fc9533bb69e2e5879085b48e42f3700f951d2ff731b654837f7bde6a08f5d9fa0d0fc0049acd6a24fad5295a772dad3c0d8f22c3b0f2a0ce9f2c5e25aa8437ca0bc33a968c8bd70b344f9ab30b2feca1ee50d8bfcf6ca5aa76ea13d95bcd23ce5887dd3c8a3fdfbf4e56e89b9953713412953c5fe50563a3086d44a9d1e94141caa828ebc1dc81d73c6f28f1614578e26be659a3b58d3f9681726231de440bb2bf0c0f0c79258e62dd27ef73c71b8e6853162f78702a29e8d007224735e901c727d4f447fcfea2da877f8a14508d7e79fb44f514352492fd3fa4c43116aa295caef6dd9f57c6440400e0615b3a9c8555b5d40b98104b1cd9b63c2ec862e1fe37076468b9dc22a84af8a7b1f574a06097402914069ff0118367a7ac171c27bbc821d9b22c4bf2c8940aae1c4c7822b7ba9756a63c1136c7e64061d6eedc7d28f473a2f5c85e7965097c527fc0bfdce91306f62d0faea329df8b2ad19e8509ff66c272769de8ba6f1a837fd58bea8e3fc3926c01325c0799fd66b50d1849d203ddba035f0fa888fdcf2a7349d5c7122550c70c1ab1a313376c9a0f85f18e75d42bc5502d53f54387171002cde943e211b324f0e6bd4a6863cda9544730fff0de585f329e8ccc4dfefb49ab63304433e62ba0ae88fef43415c170983d0758e120cfa1fcf95e3f4472120defa23d94db0c1013d3a89ba3819dff2a0c0973d0f2a8b28c7ff7837aaaf0c3b381afb7fa6f5dba12a54515ac23b25bc0c5b3ec22e9292def4a4a43c51fb70ebdf87be247b69534cdfcb6e14c3a29d917ae1bebaa2c86f20849600daff4b746b9abfd9d552efb2a2499ac8c05e19f3ccbaa5e8fdff31bfa0ef1c88a8ee3866ddcfed7f4f2b75a9a51ab3c04aee71bee7cc8da9f8f47129d0a17930545f8babc260f037dba554cc5199055e1a99be3307f7b8e5e3ebc7aa6decc0c071903da5c0151658b46f0460c41f100d1b1f01de754a83924f9a8b0688423cda4fbbfcbe25175f6612c3a8ff6a79c6975f188b1a38a7692a3881c4f558bdba583380076acf507371f3ea704e441ba7ab6414c94e7be0b38ebf24ba4aaf798b5368764c92881cda8dfbde8a68bd7bd1c84ae6d7b1172847aa5b3ff4e866adac93d08e981b707139fc093451c22496af2e279a2f05df7fbaee85ea016ddd1ec581bef35f69d8479481cf65f51c8e438f41f1f486e837786502fc113990849d6bd8cbef395c094d60f63c971685d4b16a1e3879e0b760186ea6caaa3501dd392d5bc41a7400deb819ae85b98c9c29ddb6be3ac09224070e534248b60c7164eb08ac5440c1616c0f325b86a0a2bb0e9f0211d8e4d32681dd2e2bdcc8eae71be266861f2e74389cf97aeca7a42fc1a2e7b2721ee2f65cb77fc946f4ebc93a2010b858903626171ff249d9a4a2da09a673468ae8636caf3fdf598c691105b493a739429539f1e037b71639e8e659b61192ff01006ebc584e7ac5debe8e73ef0a96c61c7407dc9b8a262185439fea16a2c944eed5150762d77c19c284224cac44c68e693035dfb0e30351abe31ee1869d9c9b3823917b218c3071fe4d7feb0e020c00379a1bd7ae94f00e04af1d0baf9bf4d1d19aa5e03eef7609736a5389b4c399482075ce99cc55397b6c69825b3d4c7c45d6075eaa867a284fa5a4337d0a93f8ab992cdc548bf6d5419317c95667329a3bdf004d78788fc8fb28e3d0fefcc8382c80d487d1b8a10900d23129b826a4c2bfdae07f09dab5410c2b89fa6962495ad10ee4a491d04545e26e17541b5a2036a43c3139c04f1d652a9ecc5d773662ee1e94ecacf27b5c0ae5d6698221057f75bb0e822b976873d9a9d4d1a66a1e6b6516131b52b3da474f78163d7bbf8e08187937addedfe49419b2097bcd6831fae0561fdd823a25f873e51db972d7ebff6edd245dfdb68b4cfdb52bacd55633d890d303d8d0f32547f249a93957f1c25efd19a6da30ce4aaae0faed06609e1d091e74eefacb5563b349f99770063b71b84922867ac0a7f216744b448e855798f02c514a4a48729ffa0ca84343876bf18cfbd52a632af5ddab450efa907d68da2542a593c781b77ed7a143f35610af0d194761219c387274a0e332aa9296f3a40cb4b8d5bcdaea211298bf51b508571bcc03a6ac24d5cf320b29bf463bfbcf6ddd9e8b8cf54aa18074477be70b77e11e465f9fd2b80cba0cacf21b5b81b4cc0285c56dae134384372edc8aebef31d32530db9df660bb24de7029d8aecb105df393df458c736944d2227c36d5868aaa8f2e0c17e1cc6d789b6861b4509c00041321cdb8fd1894233fabcccef3c6397a8b72320be28813460443930f75205d850b35aeedc870542551f860ca6b8cbda94d01c705fce27e6a114e5b11509886ba3a7540f41a0419488f5b50afd50d482bdc1108fbd9d9a350d244b3a37e3c52c2ecdaaa887aa921088d4f36604df9a9d22126886d61dea42397fda7346e1c3356b709165ac0be2e25914ceaeb2f549a4a7ef780826cf1c8ea55a425aa60ed302dcedd5b63f3922e90e46f7d772014c6589f907b1cd6bba157cdecd040fa54c29c21258161b584740e88d251a6ceab03a60f76e2b55ed71063bcd03c124933ffebc31cd2b8ef888a8bad135baf26d36419a8b511bccfc31bc8409963d21e3790cca364eb0c57c75e39897f08ce0e73f766f99b4adea798a89df8fb8268c7e3c7a974ba85e93731503838d27fda8c19a215b9bd7621399f5a395c599581c588d0cc793016fba901b931dc825d9b536aaa6a5d7e5f3d2b4a19810b1d9b6487e1495b572e67091e9ca758f6b69c9f2fb6f172bd97a420a200f5b43d27779a4c965be5ff09dae18bebf5b07d38fe7fbbf247a4dd8fd7c84458ef16537dce2ec6730d26928398a038e0e81f8c2c58ba6a66514ee92299350ba367c862d202cb9d65d81342f71ec325de7ab7585114cf183e08c4363c0c3fa6df4b311192aec7084cc01b2666e212b9e6b67f852c663ab4359953bfda0eb83016f02e34d281ae3a3567ff4d0ff1cde6084fd227cb29a9b78d0aef03e5e71af8b7fafd865e84c74d6cd97994d74716c96727e87c4b7de3c6ac5d548e8543fcf82ef3311a8bb024319d4ed56ede76b4b993f1c1dece264c9fce13c758ad122d10302f523448110a894ca8e7ed90e0988b6c2d17565fb68f8e8970d8256d7a5886a3737ed402e55f4806803ef2d5875262568142fad08e2a13e54d73ca89da659d2041b2a0f88f76e598045d96970d80e26c4c888115175d0a7216e0c2a72929cf49b479a87ae043b42b610ef551f7eb38bebbbcb371224a91d14597500b982afed88e5a8e7c53afe2a32e79077e4a69ff0db77c8fcca12b69c76bf33ec387a2b66655feaf1892d577d69d3ffbe075b09e98cee407d55fdb53fe3c3cf64353b2777a86b3ceb845d8d21a5cae98a59ccee429e781ac10b23fe26b74d4bbef8eda3da4ef24a9cbb0543d3e6d607d9169268b2be81494047de2543f1a52ade4a0b7deea8faab23be63f021a07f60741184eb9564b74abb17a217a592300e3e09d29a7cdcc5fff6b19489d86624a3ff8b9d2f566c46349275df3f8ed27a50769fa9dce7e17c8f303d31bea6ca704bd49e7a4ee22186fffd362fe181aced66d4c4a3c4522e3632afa3052cc0ec3834be27be1669b7604e3e7650dcc3ac578e0963de22cedc42ee99cc0a9ffffb47b63b9ce4d4c0c0174a99f9a0b6a98d748b4d1d4011bb407c84a8085b7cca1f68b86a22f18af9709c3e6375ed979dcafe44a391633965a1979c0375071b4ce9f4dc46ba762321bcda8abd3f2659754435088c9d3923ddcfe464c82eb1335b8afefa0c7c8c95d133e4c454cbf900041c004fef8c31a681d72aca1429571f03baf2ee232c43242b589cc5d00955576157bf288943ab9b75aa7f153e3e29eaef3533375dde4cbbc772d1343a42a9f1e831f526c3ea9dfdd996dd5451e84a64d1e9cd44c5e9a97f9bb2403482cbe6b02f7313648c462fb9b233b93dc1464c1675beee88e45ba45a65020f6b90d6140434b4f30c24cfec4a422da5b31490bb6e6cbffc291964448a1dcc2eca80794a54c28781596f6d4763c6b2919a2c5efadd7d077e16ae9aaf30c267722c3d8e17db4db0aa64c4aefc341dd37fd9d61800e33851e4160c99d21a143f8467dc5e076e2c765299e130eb1822636ba43ad0df816c0ec7188a03f19fbf6f4df8b87ded692512ae75754de6115401a256f36de5677e9fff3f880575c09ef02553636d33bfb3c201939180b8918f570523caaa42ef00c23f8d98f1b93f5061dffc4a35448783cfc709ce4aaf82eb4ebe8a43e9c59dfba9920c94bb7e6c4f6eb13d8eccc0fa9efe4180141571c65def9519040e6e321d4cea650c71f2afae5597c2193330818c8de2ddeddcefff8e924dae629b737748d6b3a63e5f7f28da9a58d5309c3ead877b69ed0ba08f3ab1b94972b011f63373825d8bcc1ebeb0802ca17ca294eac698f9a64720daaa86eb3aaaea087023ab2d2269559ee9b46d70834a28e558e9282440cb49e9eb08a73d311a4a5bf91ee96d6bae6ecd80839da794b60a314d2834b0cee1dc99b82f6f1befd6b303d90ad5271a2ca37abcb59af4133995d529bbaf929d879756e6d5f5ae7288510cbb0a4c5700a4aaec7843a90264db3a04a78534644a8952ab95fa8da7d8893584b96d387fd42f22c67292d4e0003f2a5f579c9ea8d9607fa8344ae6c4a45efc2b88e0f4aaff5270879436b0bfd22fbba0fef4403fafd3be6d2ef7ebe584407e395bd75f99943488017ada224edbdf5e3522823d90a49cf38384ee593cec6f5010e97533f4b331a0a107edf857c2d3b2ab061e949134208b3736fbc09fbacf03340b5ffcbabe1715e2e189017534a3a13948df6ddf7570de4af09d8f7a9d49e1b5a33495dca3675bb96bc1d19bb076e836db700e65724074f1d5c9da1717203f183207505746c75b45da6fa88d1bd9f91420a8c05985a3c8b6056e797716b66bf1d9d8ca4f31336affc50a07379ed4f8f2892adc2c4da126f4e6181c1ceecae3d68f571fd4c669b86431a10ca09e7af43df93dda9fee3253bbcd0b35bc28ee59aed22ee5aae1d2244cad4541347fec80b3dbb32d77a1f4f1bf6559e4de75f06c0b48047c7011601ce0c5ba101ab5080eb93f37351c6b50c99fce51f62ff07da0ac3715e8a75f07da368c6133ba8715db9bcefd8a28e619a8c1215874e225c484e8f5376556126e08f0534813f47520ae18cfe082b082bdcd14e4d54bb5b5a6e2800a945b349554ca7fcd7151c88320e8cdc421cc34a1e5674f27fcc230b2c49b956b3e7cfff1e91be15a57aa665cb754e6e730a27508156c4025a17ae671248c603b587affd7214a6e0ca24479db10b8887f3220c32b8abb1c4c948a0d2cd63d58a6223341bf16cd00db0162ade69ff6b1d6fa427933899535e5b0fe2a0b0a062f0c4fad6c7549ee97c5fe6785abe700cefdd2a67486d63d4a6e5efb410ce2158591d379541c7d5deae93c0c113cf173a7f750e34e4602abfc2d4b4e23852b92913d1ccc313f5409b3cc1e54e3ffcd8ac19a4c87d22d1a3d57dd997db16c3dc6d108ccc1bb77f4376bc4274ece1a15cf9b1972a2701e37fc54ce48aad9b6618ba3a491753311dd3a6cf2b1ce7d89a6230e239c859a8f71e916f4c62aaa171853fcf317f98a360135277bbf9a8df5e296204df71ac4b7db39db84a7c4abd962e93dc8bf2c0ff77d274980991b269e9bba16b2bf4f6e924f7615dfd921958b71a8d4513727804513c6867d2d777fe22786bcb04e00e0ae4e49f9a8489330a7208a6042e3bdf513fb40ec427bd88e1b473a97866f835d49578068967984513b68f6e5f99798f77f6a9ccbae9ffb733e657b583974e8ab766c31dbd51aa353ff0fbd97af116f9c65d3e0d7207f04421bb203c9a8a228127c7acad22a5a745be3a9566b42020ba57afcec009c6b853829b8147299f02d35875e083b588c77d1f744d7446acc4751ef6cdc94247798d7f6a7874f354389fc9d6c8bc0efd7bfc6646a44314f8a1d13db3e596f850e3b5a3a7118318a8e40d106a268f785c9d754675bb76d5d3b7543dbe127950cbb719b9a33ab3e0d9434019ff6f8acb718ae64b77ce357ad9e7fc5aeb93abaf6f45f4242589e361f2b6b22b904097f94b4948744be53f34c662d2ccae518a91c63fcede263386f5be228817953c0fdb7f94d8ff147d9882106fb3d362931807bf6755954bd03d4e4f1b48201761957a8155711f097fc36a73e46b187d1ef07021b641910c45ce5462e9a7836fc7a913852648826d691106b37b309e546cc2aaf02b871baf0e1b9b8061bd62cc2fafa308af551b418a7978d8fbdd56e8dfe78ae3ab04a4aaf8fbf111a024f450e7bb793ff0f5f776e62ef1916b5dd453ae4495b30cfd29d834f08fb4ab657409e2e5ee57cf41f12a6375dde7892896b4d8aedc3f6b0f5ddf67889bece7cfe84b452a88528a1e86f3cd70f649629804bc8dc2e92dc1248eb2d57ef5d34a4864861786d4f040978158031c5e9c43527187050b2991d6676d8cee4feb6da12b8768f286f6eda90c5447d46b440bc114943880b24c98448371ff1f566b9bcde64ed2d89b910fcf472b605ba1d61c6a17a635823aafcb969237c2af3a38b4a1f88ec52df8f356be765fb666c7f15897e42fcf3d3fffa63340baf2823c1013e5c465f7e6b038e049c753eada056d00ee5535abbea6e0ed1e04ffadf430a0380a3e5be4154fbc11af5e1ae727c026407975cbe73897e8619d98f7656a62e60890863d379001224406081ff427f9a0ba481428ddd0a140333f714da1ad7b98f7d20a7d7d797f43eaaf856f96015ba3da10da9aee44cb8170da01a25b9a0650719dca4661241bf11c654d02b1bd6b849193d6e821d102dd52ff6a3454c96f3428f4f45421754d472d924867ef84e23163d94b38b214299bb073455613b12771e0ee3af776ac032ea92beada477383f51983c700e4aa587f468c4d9f8d2c0ec11e4d8eb255cdf917b98910b0f462a96ca0b3d689095cadc8dec2fdba6d696adf83df9ba7cde0050735ad75d811d09cfb1ae591383747b4384290ae5e8c74f5a35ca14d1be2a116670f939ec5caa18b37adee12ed32b614f807d3a7b321d4e7a02659f2fe42ddeb14332ce4fec483bcaa457c7ec0a3b7bc824e1dbefcba53ce90888dbb3415783fdbc0707dec8e953f24d0ad5466e610c40944672bc540230f6bc0ad89c2ea23a7f5af93e92e30d70d5a9c5ddb964d67b7ccd3b66dead038e58849ce315b2ae823e8966e4e586f500ae70dd3c6c1c039393e156146eed6c19b431d2491070156cecf490d57ae0ba1082be54cf073c05a04f88ee8e0d4c62ea6427adcf45015759ea2b4e830c3f89413531a0d6036ad9b4e07e6aca239e908da055b5ad3c86f27e3aa63bbe31a9632d2f01aed98ab9613e27eb278c71fdb19d76bd137f9cc9ebbd86d2de32e963f4b3b8d185130a8b7c0e773b8e40530cfff9b93b483e2ab364fdefe1badb465966367ec767bbeb0ba4ab86038f1a7d46dcae61b0eb1f01278add88791bff3cd7e537c02184f939bceb6ab8557c6ded8e455052ae024ef73419a546859095f4142b8d0295358fb7f641463919423c3975ed1c140e539a9bd36c7ed986b98faf6833712503619fc0fb04c725a1d7ba04f8ad4ed3484e70e446929b2037d3734ce7ce544c2d6dfd63c30ea6c3d9ad8ab808dc66079464cb0b9ce6cb5ad69e54f8db491b172335dd6c1072264deb9d569da13c8ea5a8413db4f5b0617a971b225661f95df5f4e49b2dfba56fd9864fa22773e84b7b26b940947f32817fdf65b1ab4d666605d3faee69b33a06a9bcc796378e95d551a82b46da904f3d2e11af8e11422d387e9b7ba5b7f4f1e79da57daa7e86fc651d21268be85e5274d55aed206975d6168dbad5aee23fce30e6e71db53cb0b97eeaa2346964ae22684aabed482584c592094e1e3e32696d76146eeea9409552d072621586fb4ce833e1715fa109daaf79dc31d6075e61e776e79176803f442a24a8f7fd8461c1c1664d3fd2174ca6efd78154cadea63358feab6d47e177282f6c5061af521bfd48d9b95fbe58add6fd9e923ec0cedc9339ce591f274824e4ae35f79d2cd7313ce2968eeb6bff307429b1cd6b35ced91bc36bbc5ea15af6d833efd0cea1dc52d1bf3b96e05c6cf209fbb3b34e641d3224305f486e652ac6a4820b4e464ed41d379d0543100cfa383fa2a4ebd7b5311fefe89dcf3bacbe3e662f3e1a20a7c02a769bcda7c7703015207a97fb9c2633a277be8fcb0352e3ac60aa56a2812e05506c91b29f224b7f5286b66b2531842e4a480142c9e6328216a92e34930f98cc836c1eda30072fea98e6a0b323e00d18ead76675fe7c4a52d91273cd7e1a84523a3af3a1465c3a3b7be43d230afcddd13812c3142654426111dc0bf4dce19b5c94e254753fec9407b5c48e5d7920057b75d221dcaabd656aff0ba111fb90ad37f07f0065d60eb72a4fa3747923541127d4516bc1453a3d6f4c2b4dca857108e537b81c45e6063c1844b4b00cd86ef5fe8cf035a65ee575432982d95e531f404ce118aace45db8cc1cf5c0e595e7bcaf7c32910133eb90f18e455399e7259c0957fce4ba621275b7a16be39c0393517c9b944ac3e7e480d06a679af1b9250e5bac1dceb205220fda03f1982e8a1cfd7182080388a5b81e35f6647acac588def02c47bd56472711b439cac72d3717e5ea4abc244d32692ce4ba426478fe030fbad6a2e25a00609154736c22bc4d4d374874b53cb2dfd9be920c7a390239297ff97b8b7f1b852842277b1fcbc7f57db281fb539958d9f2e629443741172643bb50fa34319e436e6c8c9e3d77519d46c5fdaa3496088a64198d12258a07e37050d1c4fc03f58f32ccfc50bb9976dbf2600f09ddf06f16b0756350964bdf37cfde5a1f5058694238a987c0c6e4b6dfa4a8cc65cdb1204af7e2a79317ce51d772270f62faa58280e4624439bfda7139770858ed72b71714c8aaecf90258358d71077ccf236209b619a4e3702c97da5645dace49b2d1dbb685452419d8cb82a846e28463d1ec4da5b7a918f9480fec716f3ad0acf4f41a44c7de9814654a84435e1eea2c5192e47c2846e9d52a11ce20eb405a0328ad67afd96fe04e7c462d7184260150d38c42c72e09fa4e1c72c3a43e86a35486c5fd359f5824b624e5c243075ba08de70e4b1712c04ffb742a31d5dd5e437d9a5ca1d214f00b429c18c97283b2db65ed69d56de99e5b2234ccabc44ebb32478bfed14cea303c794df38882a51a486fd2d7d5f6bcf3ccfc32252b5902b180ddeb6b557a3ba3d3cb07b094a353ac888fae0ce6cf1954c107f9dd40b40265daa436acf4117112bd2beba845a3951234176b9584d9a8ad0f90f3303558070241803ee883b9b4220479a806760da3ef290b01f4814094b3fca740038c9a66df61f0bbd61699d2ca25ebd41a6bad34ebd15fe1e25cf11501b7ab009c0499f02cc281cee25fa9476ddb6c9f7ba044f0f412a53d4eabef1ffab2c856d25991d6f6963e16e792eddfbaccbb972ce8eaf40b8af22c92cd767a69e45d82cdaaae1b38ebbb58d3bda56ebb44f351c5d4fcb0a36b199744c694d15fa38d69a7521a6d1beb10d98a7ba7c416f257d1f626d69c8703a284d54170f1c4002f99b8e38bce7080a870419c1a2d4b25db6bd5f642df423dc9462a84bfc4c915906df9c744680e2c15dcf52bfdab6e42fca34b4a602e64cfb4148c752698721a8a1f4237b14035af67626c4eff38417b64412f1d61a025eaf163a5c718720d07bae9167307f895218838fe294583acac29cd1de32731f94e704b0c8daf7d8a7965a03736d4e3aa5a266d8683ae0a0d98678d475f1af57ed45b1df31b88dc1479f155c262c0d56ea48e5f7247a127d4f119adb6aaea94de618fa58c1e348c90d2994f1cdf0fd11aca2c9cc54a15e707afbde374d9de9970315bfb4003d5cc7bf262dcb0d9a5c9020230a8c3b96013de35994e29b5bf022845243ba4b0b4849c982322f74a7276760a63cb897d726924efd38e3dfef22a1b4d72efecda26171d6f535073c2feca7f0abbdee3ae538718366a0507491b349ff992851e966547c78a7b540a8f04e78fdd824bbe646b126b5b803f2265a290f8adf1792abfe0a6e9efe57e79ded88b53378fe47654293112197d25e12320313e7b7664b7e49731cd37f45df0b3a787e0d12ff5d84a8500bd818596395e50d4b24e4f1dded7d58f713f421fad8296db0fa6e9f4dc6b9bc5bdd609f32476a6c41ab54f8d55e9d3728a1f3d25c9f0a9a13d64522064a3a617f8a15a7a5c187f70d63c368189016be5c3c53fd6cb944416df10058ebb66f0aa77b3e013d07d3780774f4a150b466b6c2c1923144f535d52e61137d7aa9e16781e3d1dd56d289d89e83a143a10178d48ca12b53e01f83f1fb797e5d8faadbcc6d63d17d18c1c359688c9472a1da63867e5c04e63cda8738b1a45a4621ba10cf43b32eacc43f1b67a0738f28cb7a2c681a70f88da6136a6a2891396b9938b00b66f335c0fbf04b0b65f82cc0c26a98a2ca2ba4e824197209d27ac842add067a85222b322964884da3a8acc44eed52cb5d1288cb1e4490b5609cd135643add4316545ba414cc2d1ae490573e216dbc0f7002b21048f3630f6d254358f52ed809df3ef8f7a00a0e76feaa30c0c5c505f7d5919a370983db98149c773f9d6aaf73f00fb6ba70e9d5ffe266cb794496f7df1f9e1723f2936da759a9b3e3596c4ff800b54255828cbd62613bd4520fe34772ece76d7d141543bd05638289bbc571cd11030396a5d3fa87bce76cc980742ae397e8c654c50f91cf5b0daee83d7020f86e8b5be0db51387c8a05822a864ab1491d90e45c831864881a965adb65bced1021cb60827d1c2de5cd14e1bd6146091426bdf3ab40aafdd34d0ff3a8291ce522915c655a46ccc70eacd7947f1d08a7668567c25ba73a68cc349b2d1c6e799fd864f50f3c8bbf8f50c5b725ba6a5f0d9044707893526f13ada45ccf6836358bf39b758c965bd8dc57936effcf3670355c60f899a5b8b1abefc150f60e31fc03ca47653167a7b5fc1f8fa8790c17a545ec327f74a031214057eb2de15c4c9b8e18261c610c1b1a61c84c93ee37297e0df86d46dae34784c8f329df8c9552153e66bdd15271e9fac802ca33cde6fbc026d5088ed04606dbf706c479366271fea9422cbd81f240cf5eff85aeb09a03c096546a40b3fc6a84cdfb56fc6b154eb2cf886590620152ffe1b35106c6bb0685cb3d2ebf794e6c34092414bafbe86cf5c5e4d992a894290f1881f2221eb73945002f05dfaa5cdff47c6b157a404d9657a0179d1a4e8310a241fd4a99babce512fed6afcab414d622f9b6fc0bc8bf378653b310816602260bbcf44d4f170037d526a1c1a5aea04ff522724c16904ead03c7b8c877a0b80e03cdef4d6581f7442f3b54de6208173027986bdc442eb543795b779fe26506c30d2f43cbd870fb998dc3ba6bd0b3e71943cdfe917d0dcb674643382090eb05dec6400233947c699b4fefad3c52fc3dae0477ca47c0a901153d8bb075296cffc82232861a698d59f8c5e67cdec273c602945f18a54e7de073934cd3491c2d254bf254664aa515e84eaf7cae01d3b9db5c00a15effd2da49fa1580f38ebc31d7186ba658391e750099832122701beff8fb4eaae62de170d80560b7ba67bc9a1f0452633e3d49b5529d7317254bf0f5556808cfeaacb4db6aa78a6f92b92a533f8dfe8707e78d70e87923910f8c8b64e72166da8a675fb09a123d7e8d669590ec79e73fa219d76cb78a2d48c5cf9202a137faf3a53b9c84aecbc3bc53d2002c330eb553aab1bd034b02022b0c8573eadeb7281b44124bd0f21e16858fbe97fde0c04f48bdf47a099e399b941cb2e2d87daa5c7d7aff21f4bda93f1d51ece863f7b5fd0a3a2944c7c4816831dc1f526b4af6b9925a8597b882c0cb09c43c56418295aea90b66153fc380780fb091d16dc39bc69fc297fd9622e77406f4fcfe476086fa503c4f194393444d14eef9fc1b51ba83e32782024c8273d8fd7ef0f8aa1d59e6930fab3c7fe7614f272e704b6cbcf1818b7861b0ef98567f5db5d6a80f1173d1b4efbdfc7640c59b2003ce826448686db427fe7a1ab235687305f782e7aa521549b744977cc14378caedfce2eadbb7ee8392cd4eb1d93470992dfcbd65dec617ea4d93114fe56a5436f79ab0783a17d211c3050500c97b0f38222f370ad4605f76293ceebacc4395d72e648046a4de7085fdf1184f5236e260c67da9ff6aed2fec3c5ab1eea4c66a90fd8d5895cb35d8453f3630428e60b650a1c5179a2551d47d52c373d35509673200a63a8ca714c09f64768964fefb4c9529800c3f9d9b8cf68c4750ab8a8c9435822b22b42eb9283c28b86571648b4f57f753fbf901cd869b080acedfb065e5440768b8fb721ca82af02469bd2cc5d1b44897a9eb1a7adbc1693840dae40c12f8bc420852b9a77d11112bb6487f476cba523a521ba1b34226197be51f0ac2b08445ffe885b23c75289d0988e6bd2ef4498e39f8d99c6c61cd0b0072078221d681299bb5993b90981789089316b3688e405eff93f939877b99113b3ff6fa476d9733ee40670ae425a9a9a8908a04d0028697d732a943245cbaa0a1235a21cefa3c645450700e7d253970b5cc4dc9a5ab78fbe8eaca7e1f164eff0dd3187f8d91a3b98968ee1313954454286516619c3ab84d052aec4e5ae81795d59aed9f95e1e80a1abf83e18ac8c8f99484ccaac3a799cd0617749ce1f3f311ea2ec33e40b2d01aca1d8a3154d3d4b401717aabef146cc715498c0debf7eb531767a34792a874245885113b398de072637f230d637b9cf4bfbe241ed85efee6e972c779ae417c2fdde364ba1653928429dee3b66931a95410f9090ba94be18f99e3cbed5b90311910af193f4aa2afc9fdb1e3ceb99493077616f394100fe8efe85fdf197cff71b1980cbc2e60db9efe2db58f9daac55ea753308b420b9d32abc2573712c0985681dd8f0320778fe1c85fa2a5be9e74e1f374af7b9a8204d53b3279f74573d26fd0b9447824381b29cf19e13fbed757db6c9a5f5c7bd5306f3d0209f3e677c1a26f9c72b27c8d0848c76b76d9aadff65a4cca3802a26d5da09af21f0783f1d47a0335a8157e915c2bd96e9ba89e4835e108f852494fbf74c8cae0619feb5a979dae6eb9beddadac836dfa53ab6c62031e453c3d26ed5313e9b1c1838fe60faf5266511a4c81f3f82a0c9884b77f001bda8c690cb47a5c21a4dddcf8f3417cc6bd6f980eece72e31a29f51638e6a1f6dae3dd7969bee7dba273a613389ac32bc6381851b6d5104fc184613f1050514223645e53ce12b0988f9e7d600ceaa6eb53259c9524d205368fb6618d8035b1066de00f7eb360b122dca1f1ed1ccd346d7c70e52e0ded040a1d32f6eca362b6789071bf94b8fe224b9c52fcb2d0e6e7219268c9165fae8213fab7c3610bd8650d9b842f2dc5239ebf4f0f84280d65475a43bf92cb0b9d0d9c34d4ccd6157454a4517b1100b34c9734bd699aeda5c644c223b3c1b697db05a66491fcdf35c2bad6e6a5235f7f484d1d886f983dee0717abb447a5c4de97fa0dbe32c95ae6b35cd8a43fafb5ff2476c4fd7a807f29f565f7f91c9d4c64f84ea041b7aac25366d2a672b29023c8b0a4d96833572870eb2a21fa86954d51c2876a07e693d4275c1b86a570d6d115a89e27f3016c9de7bbef504553550408899ab06eb03a9ac512e9c8955c4596afa2453fa9f5dd556da42c3e413bdca9b2e46d95aada08caa069611554c026ca95bcccde746ab08fca3727c7fe19de778b78b19b4b9db9e08b3e491480e157fc8b5ffe17ee685e9b6077a2c36e271e32dbcf49ac0251be62bbf6ea7e6b54a235e30bd8331deeb99e95e13cca03b356d821b57ee7f983e4289050c3c6a1d834692d1fdaa70a0f3828714c642bc2ec163612e6abfcdffb2e110db54b58da4157228a92cd3cce2100892d2fdd8ade869fa8b75afde7dc1e2d0992672a010099d108aa3c9022ebc908cb85a1caca136ea103069b70b0925db872708d1507827ad284378f7abd547f092167ad04c03ac5f0b912eafff22a57a4c0aa37bbd18b4bb9ca4ca34c86c0fa6f950a98775abba60ab25bd21146abbe35241a257255271c9b84bb6101cf4355a6ab8b67c0e562392a4eb9b70e8e64f22bacceff543cc7b6cfce1d6e30fd60a48ea4e9622d26cce80018d48a374b41d6cfa6acea6b791bc3b4881325a8a72a1818738e5b6eb25659c40f80dc7d4b423dc8a8acaf4c25fee8fc58155523b3e5cca5cff9dff0355ec615d7eb5130455ab10e0aea0e69839a76285438dfbbc07d8827344dabf4ba815504933eb59404d7da854dd582b17447aff5c629f2d38e7c1d969731f5a30af3d558f9ad39ed7ece0b87f8cec23160d0108c37587ad7194562c51a6b56b6a28400039ae619ea3d52c5ee1008fd321f4fc0198e82f668603c4d8632b49c4919cc9a2d39da85377cb296027f617e400023bdae391acd1c182e716af98313afe35a2302fa8831cb56e97c32b9bca702c213e5bad54e98b3a59d7e2917be23829bc1722391abd13aae9cfff2361a6737f8feb88eeaa0e06a4650289e71d130fb988414d216f5fec4d9c6994a4fdf87807ca8a5c15ca77640508e3f5299c9c24d2e2a7219524ebbefc6abf7090623bc4509714383b9fda36db914f1a181f1f2d28c3dfb2e048be3b2ba337b5031121f31319bb4f25245a93516f1853253579e589e0e9effc579db06c7ede0a2","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"866d10a5c8fa1421f11baa3a03887662"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
