<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>BC-Drumline-Archives</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #2873ff;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #2873ff;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #000000;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">BC-Drumline-Archives</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"7f69b4cd4a37c48f19b581aa38cc2c9d5dd1982c6b3f767edc5540f40865bf956bc29b08c276ba01f164350cffc1768d529a5b4c11252e76b4e56346de3c60e4185a795b340a663914247918f8acf92dede9edd5f47a52ac65f200d19d53cfb61a9adfa3d0eb2f71ea2f2aaae1d150a3ed382a789e75179113787f24e754641743b536dcb1e5e9aad492ad105e9d33137bd4309f5ad103e58c785db04e72d1d410b7598a39cb5240e5780f1c090339a39d21eda01e2ada97fb4d77ee02aeafcf11adf4240d2c7a4e430634b7c3adff845eb2adfc250b56ccc785d85160d9f987bc259c0466714f4f50a9e2af6f46898033ba4bfefb1bce9d4170b1ca60abbe875ab116e3dbd44dada5e4d1ff4524b481eef9e58638aa0b91bc2792bc29d6223e19ac45b15c676cab17a08b923cb8a94b241193f36c724dbd822cba1fe017773612c37edc4a054685152e58c562620cb1a9c5661b6f1b2aff515335dc3c569e00651312074e0de3cddacf337d596db000fee739fa7359e0d204698c20119bd8ddbd7a3c0cdd1eb1c760b11f8a701e270f69c60b5c1fbceefc78a59b63a35a7a1097519c2efdbe7891e1a1e22c82aa6a4a9578abd46ab3b365d973cec84dac17a4861409ecfe11cddb29823a0826d5f429355bfbdc2e04e9bdd7b3badd50bbd4e34d778cb291a62721a4cbbe5039b692d35a86df93f88d961b0e355ce0425aecb6c0db734d4375b644e8be2d47a24c4a707805b65967bf615cdd79bdce0752877e418d4bfc8803e55f0cd83c3b511e809c04be6787cbeed28df2701fb20c90b03aeea0a08b281951e36d8ad005d0347abe6f34ce8ed5e83a9cf600c16edb12ed433b840be6a037d2c4e6b52a8da4c1f1873ab1fde30eca41535fa2aa3c53accef3001b4457301c07de7d008fc3850416d8faa7feda03c37d694c2f15f9f40103e2a9b04c53dd38107fb109244c9d6b76597d551ddeec18e292c8d34e65ad757a8388177e2022ccf01aece4d6ce62ea3be6e7175d46c8dbfc6ec73b86c751cfb2a480e86c98d43f18067e24e789cf29ea5f1f1fcee8cf63e3f86400dbeb1f0db238f5fc2252937cdd4acb30d89445304a9fd135b5abc722801e1e7624cf26c594859bdd7e57ce09846a5af37657dc288812529738b025ed2b1df47dfe319866c805ccd5c54cd96fda1c76ca6ed679dee4a8a7a36a70199524151b82643324c4edc261335f2ba3fac7dab29a5916941c9858e49435c9c601a45413f4cbd3c4b2361721c0c3436c4c95db876cc84d6c3ea0b0e0559e3f35179669b2280fc8971d63944d0a1b9b084ae9149fb50741a24656f68393cddc04c9aee110a7d73061998a27251154909a7e2e5d16bedc2981acff75f04f416e281b9af9bf58b58d4be3b199b469a125e20664841765e221422f4f91e76382b212f2549eda92ade54753c7d0d6bbf73af2c3b7e87079daa4b5c3113147cde90a2685da410a35dbdc3d8c9d9a8b2c000fb1b9ee5399b7e5d927cd08ce46d48ea0ea89acb7f922b8b359b68c6e7a9c1899fbc09308138c23a9afc1f501b5e43932257067c04b48202cbee69cbd04b6837471ec93d779df9f09d18954c6ad3c41a9be7e856756eddaaf062c921f6ad797c65ab1afa1a37ef2f7b895e0f7b72afd1792b0d40541a78eb6457c116ef5e68f4648fca925e01e19bda145d410afd5573bf366bd9e4e2c4a24c18551e6595c750b6ca0c7c9eef278092dcdf648305d292cef2d8630544ea61d820dc908016d014fbf6480104c93f65cd2d06805814b9ba2337879906855e4feb3cd82147b1ce1d34e4af686eb4ec98bbcd1584ca687c6a2334d5994b4457ca1c073fdc5eac6b2b8391230df05456f4d72d4bed973e7c910f1b91f6eca73249b3a9e2b79800632c634ea750d415d87d6a49edc2279505d1b5a392ee5bc8f9d2008a4d77a10f6555ea9ef0d64e0a122cf878e90fa56b67ed9d395c40160c503406be42fbd7986cf307ec9c807d828e3a40534a0f56478880333e18670b2b50fe903cba8c5c85b62c93f1e94bf1a98a26069cde5731be90f6ae80400a71f3667cdbc099f5efe0a5ff0b1ea0196ddf0e46ec0c71ef5c56ff4708a915a516cce8826caadf8ea8b71eb1fb7b4663effb33d173c0586ab786c27d55a97efeac5039b81ed9a68df8af8f7b062941cbd20d96bcfde1fba2ddca48d69f0b647f09c93495bf2ded055f5fab809cefe2f0f3f0dbd0cbfda3e2224f7f05e839bde2561008435f7980107006d5f6c83737d226cb9fd75625bae04e064b4a7ead86b3fd62c65cf86106d9f840e6fb522be8243978e8c594f048e7d40355db3d0bf65aad3c0a5692cf3e7f41ec63ab67b06e5a5b58dc2e011d6e1b9033d0de2574144105e9750b72f4b292cd18e157fa16fd34d6e910fc083dfdc2f844a7865e7255aa9b2ea7d6856f324c64e1308ba7db025ae6bd8d1000aa0694baabc767309bc6510637f7554651bbdb83bd19699fbb33fd827b285c21d27c211d1dc4f4a2cf011fd87f23c5b3554667e94af7dd91e9301e1d7407d9679fdfcf3e9eec1c3a691bf3756aab383b9fd56826d7501b0db6f894f11e3a25902221f52e588b6d6584c71652a1d5ba2c15c0e3553ded94df045aea42ea515f1c48177bd9a60216988b1cf4089f30b23080dae23b03fe7619bcb0a3036bbf9678b5579059ba0d4fa5bc28eb06db3c028a3224910f9c672690574dbb7b3507d9f6b7d295091fd2dbaf6777646556a73add0304d59858ac9925cd7a2afc72e55b3b1866c710ae481357742e4997d82aa2ad237c040c7ff0e52260469851eb5521b9a94d72c016a92b09f9e66c172b4dbe8dc7bab160d70b635ae21f9f5e90048e7774ead87df27df5b1b5e7eb8f120ba3195b72df61a5e2c9321bb841044c2294d4afa74df335fc4197acf7049a435c8d08722895c8b1c2fd09d2084f52e581b73b68680a70946c823243ef93377c7c0aec333cb232138ed23f8811b93a045692c2276fc64eb2a15b2716ac975579d99e8b29dc934977493357e9b6ce798ac0c521b4cfd7b4fb342a9fb8bc978b07d05d45497964873f9240d1fe74b958cfe7884e20cc4595349e5783691a9e83001e1e32925cea871c37a28a08345aa9f4e60d56fffddfc0d653af4a781a4ea735ee1bd493625d271ad5d6fc76a0fa008d40dd7ac65500b6f7c1bb1f170686021fe4173c10870afc936f1d37f730b02643c28a4d1bcfdcacfb13155511f5b9e9153092018c66c39abca21b35d3f3132a687e3cc7af3ec1ff6a86c8cc2178f657ddfb2436bec0fd451971df22ad902a32380c8f0a6bee8e20c80b7314d7e366fb3dfc153fe28cf87a50f4af158581e2e40ddc3f56b3cde0c56f8798b1c39edeb7444b24ac3ccacafcedf54eb80e44f2efae81487f1d2bad2644a23d76a389e32799745e8eab593b31245c21148049c4c6221c1590af1dea4f283889adfbb6d28d0b85097c22c8f94a30efc509731fe3878d045b91dbd8c9fdd99cb842e8348ccf4d71bc276f412963fc488aa53473508b9c2fa9edbf3466240c45af28981eb0d38544004fbadd116c396072ccf3083be69cea5aba1c5ecf5d3c0f3e542b32cbc5f27ef6bf78d72207a293ecfacca925a722ebc6798aa9f43c19f02a6adb5409cabdb77d152457d701f3a9d117fbbfa879dea3fe1c3026625f2c68e362beb1c92446c2515d1d67e847d9942b4fec06fe2d140f98ec4dee046cc0bdbc84d315a8ada4bbb049142a0f9d19c38b206c7128d80352e95c42d4a89de83b11692d3f30545a58d8065f163e3cdc0bf5a9b6b1223924ecdb567c8d04401cec7d08f9b741c257996adc273fc5dc3797a968466918fae200934723849313ccd87833bc1df108b28c585dea85403aa207102ccacff1962d1feb137c8d189944cc91fb7e6c1e3c9972319b2116599f8f763e1a66bd3829d30351c92e9f91ae364ee559bcc3eecac5f5b2710b24fddbc45a777d935b0bd6378d5a19d1e19b774de3d75e6b3c9bef51f7e9c38862070a3fa6e2fb12dc877785fc9d1901da7b0ad466091ec27b77cdea6a9d67db8944ac1c9cccc13ab5d3283dcf156e89a3d564ecee8be3d903316526adce75efefbc4ab99b57a5a16e3c82f50480f9ef04f2c7cc8559fbad6eb99f3f354d7ec83f018a064253ebbb60f396c7ecbd7edcc113990c1d312db8027325cf172e10a66e7eeca28693d3bb7a3e5f984878a9aea27299c5fd6799855c3b5d0169a4060ebf43f14a121ec1964834caaaf5d729cd007bce56d9dd91b45f0a3c77dc7d1a6c3b3d1960b5a2238abe72c0d6108fbc91e39e54de126cc417f2140241e521ac782f2cddb55b26c6cfde0c164a8b96a8a57f37cd9ff79343d26dd6129bef71a9f9f562e65ddff9cf3be5b2aa1df16df1ce2200a793fe393063939a6b458a818401b7a82a11751d847dadd04193b40ceca441ea99b669819d10f6265201902e1a01d2bc8c7d2f6287f464e4953ce795112a33e6c74bd1b5de663f44618b497535b92aad966aaa2484cbde909ad03ec49869c6c8c2ef9809a9f30a91ad7cbd1d21ae82ca8fd6455c28b2e51db22e71c010e4a16d3bce6eb0a9a9a1ad362bff259142352d37f46e8ee3521a8ce1b15525852dce0690203612516628975349b4cc41d4fafd9322861af113837093e04f955177b71c1345236a890aea87689ce7dd242575ae90036494fc08e795455ccf3c60b4fde07ba63a790332daec9ff9560b4b1ee0e6d114777ee085f27166f2446d0ceb19a82cc7a27006a3f18e81fc0d0e74c2cd8cb3b28d0477f798389fb1290341368fc90fa77c6cd678753a40056ce4b4cd6ebff0f1361c3374f465dd53402f69f9876198b927b71b7217e711028bc81b2d1928e73e01eb11c007edd36d88a38efe788f3fa120c291392cb4b775d001e3683735debc1f68cb85ea26a23eca925fd5afdea09e03c12937082dddb2b8fb5ffa50c21b028ff10c2e69a37874f4a4aa5cd35b75153a13439a112e326470e0bb240540936c753eed46e307017f68853bd23ad2f765c56c285e923741c7bc97eeca831cf82b1a08fc8c5f17d005a0eb099de3baa1c1ba50f9499c1e34eb95417395348518ad535d20fbaddf827f7f75c152e468808b32f9995562205a1f20a4e9316b1371050091eb255da15e23bf3111b5ccd2090e8888c73e1efbdaef916df4f22eb2121343237c5556734dfee68904722e5db32ea069d07158bc6af2f114162af37448318db8753543843e8c174be0cd666431d5c3dd5e25a44609415c0d852bcb37edc8f3020a755dccb754beaf47905cd7bf6b2e314d7a00a1679d3eba05da73034f8230aee74b7ffd03d590c7a8cb71518417a21822ac8c3db7a9adca79e0f15d259851aad134f18e7073eb80162ccb3e1dcf8f452fbef1ccaba2cc765c9fc320f804d8638feea03cf293f857ce83e42a2b68dac4ba995aac9436a9de0b7c6d8883e9f93759fed8c4c2750b77356f2d502e02320ede01b84fb150d76174b13908a320e51d98daab3f3c39e2b22de9c551cf81fc2951c510e7a9fa67bb1f9a51eddf72a1dfece290f3d824921a6885b8d5472c0c269a55d9f4ad53b308bfd9d2ddb41408e8856eca17395ee8d7b2232f0b3b5284d69b22ad69f5a240cee5a429b5a2f9361bfcc2c6022176c14228da844e2cb1798cd64ebc35759a36d8c7e1c90c305cc5817e5bb2ecaad7239a73f070617cd8e2d3d426942f1cdbf4389f4b64963ab7164bea67fa2f4268c17518218fc8ac96389e7cc4f20d29b8004f6d3002b1830e5c20d903ac3694eab436c3d53e5eb12945264aac9b03bfaef951110ac779fd86e51a81ead5f1378bea341a2bf9c50ec778c127052f5fe5f39bf8e8054343534011e71ca0a5dfad6aa634701c1693039565ce6de37d9fbab6f8be259e1379b6a8378c566d0bf3c591b44345e9e7c10a7fec32598ef946c6e59b4e45b297b49f9c458198db26ab5498e72f4f0a64d979eb64e6864c4a200ad404c69a3cfa7a3fbdc6a932f9c24a757f312c230bcb9f7d62744e027709984e97bb59119edbf688f2048def149f2e2ffa6c42d79d648ebe21674785766c6fa1a7bd2469af093e95d642e4e05d4afb96f3759f18a87b4ae8a684ea54e78187aa6a7f1000765361a87966d41cdc7a35cecd0011990c46280a02c654d5696484b6785f365076e74bd4d84c5f6852f720c4702eb99e165033c986a3dc68e80448c6eaef2b2f2d54a3beab31e3dc12c17831561b6d15a16ce73436982c87fd10133d0f40393a023b07cff9cd807f89d179b7035016aafc8bd1d65be4718b69861cb58d171e02d99435609840b5152cdba014d5fefda1e55480e57e8c65464a8a75b0a3689f891389e0f33f4f99d05423e7a2661cf4da043a51516db0455602b3dda6ad85e47859c8a11812141471c3fad9ac89f309f535ec253b9e98ed3a303a5734751f3346255087a45e3c7e815d8e6b8e90c2f812e5015547b6b291436c889f9ba6f88f81cf14951fc6d434bc248a636b62d4ce91ad2fd28697c9b60d1598332c33fa70e2f077fe19c1ff3f1247bb11c4e607a8bf234e32c984ca37f33c2450fa35ad6af3135d62e3249fa8ae6e9db94e1756072e7d77545545c822ca9e0a0af63b45a745e6e08cf554910de2058b462f7dcbf0a5d1a2a6b0b0f2b4ce0f9a6d7be980b021340e187cbcacc22e68b2eb3d94abec8b8589dabc97b721376c0d2ba3d6f884de9ae0af0a2d4cb23fcdcfa2e088df7e133e0047f10debfffcbc11b0959bc615d638cb26fd30cc8700f34496772962e7499b257204b58faebbbb94aa20384cc20b7d40a08a9cfbefe33b25c57b8759d5dbf1214001afbdc2e7f440ed8f9a583d0cb2f9b79c2e827d58f12b4f301eca3c7713359c359cd95fedcd320c0ba1dcb0088f4316e0b0cf4ed4a9795ea77c59974b57352df7ef59d073a60a7f79d3278d9a59df4d2886e236c66624b2067de8c8f6d160d10231ac959870e22eb4fbd65b66e1939d211d00ec34fe4a39531bd0e2fa0531ed503ad087ec8e4e4ed72cc220d711e79f2d3fc944d64b4331a315358b38cafe54f53d3e0c6850200788b6769cd3c7a8939f30a20e4222ef6a22712a4fc3d0cb363498d2ec8ee672a0a1c786ab0870fe2a03f0fc7ce8a2343eab361418062e218bfe441992c677bab993fa1ab73c3c5b00aa18715aaa1f9072e730472051b4502cfd26704e852d54df29d732e30ea84a2694b44394fb9134e9cda5bea5ff731ca5ed26046e67851ef5433f576070382bd2ded4926397181aa3571cc84f65f77301c656eb3e1d781a128d0689cff5f9510b5e55f3272de71e8762f1af3d82539e66bda0e74fcc00d592f07ed5decd6523df94e08d2f2ee96ac0e9a919b25bc8d40a19aed10ff88ccdf2a445949efda79c65ac1d5249cd5643f69e1e74a73cce3d6506b83f2db501c4c2190b5aba8e76c3cb63db6054fd28f405daaf53a9aadca3c416664903b308339549f21a5055c424ed4ee063351556535d4cb569e6289295aae09b2c1bcf9741f926f268d0515142aa6ff8a2c9825884d828771f1178a0bb3a4e0aebec5bda76a551a24c8f9c96fe994ab826826f8b68964b7a91c69643abe80d141be84a075f52e60a8acdae8077bdfee93fedf89d503cac781239c6e12d76d540eb85848cce20b8edccf16a542d52dc327597faef3e0aca2bbb69a77d5ee17656965ad786f0f6faa9c6414c4eaf8085575d695c57234314ad3b9f00459505ac45609e4732e3e148251147a62021792472de20df822e50e27184a6c26fea219e8cc2eb9da04905772b88ffb69f2908562929021b51246eae241183811462fa72fdcf55d296ad15c3862d7608c8c0fa48453a446e54656c6f90333742855e4c24c0937762b8dd955a9eb99a73238b0fd190aaba41c9399828a6d7fda023fe18a51ebbe177f707a92e2e66b9b599fce8188195ead3ea0c05a98651ad542caaaf236f72de9f2a0c9fcd210d97a54dbf1722b9b918934014cee79c5f76f728a7a364cc7f8d7116cd5194c9d61ea3d4379b3a1bb5ffb7c8c633a6d5cd6b4e1994919ad51f2ba357010575bc9cef5bfbac300acab542a069b106bbfafb30d135629f969d25df822d33f031ccf7d52b745a1bcb50ace42a4fecc0e9dec1a9ad8c8fcab17756ff00f92895f387ad1b2273e93b0d0c42a7e8b4dd2e1c28a211d319ff09140caaa48b5855e9bc6a09ca3145edeff537cec8c6c8ee1fd3a57108f720245b7d903d29868d137bb725635f218dd18c98bc023897e8f0cd655b4beb1c676b95e512da8e0bb9928fa366f7aa6aa6f47f96607436886e5ead07373902e38edbb94ac7f0542409a47e9313a8584cd6f8fd5e09b008c7101610396eec6985e018004a5aa2e6756bc621b43b3fb2397937ca3877936803259ae7e8d5f076395e57abedbf666b4aab848616ecda2cdaa36970cb0f6e6a085c02af54f7759adbaea8d9d50d42cb6dee7718e1949c142555188d5a2eebece815768208a9b662edad1c8d1db689f13e358e7921cf0c92e60154733bfebfee27c569d3b888e9036ba59f27c805cd8d7c650be6ea1594729bf31f2b4e220a21b3b1f7d473cc36e65d2d7f78f206108ebd4f03dc9f10ac6929a9bb08be61c16a24a3e998c15e57632cacc718c825c0c915c13f8f5a242699cae47b65129e87d9b3297247e3b75c53ae296f8b06cb1945df67299068f83645b7a6bd315c70d62521042439cbff52941e4478edd1032cf62161896da46fb95933e43a3653fef938d19e5b9b401c5893d0423dad1f18e73baf166df19f619a966cc5d1016bb674fa8f3860047b224953a6a4b62b2cd193516d20e63e4037680835431d8b82ce2241a914db64c36e50b00342483a31811fc48395260b70b44c74b40325cb81998c033a3580011b4b0e91c2547e147df3ae7543118cac1816440043172a9a8fb4d22cf1d9020374a5e34c275220e2f1cfe9a36eefa61ecffbb48aa6de9928699a0a0ac68e760832e29a2e82f656a0f90a37d8cf98cf644ea32b55893d37cd7f6fda8fa9a9f60bc3a98685b5729361e9f0269836ab103ff2ee789ac3906e9e90d91a71b022bc92591f3a87e28f26348ea0c5e569cea9e292159ab94fe5ab0ec4bc3fbae4b46a576c13671b61f75f483cc204a62d025daf9dc7f38cdf018f2bb148563ba018eaaaa2bfc379aee23c37c9c6777bea0ef4118e2e85394cc723955cf2d7384574272d5cb4b5aebe0f30724089d92985dce894f1aa595d078e86eda3123079e0fb51ebc1ed58b975a85d5c9297fb27570c08bef01bf842c9012729f8fae61f9a25264b85db35f5511d3f0b41040f0c5effd87758052c13a483bec11e397dd6eba6b0d81d093b2717afebce9046ff3a523acf16ecdd3c1f42229f2c30f461d1b893774fba7a3ef76eeb50327f96dbd5bc17d2bc21825dc4dd036845fa3cc9876e3016bb1369ff0abf84f0724fec070ae047d24100e75f1288be575ffebc075f28b7121769334dc28cffca22944eb2ddf6cdacd09f37729e32cbcbba6c650ce30f17c5baeba6494d2bfad6fb9a984596bab15c578960725a5e92b3769afc545515f6413328df3af064852cf2000b1045dd7180f3db21b21cd5ccc9d5d3db5f77b1e577136a5590abeed56c5207b0e11519f261c2906fdc33431e1c015524e17c2104a60d8125b56954a8023b73f7f165fa9a2384803f2672a04e8d3f56f6aaa64a78d9dcf4abba5385c52681dfe4f93f95a2006b9f16aecf31a2f251b1a7a22672cf5f6bbcb0405b29e44dcc08d4ba4d7b6a0d4e25ec7822ce970bdcd5d0f7820995bbbab03aac152cf5d90721f4c83e0c73aa3882a0178b1ddc133c4c0ca0d9f021820656920696db47594b0fed447fe91632723f63b6f0a8b0de032c61b7d31c49e2496e2761aa51051fcec16182a47e382fe4b1e08c14f3c9f05cb7cda390164e0cb3f5952f111e72a1d447f7525457b0ee9a950034bfe3e21dea0baa552f9d92597d8935bc84773fa45eec98ce27dd7370218f96469fd05ce3e70f059e7d46dd3cfbd00ad7105b643907a4984c0e93cc25413eb275c685cb127588d208791404dad027860d646c0240337b20f70a0f1e1c3d4b98b98f9379a737ef000d81b6e08d6ba5aa3f9f2b09849460dbcd1c842c029ae2f042bc41d78cd1db4787e198d4e6adde9c70e46c4508725604a8d0d1cfe43ac2dc8234bb8f3fa51ebec66993a2a4856171268f5af0de31ea11b4e1c961948fea97092d5d5efa6fc557f4f91bc8f7e222e2989ca0986fcf24b663ad008f8ce163e315f35d79256b2b37caaf20d220d1a204d526947a55148a7655c5d5e0046f25b447d3b4b6d216358b6273fc152dc77daeb1e120360f9938c2084ef1fc53dc01fe0464212f03719aaf57144a1c150e15e9fc7caa12ed2dffebaa9eb5543ed1858df54ab3d71409eaaeeffa2f8f34c28943a5cd0ff34d94220ba0ab7992e575b22bed889a1af193a9b0fcb24ee199d75d978da9797746a17948b8936d4e3299a2b0f029d1486e993b30e18415486be27521c6fbd8bdc1bd5d8636c421acdd8925b9fff6a73efce482306ba88b682eddc653d8a52e573e16c13c3d842960f4b6c956a753aa1cb845b53489afbc95e23bfbe74ec4e64ad29fb4563c5f54ac9b16bc0f0f8432c9a41bf28afacc12a3ee2eadbf3042eff5121bfe19c7c5f4aa0427a5a144bba6f26c8af30ba7867aeccf1e3894850a94328207290f4db7b35c581369c2fc45fefebb625dc9de5cc4a6986ac9af0ee0d0b33b9f37249852a84ab6038c423b5ab8a09a7016ff157d53638785a37ac9fb1a2e2ce25fd86530a1568176f1d1c1d675232d4b144093b278875191863a53f8476d19dc70df47203f2d3c27a83ca0a7105d66e59daa5086e303a750ac78c34b744bf1ebb8d8b4d5e504637ab0f8945fcf6e29df37e218ef7acac38da884676fb361c7ba4625c94a880b551851d990b1c32d66789f139c239d4156e06a3e536767474796951d20c3eaa2aac9a049ba21367259c6f352097d79301b128c164aac7bc6f3a9e85d8680b9cb7e0727a39e2a257a091e2c0f1473698564691bb7737c63dff84829a76ef47b49bf94de67834653dfd231fa6ce63bcb017cdd9d6077bfdccc8217066a4102f1dcb02ef38184f298a85cf575c43806922bf73e36b369d083534e8d18fa2742a1fb7c317a23b6b12403ffb06640d6359f6bdccaedb50514a5e79c2790f23d5a1f171296343124d16dccd9a226a65486b2609ff496176eda10a99266d57de79b474699ab7aa218a190daf17309fd9f3177a443125333503944f97b166636c994899cb1ea3e78a6e09ab1b3228a983a949121aea5a24817d153a35f85f5fa7896a69f27b9834d9cbcb82496fc7265488fb45e6f529dbda27d64589c5118aaaea7592ff33cea79182e3112692dd2dbea8cbf3ef5541e149614202dcee50b3ae915022b59129bd9d8e17219ad79f9ae415135496a6edf772b1789dbe530cb0f384ab5c36e125945b94bd975368bf96006068841e5741a92711c39cf037e81929d00fb117645cec2764b47dc436046b919dffb2a79ad1afa8c64f1bc49dcd85ea47811eed586071c63bcafecac1ca5ff760e0ff876f5ab8470b06a4a17da956a09078f0ab49a8549310291cebde7c4bc4b2cbcd4dbe65bf3dc5d34be6e4f4b3edba09b7ae289ec4bba15349195075143b3f1f4e88a085fce89a9e0d6027c88d936d11831c1900f5d263fb28f254d18b5cb18a07dd180c48e84cef4654ef3d4da0aa6d2ad9c25f01fda973d672fd8756b0ff74c41547d6dd3d6d7b28f6cecf6aebf24548c8bedd192275335d6c21eca334cda03fc2d0f45b6d2519bfaf8db59e535f7066187ea7f8ed2d852fb85e422164e597ce0a33c413db083b9d775c90e090766e1bdd739ba962b197405185ff23cd5d6ed5af62804c2834e2ec2924899e0992193c7c616c402efa7c42cdce00536dc0e0a32bcd3060c1f8045a2ce8c3ef47f6f9b966b82a61b908aec5016c43c2e136bdfc07be0cf98a1bbb23cf69dba2a13fe80a90f952e01cc2b22bf5aad5461b1f9c2f864b3cce099ae500c415879dd2e1b2fc51f85d4f12a7977071d0b0acf443c8889d580f1dfe97bd579564f82f9536cf44a6b3ee5ccaf7d9e5c6e9939f3fdb83b35663a6b5e7dccf73f76c457d5c20fda446c7d043f5910c589119409efa0cf30c6361c5f2a2ad68a11d43e90a453258a07dc38e3b00e12861d430ac3000a42b06f59136b31114d8b629d350566cdbe9e9bf798b00d046099436b045101253fcfb061d5071ebf5f3f862830dfb5bf4b3a576869b1512bbc415b84a8d0ed5ae888ee325ba686e3ded6f07cd411ab335905669c037e6b5873f0ef0649090a0efadf58b996ec37a4844598b7bbd42d71d6c54b4e2158e5a9876c92485d046d666878887208b512c25c0309b35f4e7a6ffb1a4a1a75a66b4f54e1c4dfa228a462130549b208faf345fa80831bdcbfa2b6300599a811e2b0199fc2d1a75cce100e03cc95de5ac370fa59f9b25b2c6372ad19734baa64e477f3509159c59ca2522d88ba8341fae1b7418ae84eb9eb07e8b43a5fd232ae7843efe9869b3cef06398a692ed637c0b7d53ccf5b2c7d8cc82792723e42f9c7fa5597aa8e6b51d351acf678e0fad06bb9e76ce7fdd2d92d211ac6de0f914dee6d12c1ffe006942dfdc77980db69720a247b007082a98e471039d5718459f4c5a4197d6ec9941df60276c4fc667dff95973185e637f6335d4135a8873cc941efd221b2e02732af5448a3bdc08a03a8104c391153a717a92369814f1e69b731912ab131156b26db445fc916aa624944c9bfb1ee0b59c8a5036dcd3a93187dee94f0b055e359e6dfdc7624a24815d3d940eb19be9cf3847f1152b959c4694861c7b4890f4cc77f6b318ca6484c70312a2d0f8b22ad2e372bd85157fdecaa46935309cdda83e3ff5bb01a77e38dbee4d6cdf690b571be5dabeebc65b58ec1457789dc0ee9a7e09ad5ca49f4972cb379bda8675ec94a8accd89be50dd90667e62ab2485e6a9abb2c1f0a20085ec5f94d98cb9a3305077f219d3da8d13e8c023057834c58a7b52577586a5b29f4d66d2c91e3c95a0815b8ce61f09fda5794ee9dab25f57ec0c33a7ae735c9c5921def33f85246d76440aeb11df058cee956c02856fdf15ccb66ce81ac41e7eceeefa0583b1cdc62e3a25f22b506c36f6a612222b55525d4a1a20674e9a69a1f74a9067811dbecd55b896fb12cf85c4506f3a874a49a544057f79d6a4eab1200ee02beb6d8ebfc0e8901257f2959f963b7678227e8183e3e1ff512df548f0f1e8d734ddcf89d083f12282393f26e0adad49b6374c6ab43782db74f677f565159f7f259af29d0a92dfe5803862f40bd3d14115cf54e4831316d99e2dde34d0585bf75b5a311b52cdf257a07e62f43aed2255802030abee8b3bab575b7475d934a2529e4b1af63e6a3eafb7eb9ff28e939d30fd711b48e07a3286a3f613526374f354d3fef1786465878b070eaa998994018c90648fa2d0a0130e2f2a4fc5a2efb5973847c4545012e2eb1c3f0284b6d7dd24847865393afb2de4f27ee8328b26f7f2b1a62a05836561119bb274627fcf9c44fc71db57d11a99e61064ff6f28ad302cfea6df812e6131f658e426a098c9419c82680cf2affdf7cbc8479bae6ba25738752795cb52b80139511b654e4a1a2bb40d53fa44178ebfeca4e4f065bb312e5fc950128392d609b7151c309bae36fc220637a4c13333c234ee65166483bd5d30558c05f625532032ee7ea9ba7935af61473f6220d94df96f33dd7e9513ef85acfeceb12870fba63d9a1b319c74a19e6b478f34ecdd9960c7715594f125061181e46250b961df12acd3638353ac239a999af31ed4652318b74ee7c4deda08237dc37584ac531e47d8d3b8a632db62963252d2179f799d18d47c4cc27d17eca7dda1b1cd5d10f483eb62d8a9ca043c36196f55efeca30681e898f465ba96786411472fb1c1376b0730c351a56aff57fb7829048699888fe8990836450c8734d44d62c81eae405752bdc966363bb634c5c6a999ed6859307e6e15ffc7dbe43d5feac1da6dd88b8e3d00cd85acdbc9e6ffb7119615e76eac2665e7bd9b2fd0fc080f2fe6537a4440a4e97d361d9c0f01efd12e980a74c8f693fd78c4bd77cf52301701559016e4214e1a041894a79dbb550e62e52a13e79e91eef6364e7bf4a14724503ae47cdb3bdef163296705f79ed118752388721d2edc07c9ced8f1196f1956226054d0ecb1b5d5c42e800d0b46649416f0fd307353cf47176f8cedc3a3dde80f064a70af8d3b8c9fb3bcbbfbca8578e3a3f10b0a3dddb45c43e3a997e9ad742394308862b93aad9856440806d99af17e167105ee6c57d6ecf64cec923032d80093cba9441cab3cc64f378e6bfd760cd78873f93b0a0faf3644fe01887dadd9c5db6be5f59c2469cc54914fe8f1bc5adc33eccbb3f2ef5128220cdddbba91ce8774b6b702bbb46fa17f27257b3ecc795861245c4581d527e170b88c6add3773ad30c439a60b7b5df9a9c9fbfea31283f47a2f52133181b3c54516e4aefbf3906a52f559befa721534724f0ca921b03c42894188ecffd24a581aec969753a78f1c75ddefa386df1d0ecb04f46ab56f92e52542f8bba977d9057a5f50e72d74d13139d32c83627abc1c7f0807f8a82b3935dc27c064ef0da4dd87c3ce497681f0d42d2764f940fb105a6d7757560765bee358311e04077ab4b30ca25a5f210d79a305568bddb659ee1201dd807eae83c4a5ac34e14b43aa4f6ede86a7db58991b5fdb42b5736f4785350dc6c953ccd70eb037c0d21c1a8b94ee23e371d9a83c991c79c17ac19a3278c1b2ca6b7d4b23550c241fdbdf086b5616640cb9dfe189add9ec1ff14d45f0de1682a7ead8b6faa24b69124c2718a142bc195626f284419d454fd83b2cc7bf590990828a54e2f5afbfcd2beb9fe0d19e350bf4147efe8bd22bb74044c6917a4cfb0e921a8c5ad8bbdf3fe7588c11cb6c88d098993aecdd4b74c5dde51bf78ecc49dfb26bde10a9ee15f23899187a138f6d36a70ddf52618a84b8d2897b8ad671df2cad872d3b11b79df2447c17fdf1df957c4b5498759ac47f9ceb9b7790ae1cf3f767d9c797f6a93a66a7e43f0b1dc46d8e9b5940139a0e6da7c0433682082016ed24b99bf4ed6e3a55ecc9d69b0ce6e1774cfcb299dcb1a3a41fd0253a6f86eaa54499ad93f5a8dc8f366e0dc9a44ad5216d0762e1dcb994f73c5b3d8c5f039427eb0c568ac28c35bbd750bd587356a08ac032197d29a433013f0c1511c257e437fa05a751ad5284361c4920a09033f27989edeb768bc28bd8c3453f34c8e980bca2e4baf4944af58d3d8d2de7b7e18b1dde77f498c7f250fbc7ceaaa4d08d315ac001425faada5bfe6d2c61279f9fe69dd0d2c887ed5732f9941e8528d2938551e59990db18f3d74f8d6c949280f2db39a2be2be2fcedee01932d1e1e3f517c902c61e4edc8ed3e3eadbae6d415d006c7d6a54f4a62e4c21559ccf158f575ef6c81e1317c76ace3c4e63305d7034a0d9dc25820b2bd94c7fc55e997cb3a5f18d11390771e4ff9e035d2d0b4ce6859bcc3c1e6967fe7ba218c77c4f2c9735245eb884f889bfc4ed2cec3fd1b8341c2e60ac73d7e267cd30955cc668943d30116e843576d58a5b679ac0e6ae37b8e57631216a31b017ecb06beb63ce1dc09ee04a47b0685d60d28d3e00a8264ed1f3fbeb75159d10ff393c67caba4bee69254441d189ef00209bb30109dde69926dddc1514c6f630d2a1ad91cf52c3d1f033190095b3dd2b9c2d3753ef53a0ec488f4585e4f27f6f6763ca998d2dbe12fa20668c67e3687e89f686cd9b1c05bde085a47630a8033434f79d3755c7e5fb5bfc4902829b1d8688050f6c95c521741cc4443c8a1a536652cbe62b4ad67cf22696aa4f5f5f351d9397e59b42821d43bf4b187f164d3042d035baabee5453c93d4bfb6bf9f84873eee1f3ba94b17ea4896666d36d37c63017b3da4bc5e3f88d4e55aac18b9c49aa6047988475edd33593c697a168610ea807a7f11f1819244eab305f3e1fc821adfece97dd8b6a122a79cb8a63e9fbf90766411e643670ad3419a712b3ecf32baf35e4e0ee9d826217ee9fd328798b9361a778c6083a7a6e8e42f6ca5edb118a61dbd68c3778784e268a5991d3a670544c729e0e3d82446becd6dfffeefd858aec71232cfca6f94978d3277f32df600f507f166c348f9d1aae9e43feb3941c5ff0bbcb2c055c07e343ab0559d3cad86200b8e9910c0a69f5c006f96f66fe82183b5b8cf471ea9e8c8c33d2b39114bcc21814feaeebabf94e1f2d60616040b210236303faf10a032cde0f95c969a8e8c3743552483254d9cda58b0c28e4aae8060c9a2c790fc8a8e7ba10fafa2a3c193b2fa1c53fc8059efff75b5aa97f7613dba1adbfddd542b25806321ea5a17bc09b82087dc41a1122f97d5276d3205256cd88814e04fabb634cdc33cb69b20d6b76cad7088426ea6159ee123eb6f24b3ad3c49c7bc9dd5d574665169b2f74df912999ea26dcbcc508a92d0298cca2d55a66202ca0bf72f1e8ce9c0596d15835bd20e310334d745b7c589ea85533165249064f2676c862e639560d3f3bc1dc0bef0cf352c6cf784fd8dda5cb384633fceb305fbdd2490510fc9cb7e8f234d4b1d213f42b393079e21905b4bf41aa3808301b9116f51ae07c6b1bb0195e077a4b2476bd34e8652c5fbc5d1f495e8a3330f9d7be03f2721762112f38cb57a8b2df095670e8dee271c0342bad222aff84e12c0c5e50dbfcb06c8d9f89b5d67e06b0e57442a0a79c6c8415464daac56094c3f5d90fd64b575ce93ca9ae001359f8edfe879d8db2a359067309183e91ce103b78f3844ccccdc58b8552b0286992b640c28ab066aaf1116fa6070618bb9b01c564a41212a812cf6b1e547def4ba9c6f9a0863cfbfbfce45a2d0b94fc73e9fcaa5aea782ba307e24ec1616486a164e2137590461d53eb546c33b9a303f4aee4bf7af39748f558b004bea06aaeca87ea27136c360ccbfe1e554b5677e6a4a9c78b033f94e94b722dde676a39fb940baf15ca626c319b547cfe85a995c4ba59153de81aabea87fc496b26c8e721ab5f26d1b7986f01d808ee2852003527171803bb2659258b7f199eb999198b1207ceb24e3905694d374513790701e4e80f64e8cea56799b24240dbf9323af4f93b54e1c6d64c38465a6ad5c9f80b6062888ff00faafb23e34a07154c79993aed3bd7995a0f85eaff104144630b0cefe9b47a50b77c3bff88781145af93a5657f87543285e2a8840288c563ec3d7e1cebabf8eab36305a3b9b102b2b7b697b27bc7db8f8344f01e24801de089c80ebbac2d713181ae3deaef132151253a56d88e4b9228419b31962e42b1d8c84d9f2febce796c5832f66c4d8ffdc48e317c2b05cd387d8c151f4d17e291dc67942695ee59ba064c4ca866764c85ad01bb4cd8493361d392f305f71d5da609972096567cbe81bea9b3c0d6bca0b5ef9c596b46fa9cea059c5dcb2a64668fa6291cc7b74fb371d7970897d1b557630a6ea7151705a6baeff78dcad","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"866d10a5c8fa1421f11baa3a03887662"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
