<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>BC-Drumline-Archives</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #2873ff;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #2873ff;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #000000;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">BC-Drumline-Archives</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"b61b34190a833802e57ad2c950bbc1a8fe613de50f33a719806d3e35f491030321ec7629a5ec1da47e3d8dc06225109951fdb44f4d8fcb07862547eb511e714aac68a0ac45374c70ec584bd99bb175e4ac119c9dda8a5b43174278b2446a6c0885b591f31dac5fb9a8751574d3d5706ec61550ab978d8bb8988e1e6efbd8cdc0f5e606b8e36505a23b5bc4adf0cc963cb165b48ae83fb4a7160f11347022ac7f6143c971700132575d603d3ca467effacd11acb68df54db3e4124c2b642491d5c3950438905b8a4a3166714bb8238d6da3ecaf5aae324dcf968ae108cb5ae46fc244dabfd7e0203abe7252e8492cebbbab301b8dfeac0f2e7e3fa65804d3caae8c17035238d4e548936272ed7c1cf6feb94f6286b6b04fb51a003d64c114ae97e06f45f46a849b1acd4a7640240a679ba2ec6bc50755d5bfd46ff6d6fbefb103f0a7307b8f0651d060c872039029be247a423a876b2118a84e39b5b9ce1bc3b0fad009091f8aeea34a19788d46d5449232c0b63c322e94cbb331ab8181b6132dea83d8401b67594bde4d8a022a66242cfa0347587f1bf5f907b65590ff043d15ab90d87462e2644c800757bdc18abde915ac695adfce2529b091ae822c07467964d2192622802351bfde1c541b6ff38a388745f8fdd98052e1173bcc59d021777ec64fd1778b6846fbc8611400ffa1bb8383384fab482ac2c5af75c5d31163a25ea713fd3f1a1f654b9c6e98d053a4139fcfc9cd1a24b233c6cd35f7b34f45931a2439fe008dc554266b435cbfb104d2f459f22ac746bc6120155f1daf79ffac5abd653198d62a62d409cfdcc5ad0681fbfb051ffe1b610dc403a8a1231f35c39199a2d8e5d9cc6d88e881110de724c43314a40c789c11dfd3e0fdb7a3d811a716eb0225cb77839148124f2bccfb33d2f54d154f9c16697aecdc867fd537b0ffae90a194d4b38c7366e68e099b525d67d553e4acf6402edc28126c7823d1fecd3e34327e82d34d8f05b2c31b952513955ad55e14fb4aea512df2b9611c6cef9a64f8e68044cd336cec88903128dd782f9f8b0d78f240d182d36565bb3e103824de2a7d8ee302d73f3366fbe8cf4a956fa12f40bf8705208841c2b0ed8e379ead02918c16ded55d6478fc44a69ed21096a2a93ad9912570d935593e271736bee25fcfa44d2d31222f09a9416b79c14a5c1bfae8c1bab6572371023113c83cdfb009f64cb09067c6ff2a4d390e337fcbd97b809a0892ca01c0947f46eccbd0a527d57435180ea0e2ad7514a9dc1d4d4c658c3c35a94d4e49488dcb2313d87ad08895545aad15f5de717af9c244502bac26f345b80f55c3c688900510a2e9143bfcc29504d986be5fba774f98f2970c700b522a30cd7c6a32d342ba26be7d5e0e4c8663e18c5b4bb62467608228a07bd4fe6ee70abc0833a6fdd85bd6e0cffa8c655e3d2b0b36bb51e4d3a26cc9a8ee48da2d1d0295ab4e748d6b326acfa8fa09c3177af7b5efe0c4aa45f46b2140b0d0e30f20492d01941dc81515cec43fac67749d4c58ce426103d88f71d756306a6ef814a48b64f011b2415af0ec3e721634019699c7b192a8aad13fcda6ed15abeb0269d114f08feacc42c1328b95fc88ebaf004578f4594b34785d0e34419b710488adc96e101bafcc190cc93f5e358a1a718db7ce923307dfbc303070217fdfc00bb08f655ea9840c33a286d619fde575848fe9e794cbf3e2658a0a3cdb4fa787dfeb695198d8f8794c565f04cc070f97b03c8050e127d458b1f766a2a00a9d624712c2e39624ca6610031aa3225cbed9708e4bb13d8943c371c87797b419f52498f8de21ddee2e4e4eecaf44688d5320144662dec524d81c9635f4ae7e82257788821b1a3f582d0df354a8638005e81d6a2889d00ab069d947b82744ffa57eda0dbb032561b9ab9adf145cc7fa88073395181649b92fd5d8c93f35b2ecee11abf53961098124b48284e0852e44fb8e41c2a4856e911d2fdbdaebd66a95c2ea00e6104b89e75bcaf35b92ad54fd3ebf9a5efa2e1ff41bd26f93c43ea1589efbbff3df9a35dd7a289820947ea743e4023db907434596488625c831170d79b8697103ae24c8cfc126468dedf5678806de9cce227a9b3bf92a31d1dbfbd3d8a2244b78b57a00d06f8d9d899df96aa54ae3553cb6b705fba76a9887de9745f558d0da58f90766cfc41203f2910ad07e840ecf57748672c233aa294402f6f1cefc09fea54d83e3214af5a56e1c6a743e4378fdb0a3ed28fd4872aab7fa6defc84de0befe83fc30c6ba0cf9e4cdccd72c8c6d299ac097a8c9e17111aa19657a7868c485d7db50fd3f35aa9580b9a34e84b5a62fd829be64203c1be807be933310455d4d785d2518cd0c8e64334ea5889fc30438865b3164809a0066382d23860bc5bc69461a29c6be0d0390f75fa8d301ca9ebe4f21d25e53064eecec964ec57b4536b0f61ad4f93a720896f2d423218f0149eb463b9ad88972e5bb6afd5bec907ec95d8e030c78f0eb645661055c63c55152ef86322f95806af6afe8afab624d0459626ff44b08a8d39cd8c9fa296805f3b414adeb122aaa54c0538763ea987242ad395cb609dd3c1d72cde50b1894584d59b12a984aee98fc11a648b5cc4b27d3b5538e466565861c332718d285455cfab6199d1f9183b172fdbf3d5483d4ef6ee763279a02fb0662315afdcbbde7b61f18cf4945691e1efa22627ed0a20e791acc5f04866f055019a3806a0377a2e8e8431a93dab73649a64d40bc9d61985c570425751751f7ec8a95cc04dd11e9b05267fa8a3d0edb86da4a1cdc977dc8e5bc6abff73333c4fecadd0d6bd5d88731d8b063ab73e031f3a3c013f3861a13e26bdbeec67c6d5d179c1809bf45f5eb947221b3d3100db49c132978adf67a8916366c22d78003fc30ba8ca3b32d2e7a35637ee954790ecdd90b9354e4914d9d62193ebe567febc411b636503c00be6d6d07bc6a184bf8c103094d36f610dbff3c691bbd8a5319761f0e0c24dbbd9a8fba6261099ed1d0b03b698bd4c7c77cb44592d6975580bc2aacdf0d377fedbd1ec49a323822e9fc627506cf17a35d85b3dd8a920685de622ef8a90d6f80e8817590916e663f7a3089d94f83f86ea3670268607f448c924824b54d0fd012f95c709c585ab4636a42d8531678de4c8799f7f344eeccd2107cc6c1df00ee023c4f864c1d89305d96225f0a0087c01d1ae1d29b902456bb73ff5d38ce783bbaae338191343f9e4b81d2a34ebf21e3eeacc9316712a046022b187005c616c66a5a0330fcd766062f3c9065b9b81603a486463b6c9d1ceddfc63b51113b9c9298c03ccad7dc3b6fd0b4521c4bb285c0d897da1aa4484066cfc32be3e21c31b14a6033e8dc07686e1e6f4d7ce2350d7449f619258d54057c47df9e52c07541758489094e78b080f92180e3cb285b21d770da31bc1953559c46c13baf00b85e4ec99f1b2eac4dfd3fbf20bd1266695d844f0bdf0e868c2ba5abf520c222ed5f57944db55a37c1fed294dd36729431c896292e04ff8b547268993f355689289b9ba283464f24814a3536ddb63116a0c651b4faf296966af04e93f9b61259e420b2b42acff5a6c8cce6673d7ac53d4b34032e2dd95efd122bf0064961fa47222603bf9dc95e329708b0ab4fd393ef0cce5817c78481fad1753c608953b2221ef8db52c734cedf84e93caed8f7731e6ce30471ba1b546aa00a4c1d5741913b43555a07ccbe9aa322e7452f80e99c4d3f9781f4e0f0bb47bda4952db9d0c266856b9880fb773ca205d6a8c009098243c42aaea59ab75c543953b5d6fb98d0c36fe13a7e9dd7016bfb6efac873b3783a688bbefa25be61d6c4d1a114089b3306901dcdadbddf1a7a5e73c108825858a1430451cec32f59c0d8fcf2d4f61a8b2d8f15dfdd77561467a8066f60c625c785729b4121ab84f8e63bc9cbc1090ad3447239b4db995c5d46ac61cf0897a013212e9c97887865b9aede30906c634eeac7c5041805ef939e86a09af2a0e7c87730b73731ddffbdc2893ce01b04b7746d973275b1c4bf476b381ed9275da552f35d6f678d6d8aae6e8e095a0765bf6960ba88ac449cda9a7c41df24b9930b876f61af6897a792a2358508e9e4c1bfde393a0e24c9ebbcddc899dccd5e9d1f3c81116d99fba6d197369c270432640d74080874774b39fec44e1c61556fffc3a517f7bcc24c600ddddfc3c8cd4e81d4ab4b691fb715a728d5005d79ef52b1639396288b4a9d4ad975b4251a131fb6d0cdb81e709a08245253522e6bfdb13cc9c9890cb746d078d66a7c45e6f67a7960b7c9f857d6dcb09e20cdafd22de0ba51284bfee7972ee2091fdca484c6665bd4cdb18be1cb45504172ddc44374224ef69a63f913a452565f8889abb9b6f031e47a55a24c74801bb196716b8ddfb4c3321493b7be8b8d3c66eec20e79f4eeff744a02e6482da7df689f4ce989ad57d530fb38d7ae0508d48a1721acb5faedec89b734cbe6524f18adbe21af5c80ce07b240dcde2c03200ae9a325d3cfd18c3df06487c4cdac400063b0960c1fd19c6d121bd36950385155e875bc4f5bb301df3af5304071283477ab2a3e3e2c8bbfd1c74a9103c09be5857d0536dad498687e1668df982931bc41d4e14a4d6c43df4c6a4109f2c80505f48d8dfbea80a01a06d0b53af3d05c76c8698cea949f37f975cd5746ca571300d001482e79f518d1a1948827c9457cd12cbf551094bdf7e3c9bde126547ae34387f45868cbf620f4a66cf3d0d61c1f42c1fcf53ec46204626aee51010bdcd0263e2bb3918afafc7ad54cb01949494e5238aa56b919d5aebab84ebce90d7a96dc1fdc74f214504967877b005d4fefcc8f43ef8844301d561e37d1157ec4148f3056788b391f5e0ba655bc5f1192a80702009f75902dd3e447b3f180526bd6f0e1f45f0089e38cf9587ad9062a621824ad7321a8ac587ada7af048a0e9133a187aacbbf4a95f26a9c8aa953ce95ac56872fd95bb629a5f48c0be16b6578d1260ecf45b7e7c02fcc6a2b84d8223ff502da7052677f990f372729321816725c9b8601e6c3d4ffcac90f57445b573cf01b1acda915682d8393eee693633145818b90eaa99dbd49680c96a6a58bf14ebc49e0225028c65f7c9f0d49050374767b678aed89e8f559bc7f6a72ab80d3485a5594dc4d8b6a88cd100fb8f4b2821ddf8bd51aba74d928fa0f7917dd388653592e36d9e2e7fd08f5713febcfcd0de7105023de1dec4a8d5ba2a0adcf8e1a1f38d95a42974e63de9ae08fbdeeff5ee24d004cb7e8b8002ef15c859b3490b4dd76cc7cf12240457b7221cda81c731d559515fa81eda963a900655233aedc2aabccadd73bb7b0920c7853491b68db23656377251d3ae0a8818ef65c07adf47fd4139f91c1276f16250ea523d8a551382ad3d79b7df01e56fc5965d5b2e752c4acbeba7896075e99142f72ded4c59be77555e48a7abf9d12ab6256e35e9858ab6243707ed385025e01673de0075afb866e56a2736f200269885a5022218e4c68370e2939ee7c2501f7476e2973757cfa21827de8eca365fe5ee321a8989821e8478baefc838289905b1385b8895af2131989d28b6ab574c91614cec55b4215df5b91fc52a4df9291f6bf52a55869ecfa04b129c0d9cda9afe42773de62a2b0c5dbd49958855ed1b3a719523eeb1e2a80159ea3a7756b924297f9beea590209cef566b2f5a5d3ad6e42771b5ae092c9af7cd392965e75ecda118cf87e4ac8c99756b48e3ad4c7e493058a1b1581a30bf9dbec1673a8466935f1e02b759cc9f1e44e0c4b98d62472da76f01f091125177075726695d25405e079d154f36e366656bbd51cd7d40de8f722f3b81cc16c26c3778d14f912a522b56d71bb22d0638b2a9ce81cdc7cfe5e8880b0e75957c82cfddd53a1a8be0433ceb9cdcd22068e5793c7441d2bd99d42cd5d3ff352e6c0df7db3a5566c07b1f4483ab20b85b918109ca626769c1ecd4000daee7915b5c5478260cef8f3025b5592a0d0b4db9f7034a4934eb7f70857d402cf3c024f59a275e0a14f9cd9329b5a635fadf021925435da2d6d69e7072c0677a6034a5641f90d41f89c2a3f1b60f749817dcc65e104c00257771570acfe298c18bb2f578ffc33b3339ce4152b5b3c3490b4cd281c177e1cd8b883ebc96bb5f5f1f7423d422827a35efc77e24f84e7279fc2f160e2bbbb1dbb2e252add382cad0bd88b82894ccdc70efd99d12a538029d8e8595524266068751bb77b774ab1caaa2fcb0d8f3420b3e51e65bbe116ca9d21c782a4e4f49d438e567ce586a9bfe1a96becd5a02b7df1edd1a110960886d88393d225f3a852549f10e62f9defcee5ee90dca973bebeebd17a92c3e9960f4ab3420262ac1103a078759ad8d1b9c0c1757ef7ab9094e51ea03fe2c5568055a07db9b7881b49bc690e228958405bb6b4c17737d0a5ade04acf4f1ea1718865d44831123eb0b07727b3a128d3a30ed83f267201485df0a5b9a1aa4b45f796923961e29fd78ab4dec4b79138291e1b26b8b9b62d2a24fd1dda56739495267fd12700d1b99a7bdbbe7860e5d6338fb899db8e485b342b04499f5e494c25b35fe684ea63b06c6d651a1da795d486f84d5bd711f880b2749d7852c5528dff5578136fe7d6ab7e62b4c625eef4fd6238e795600e498ef8c45d8da799c204de3c7518ebe961a8ed7dfeac9be95aa05a8d39b1b99d7e415a695c75c5d90f7684b62127a4bb0bbf59bdfcde58aeee832c7dc7a095ea05ee380ae307f81eac00d67193404488c499604159bb892ad81f0afdc88d83e3b8d6b056cd896235a18f1b93dd664c1d65fba7fc4e2b7b4a5abb8deeb2a1b3ac34551dbf02649796e3d7646fe26aecfaf29314b916f69cd7372caadd573b84280da305d83a9c9bd7c62e6fc4b30ccf87f42d47c53c137c55907a8380eed09b33b5be3f4346cdfdb0341df3b5eb86a05978b0d6a604886f923e673a09bd179f98fc862cb31dacb54e4baa97e9164b3bcafbaa164b99c96b282701e06360b7faa50b9173493189bd89bb9770b4ccb9f82f3e5522691101b38800455f1df403450cef970128fb666d1ef4a2d5004addbfed8a2fc5c2d84d7c1d023f2a8adad5897f2fb437e45c184296776c97852b9d41b0b1ca03324a05b478125fb68b59df89d86f2942cd1a5f3c0bd953e6c528a3df3c6029012c1470adf5067e8013fd2e53f9cbceffd3c3988357ccfcf75604313b9881e4d9270061dcb98bd7bacf3bc55018e0a81e2957a614c320b625fae91c5b173b471dc460d5e98074c70c8fbee71d90aa0d54f97fadcf74753fac3de8d4d6f905921604a210bb72e02912f94c4b862ac7d9b95908237ac31b3f07c6993f203e8b36e171439c5cbc2c02255796f8b8982df8a7250e920946981206851282eebade26e70cd555738cef91067d1785ef3f44fc0c4bc4aa762b8e2e258cc13781791e04ae076de1c81990fa8f35692197c17cf2ea8d696703c3be26881d1694f36c1490149fd188214d6de4fbae3726f121f397c36df1732cb0157e17dc5f562d9a9b320c3871b39c0b08b6d4f7dd3a11087317f42d1c71615e1c141f734ae5d305aa0df1002a4b71056a163bd5db4a910b35b5fc78b62f12a6c7927c1792d15e74c16adc3c9ab4c460675b443474b2b93e56e224d21f059a93d1ca1fe67b31969fcb89e86d05f4b01bb9384eecc5b23eb2372568d3761f00d8c8333f3bcea5a5bc20c1faee34460b0cac847461061b8423d8780079269d5678573b7feec13ee4187aea74b0550cbafd8e213e2531b1c5c2a2c68f280da3670ce5a265e22225bb390948442bf30cedd1ed34b16cd779bed57b2255fa880b158ced1a48a8238857c7c9549cd6105ad11313b592592a2c095a764069c9a61c93b2e0a3c23871e68ea1b4e58893248806ae6cf145a30caa7129d8d318d9ce88a8cd579a3c1ade0b8b5781ecfcffae07ad2c12fa674e8c26b42b1476b064663d82e72d46716756cf6b99c40d342d31c395abec37f399ae32cef42a54d0dcb6e4ed99d12fa7d83eadc0b302f10775d894f3fab8103cba57f65ff6a85610efd604068db16741b2cd0845efcb31f6c33f6e481822a8e48a5312e3a296e2f9008121b1b95095f45b380870ad3aeebfaa480848bc9674c7f029eae2253de6f5c77d5597a0686896c0e28aa2152cc92d0600af4b1d0568460fae9afd51fd6fe161d64e7d4554ab6b243e5fbd509baa38de3e048e69d2bf192f9a813c5b5e61d3c5c1dd0ddf5cf28476516b822d2205d9f470622462f673d7b74c685cec5048d5faa07ee81ab47bd1f086ffe9e36410e0d1dd4cef03c184b0dd8438122268d5e9802e6e67c386a1cad57234cbd6d3dfe234ecff815470186c8673733679c083d9dfc70a7d525627c6772024122d4c70d90f58cb8f235cded0fc284a2e17f53b877d58eb44c473025204d6ac542fce72d530926eb46e2b975e0074a634a9a37656a95d835ac1267bb9baf4f637e4ccd01fe264778d683daf3bd6dae57a6999a5d5566828273d9c6a5a6daf188dd0069cdc808661599c20c1ad72669b1ea965970003175145fe086fe78bd7009b911d4bad8647dbe9fdfa73af750473bdef150e81d457c8899d1a3e42007eb86ca44807715fc6f1526888e3009258b16ffb9517eaa7aebb9a0ff858ca3cca4709c155aeedab8996cb0bf84e9534217ade83991016d293f2169f877804f76ea8d6ece14468a93d8a9f91d06c826e9b046d9ed23d38411a197c2670e5b47fc4962d654de4e9448fa7f86ab551734012cfc8e0cf32885a5b05d6a07713605ae5844bf82d0adbb5235cf2a67423b6ac43a94b5dd5d7cf9b915d61deb4d30d64ffc5f381e1668b2e451193103e52457bd908b6f74f4bf5ca2d7456e1465a2b75a59c54bb9d1ec9770d3fd72eac8c4984194fc25d1827ad37ae145d4359d212e0684cba4c2509d14c22c0004a9e253eb3b19597b7b0ae96047be0b94b404de3552f9b2c55b468919eb582e11f16e72128e54155e970726946af3774aae91f30a7c737f8959c1cee3b4b78471bf0e66f7ef432c029ba18a7bf77ccb7e400de6d109c5117e08c037e6888bf83bd258e17c4ee642de18275bae760f7d3721e6dca37dca2facc8212d1d06a5b4c380e326a4567b70e8cae42ade201b64fc32408580d333d89abd943f177310d5cbb91efc2371a49155399e866c84f62f2308e431cfa98632aa62396cef9d217f99aefc08c572cbc0d084a8480e46473114ecdff2647bd1c1743cf4602b0fa70e8055a814e5266489d606689f31d58073dc13b9ba68c1bc3b8f6621fd0118519f9ea20a6d63b5e39593237f34ab86f897f6fae000a0ade371fdbbdf91c6714b790fa4a0b7f43b81c1303e6d6e6056f33fbcf1660466df11c44837da483cd6ece76974ac47aa78dc9efcbb75fa91955ec895b0310bfb13753b4ce311ac6a23a4b76058628a450ea1f40025c35149ef3f8eeff9a0c17a1089d48822338d2b61726b8b69560c273871cfb054f74a5253dfeffa8a257dbb30421b229ea5a3fa21915cf80508c5ee2e0f6d5240f085b2abc2e610d706d8df535f009f944a7034f2fff29dcb9174d940a69a5f5d20b5a4cde01315a9d7ac25b89a3cda44e0f4249625f541155a1f0e99e05da4db4c0b6db1fda7681bb6a091e7a0bd8684adb5c68cd37986adb500de21f77864d4f15edf8e962579e0e56a31c1363d9432e23d56f740211159b78f08d6d6eb5ff2bb8d8a99c0222e5507a5532d6467f0d95608c92d3523b3e3996eefa02f0afcc5c5db304b89949908548247bdf842968a89a9130b5cfefe4b981b7ec5575d4ccb179723f3ecefc351302089973934ab55533b323af6b9fac7e35086a66c5999b7e0ddc9c7b9c8b25e44a957996077c3838ae5262321828ced2415ec3adab487b5f1dbd85bfd19c05bacfc8ada5f5856ad3d2f5d72763e9c1497fc22c88b5f2926f4ae6c06d659bb55c6ea5885ad2473221167ac719fca91ec56695d448485d622baaaa2b960e419c36fa52c48fb52ea944a88b8c71d5760aa5fb4a8d4dee974bd62e208edf20f54939b23ca098808cde18e4a6c9a5dd91835df8ba6d46959af834eab1834702ba1697e4534a0e5d33524010486746c20ef3174862225f906dc2167dd7ebe76064677c6a56263f8f471d2d8595eda63ef3ff2926f0517cdac3c805a963e1245f71a274d407e4b4b4338b25daa7d096d23f10921120a157829d95264d89b23a41baea647b67948c1d708b7f8c667213f2bb3393edf50f1efd1b9f4389b0bee4f6c73406909c1ccce80b760061b55da2a89af520529ebcba4fa111c41de9778a8875a3861b317d6d6b83a4c3c3137b0527a69f87846e9cefbcc3b77c819ea4f0843671d133e16e7736c86c0272f6e492facc9da8f33675345c0731da953d2475847ac5a0241b329cb288f0452fa9db49598aab3f0d040852694ef25701faeede5f10c1e9bb33945335be1e93ec0e9db87596ee185e8a5823da308c484849136ebc51f30e57e0464e0836adedd10645cb7ce9a94275acc5fa0c480705d35bad77899a7f56488512024976fa9adb01c1a5380b58555a3b23467bbe32cc2957da5212b4754f6789766bdfa1df904fc69338f71c8b362c02100c6f2150f1e3eda2840cb346975204a4602e95039623891d69f32258ab07e301cee144aa3b7cf019020083295503de2c4c4e0995c1769817c8b643cb0442e5498136ce07e04eccbe7f0f68459b2ea161d02a6baa5a72612d9d2bd452a351f09915a6f4440a9d830efffdd5aade8b0181ebb0ed653358374975d67719cafbc0208bc4602bbfc4744b1e23d1d6f569802f7dfa9363e141a9a254eb5588ca2dcc04ace8411ad92350fa9b02d00e2ea5ecef8c10e1d94f388cb0a433b72c6a783bd2742de13e433199891041d18b8ec411ff43b1cba9047461cdd73bd1dfc0cd658a1e18d7ffae8ac4f7cc7903cf1875cc958532c1d17c328e9a3f022e15a9f01104ac5a47e0b4a3b390cd3f7345002ee85ecb99c4435a33a2f531d8a36ce42657fa0e7cd85eca6efc58243f37d2285a09c28dbdb86509cad76dae2816ec515ad7bf4a3b972280d39993fdcc5e271ad85e07956739b8fb8ad2f91e81990b766f651b0950bc20261019867c445a412b1ce49e1af603c450f581ad7395b4e8b7f5bf388e1227698a131866212bb2d5f52ea16f4d1a3939ef8e93f7a210c135df9eca4ab708aea135c888e18453ead0d78e48017c78e7b8cb4339e1edf0f06c9079fe53b93a836d2191a97e3df231139d7a131e570687880c8a675e22379339e102c9bf2076110dd8dde8a8c8848e25df33e000ce5b67801356e7a20c04134284fe818c76d8ca5f83580106798d8ca503e9979b9c72fd50d073cdca89a0167ff197f3cfe0c1233091a740b648f5c919c435b8e265c82ecb7756adbcb0d5a57d0345cdd485f7670e3de9f81f5141282f8868de8420645e716192313599ca5adefe92774c7e2db178623fbcbf0","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"866d10a5c8fa1421f11baa3a03887662"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
