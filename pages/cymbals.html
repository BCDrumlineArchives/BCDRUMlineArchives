<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>BC-Drumline-Archives</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #2873ff;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #2873ff;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #000000;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">BC-Drumline-Archives</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"a7f812b3a7b6c89d9cb43c4a3b1654f8b1df8ca0ed54b0305176b203ed75d7d96a6eaa2229e313a08430ec474b9031a6568cc37429c559d0457da0ef9bfaa7fdcf211d882f04ab05b419ecee98f1f040c98b88b7a7c7a6be6a577e4f4c340d7a665d7166c4207a01167e76e37890ed426883169b5b5e2db6d16b9751dca1159fc36d020b60195ac147c31445e3fedcb5107b549d8b2745bed6593f9f2c55030ecf16db0cb7ce8cd3d8a63df1d41bf263bf03dd9c6bb2fad1a34f2a6b6a1075556266f73e005a0a6e88c9e5871c9bc3cdf97dc5750899d215212baed69aec0010de5ff435406351bdb7895e6b3d7f15937eac7d001efa711329a3cca553640fdacedd79ae5973f2f40ac1d54773d3133c794830e44edacec6fbda6916e7d0c8f12f10f570cb078bb569933fdc409e5330b3af2fd7f3e7f25fb25b11556f7bebbe529d3612fba9dcc44d1c1e569f2f4c6eac09f025718168b511ed47fc8cea06d2866c67bc6ca4da0e119a93af82d013427dd52b0ab95ff8f257ea802d5d1b787996e33601a332ad45c8895dc405f2bab99b94bd89e1675f818b90cd139f948aacb659b70ebbe4255ee058aa8c0f80b0583aaada0321990987b85f662d77905adf0f6cc192dd99575eb5fe9044aedea3e873955b5752a5b95984e15ab5c63a7151a2f70c2e3a14518897e027ce55b1ff2b8f3094550b9072456d5a42dcb5a7cccc830761517d572d6533ce523d2edb806e287a93bb02a925967cf5d10144d8a3526e2ee46007d14e20cd7f4a36df80467202257d6a92142a4eeb534d0046c89ded7f9812e8be980fa34fa0fef87d5999b250383a1e2de581d0cb7f1c69ba4920013b3fe885269b414ee85b90dad4e4a32ad7b04575f7b1c3bfe81467dfd551505610ec4bd2410088305f54809bdc7440d24f183d37e40110ed6123003853e2b97837813a17bc5318029e29d7440a30945079ddc39b01be433b984640de14a66210c0567dbf749006567974e8081d78a0eeace5a84f33b82f3c5546debd5e7d7ae1b048beeb5afc327b587a5a2d23020138dfffc2ec72c34e842a2f74a83a864b0004e33f06cfdd88de8be1ef0bf9fd4fde8d162f6977255c850f96762789afa77ce2953656b35f634565a34f62f5370d07c83fb70569e8e2c308cb196f02dc13b5a78f500e42d906933f040e2ec1ee8bd5b88626885e20d0ebe2c101e850bbf314462941dcafe57d70d694c4b795af95beb7a0e6a1a1e1ac46ba783b4860e6e66eec7b87117258c335d61837a709161f75e39f78d983730233587411015364bf3ec77bef7bb62f7f5805752d82966f0ae6bcfff4f6a009e4ce20f4f5181e6ccc77296a67f452dbc5aaa2a38c10a4a1058b7d24cfe13def568622b6464717f904179c3d8125beeee7b6759980ebf454ab4d0e3479e034db7c5488b32d5738eb64ee0336303fa3360ba866d068c244df4ece4c80a2b9e6838028d9516c6e29087f28148f0702e6407e67e73dce54ccd7096edf598de53caefc1fd6f3f8b6a904e377a817f307f1e8ea179bde9d288eda4aebc46bf5872d27235ffe0c466bd42d1d0d93eb57d314b8a40385edd58c8813be357e6b57540d4860e9c8a0165a1fc1fef782134c436bdf16fd24c51f5bea5b3da8e0df7ccf8667fa5a385f4aedd9b38d8965b59ed6b5df3c202b9657392c39ec98e407f86b1f8fe6fc8d3fa55738b3e4dabd8c98908a70797710b27565e724727adeac1634d2deb9e3a0a49950eda003af521463c4f5bedc744f3d8152f794fdb6abaed6535db6d901fa391db18dfcf3a3294340db6ba0fc02c9a6522d2d8ef1e88a71ddc203f196f19b3abc1f6f39f95a3fcb047c5ecf9c7aa722bbc4f172879ec76e1fb09813411e75667a5cc6ad5a2348d52c9a600109ac4680f45e99aae2f64a6caf9ec24cb42ba2adaff3d04d4f26938d365378e22a46ad55534fa42d87eaa95b9f2b490e8e73b07667875bad99c63b63f87fdbe6f7bfab3a2ef3b2d6be4823d086ad6baf81b1e78520d16062837513a460781513e7ef6b18eac660cc930b61e35caa57d28e4d3e4186045d720a5c7d437a23d425a07d1e41163e99397bb87fcdf7a78decf7005bbdd833a6c4abe0c68ea397db063f47a358f231f2a5b6c1506b69465809bcfc8f5c0eea0c7f3bfbe12b54c70af4813916cb56bb97d1550ff545d63276752fdaad0389908f3a77c46d40f9c1d03f022637706723930ad41bdc08b3ade77495bda9f2d9742c3f083c62289e57f5c7c70baf895ed91d9ed042ce41f22172dc7d5182606705fadbd5440a6304cc997192143e124844d03483877852589117090273fc2b0e593fe0c23684988bd70700bd07582cf1b1f8ab00989ea3c21432456998061e62f02d5079c9bbeff67a91b1c5cd8fe05ba45f67f18ecd640ebd1e3ebbf10a580603471955d0aaec190a856bf054df5f105bae7e236a18ae837ac341ed9a9ba5040ac02e96355579e0e4ddb78395bcc45eb260723ddb118ea82a360d6e599ed73cc11b0fce1d477d558c3328edf873aa22060fe4cac7699ebb20dfd0970a6c0d95077463fd84614f7e88390ccca4768a3856ad2dfb6f1165a2ad088f7298e0b636fc5d4d5432d6d9f8f952a13ce2ec5bed5ef505da8b97259e4ea0ea0b56bac5d0b07ebee6e234712d2f26e190d123e053c333dccd64fb5a3b723b7acec7af97bebb57fe7cab60c9c39a9ccc74ef18d8d0b8d967157a7fbdfc7dda455d88c1501bd0d040b8116d542d41776211bbc39100480de1b664332c299ca3fcee22e60fdf9fe2c69abad06e22950002527ae54f6cb1ecd65d65eb25358d5e3279bd8b95a45a2df912c15e522c1d53a9c7663d68c87de5d1ffbc967c8138da959f6dbe9a6fbcb7bb5a43e2039fde2f7d156753e588c3a25273cfbcda228f4e7ca70eddbfeaee9923e03770c5c80b6152a0a316a061063df583fe0149df6f85ffb1cd692ce5e75e94a52225bc24c1de5436c315379e3c567e442e75a1d3b378c118af042db7131f17f8f27e4259b859ff42320ec3ddbc03b23dbc568bbed47a516b0ad21c7623d5a2eb8fa56cbef6bc673bccf9f75d096b5a7dd2b71b1335626af213d5bd4e25baa710a2b008f727f78d0474af9546c5ef427f00765484bcda9f006de3c8dcba62bb01670c6a7f4b2e1ec358c12cf9527032248d5e442110af1a1326a0887f9d0b6d1973712998a2d994198a11cd759cd5f6ed9fd21ee26d050d30d1a2f6c97875fff290f8696d51a8069bb405f2647b711a55613f91ea2388d77097a7ff4a2ecd3f38a0ed8b36873253b5402f9482790f6eec98377398950e5ee35bfff0e070202ac88aba4b24a7ba59c3da717049940c6238ee7fc17180375aa4d9e703c26947af38f148c1ca6d628586727fd514cbd61d3e39ce07edf88aeded7abfa875838f8d3a880010d2d5fed75dccf9148a2148d8ebd231e85c0423d3c16ded2e4a43a6126457ae47ec338e92183ebb804204c8a972da8eeb2471a28478fe08bb0c31d0839569be9998724e0c18eee1185c16a9a39fe1d8c0a65a8f9b770bcf7d68e4ba4767399fd59d81393b94623828e148f6b047536ab6d079884bffd09214eb44901336ff4a37f976792f7d638b5faa5142c511b9a4480a467a5d8f15030c3bfb8eac1fe6feee0181fedde2e25fb77731f098cc9eefe62c599b8d045182c834ca05e740718d203ec65286da4996881e584b7ebce994613b32533f55f7e38782bc0623f3fc6bb7c2881b363126c062c38638a970802e7b4e0cfa73836f622812af4f309e9c31de77bf64facb6d76ac7492def6829831520979b518cc148f7fe709e779ffc8c1bd1861ed3fd3e8d7fa577f3e64f10459339f8749dfd3151d9f5c44e60654a8e59f80838d92f1b3349b07b001d256463024ee70ce92a9dbb820bb16145b03fc71bb8089194d0b0fb1e6ff32df1a3a66e8880df8cd90cc919ad220206022c67fa27ef0e601a433e7fdab7cb34a697fab73cb95993d08b8ce76db2485e080e60037ec432cf927b0709ba32f16fae167c98805d03c098f771293537f797460bb3851a34a23c623cc4232675cb5abd7c4fb17129390935b80dcaefd5d5ac55f231d8e458ec3b545700e558437efe8cdef58c66936c39f0e565608497892729ad386aa08599977359eb07e6317bf3a3c7bc4ce03abafd56418fd075cbbe03d20b21afdf167880e2afa95bdb378b53425983ab8260f24917a7544bb4c49cb0672cd419967b48b37669660670e0bd997cc6b600699a6624c93ed64d9a4f85221067eff6a26f918f48f566584511a9677b54c576febb1abcafa01edd7b5ae41e9e847c754491a4bf0f86de5dad2913359b8dffbda45fe720ab1ca9e45a9a992570e4a7b9b168252d7a3e020b9752e9aebb80d200b7af6d76e09e6662d1143304d9a55a71ca2462d4bf6bd183963f8a28b81408ae4c4278c6eba50694f4eadf41c8c7a3916af1630b04c3c5780bc02bc8668b85a1cfa1ea6647b9556eedfc85aa1ded45fcd289ae9d18f6fa3571c7d7dfd979c9507cebbbcaf939f75d649ea06ed57d356a7fec9874e7bd278a605c19fdb0baf542b512b17497feb10e47fb36921cf4aeec6a17b690a1afad05ed74eae8dd3d99e9dc7ccf65a7e560af29b2f7471440dfc09cbd394adbfb69631a7929291b9fa858b094134bd7ee79ff15709207fd717c9e5536e08ed0ab986273d3256c09af0d43c06524e815b36b7ea00c8e9e7e0f4c1e34216045da977299431c861e1eda2efdfe41346d151f9601c07974b1178bf652fc81e3dc7f1309e457b54966068cae8797c00a40bdf4962815486d820eefba44dcc5a082ecdf678770dde1bd9eac5a95520b39850e64e71d0677d74df2079ea06185840df593efd9251347cb2cdfdcaa58b9f6f807c51b2206acb6e3987fb8dce767e8691b1f9943626f8a760c796f51f761ab91439b41e5314c8e4bb554447d941e6ec55e3184a77f639276bc9fe7beea1e06e5109f3f2ff378a83a0ab04af120c2da1373f3b9d8eb3ecd5162859900b62162900027fc255cd317d85eb4172e017d9b23964c0019011a3bbc9490055efef5b0723f7a278552da5613334735b31e4b2c24f3aae30e7eb775d2ff6d1c955d3b5503f77ddcb212550572be8e9673d3fa0d5ba1d33f4eb4c158031452347de9c295b16586bdfd91f39085d692cb8300e7f420300bf8abece9ce7e3d0529a651602d0ff0aec58b904432350f5375d1016205e909e362a4c10ca30219af0c637b1b09c4a2f5b2ca27fcf0733ee22efe2fa1e0f7031d9c7a78f5e292627a00fd404b59dbf7128f15f53525826104cc60fc44d2ee3edaf4ba055cbc69b88e31b5846cd5e458728cc75aa49a38d8ff6e0dd7e18f185ac1612a1bdfa08cbfbc0c93f9206fe9b9d5f3fa7bbb2e5d418f71af3fe534c5b730d58a59efa65b63ced67e76364f0649ea638d0c80594eb69f33ef869cfdfa02d9274650e64144fdf38fc04340c531898f17fb75c9a1fcba303d6924c574f42abd7463335662634830656780a88fe8fdf3acec587def6f93077693a02d6a2da135b44e4a5d48d113fa7e97506f14d2d9281801b488a37cf7e87a5dfb4058d14387d52b2a6fdb4cf77cdf591d7037f77375213dbe32ad8473080b07336ccece234af563eca171dc517bb007d8bb2e633c8d3327cc3d613976a41a4901b6cdbaa84627fad360a2c1e6889ce9db3111219aef0600daccf2e5a91983c6f6d0fc8a648ea267be3e570e0b192e62ceadb0ca4b3bb81fe67198571c195f062854ada5e88069562fdb8ab1c88e45ed365701cc76d6b362b2a4a8487dbf010838a126dc5be49e2610e54dc0060b404e54612d09cccd947f1100ec1f54d36d114c7855e93eeb21d4e6dd7a20faf3b7840b0ca628724a327d5e39a82e743e5f9ff035137a42ff069582b73be2c99c594d1153367d619fc9341816c272d1f6ba3dfd37622cb38db46c6b1db62246e098a005530ed13f757c963bf727ff30372b4d31c7c9c67aacb9bfa0ebea37e360dc94330da57d0f16430538deb2e3e97dcafe192bad14e6a22a5641c0bf313564ae815ab9286497fc63ab37c0515fec9be4d84aecc3560d01d58e58509704baa2b1345b79c848a0653bf8cddd197d4c906618d4c8a6496feee5073f0f874cca04f01c63ddbb4c19589e81079936a3a03dcd1e67a6fe12f795371144c6c2290da9d09c2a26c4e4a8946df62716ee5edffd2206d59cd6bc0d7073ae9dd4c27c89fd714694375a98f12a52a18ac6fc5447bb46087b1d719508d6f20bceacd6d0f5b562b1fbc4f5c7751d95263f7f6f32d8742fb3ca013ab84ba27f608ed3dbaa49b59aa4ade263d7d564dd455c28f82bc2357b54fded2e327fb60de794779ff8c996922db770897d365a713328589f179a573f2c4170e6d2ddbfca0a68d8e9e23b4c83aa755c2dc8bbf7864ace39683472f8b187644ac80dfde6c2ab34919652090cbe220fcd25526ecbb7157609742ab5843644ec95e4a918d2b47b071ea238d8aa2b537cb7709ecd0a6b3fa15470108f38878d210078be0fed5ddd28007d22e00383b61e1ec1dee7c33566b261759391a9ee861f1f5728d1030b960d48b533fb95bc24d8967013d3f2ad19c8f240a74cef45ab623efc14e68f139edb6db19fabcf4ebf92394f79034eb94b1f5316cd644463071062bf0855a10dea4cb4ec89d961c704fb5e1f666559778a8e893d56eaac40d720092a82a50fc7d973ce7e4c33c3c2cd44f8802f79c9c6e2b7e0b8a1651440da4c9f68403866df9383e1b255e697f7d979351b1e216500caa7ba317748b5e0330f62045b9071c76597fe338eec16853d8cbd245c5803bfb7480a5e51ceb248cd70d957dc488668de30cb3838ce4b5fefb7b3460deb2294239038a3b36e8d7f5af9041d23aa9ae773fa1db08436e20f34ff96c26b494ea0b2d7a4fc83c4e8eb5be67a906af1ca61ffacba190fd6914ee3d0edb6a09a0df88cb574cb2095960d58099cc09237eff55371bbc253bc32614bd12ce0b5bd9fabaa447bc2070fa8d7d7f3d5e59b1bbe40bcd22c2f8c0eb62ba7d9531ab667a6048dfbe4ef38b79ef180f620d9a8ace369d2266533f7c0ee72edbb348b9571e581c47e964d93ca6234f3ab5dd739e18e1b9664715a52a312f74466c517b555235ca394fd7430785cee2f7091e1c9efbb8726a2b95a53dcfd6fd718b1b2ffaebccb2b4a64265b07710662d50fe795ba69704343fd4ade896bb192b32e645d2aff8ea59ee3902859f822068399ff7f196331ccdb08f98075963b28f8cb1ea565f5d94c3fc40b69bc6cb82a1e26d3d4387fe9e6339f25627a06148d23da7c1f953177565a0449a6498199c5f988fff90b3aff90dc94c53225ec66e42167033f79b6353bf584ff4371abff11cd63d3f0b250813846d0e66fd8e9e24f44d27ae0f6a7baddb6da2bf963d96ddffc49a1a3fbe16557a7cbc2acb8e4c56ef156dab780aaae91df4c3ea41238e2c2b0dc9ebadee6a1e7509a4297d9d9213568d9ec22c0ab42cd2336f1e5eaf47ea3db30626075c2480c54a0d5c8fb220a08af66b38c7e470404a668a7fc3d10163e960b07a59c23a36cf4cdcc961e6f2dfe649bd6cd824771caf312fe4d2ce69c050bee4dea6dc5bbde2174833af39ad3f5e70765ea3c88e8fddf9d5171af2f5700cda47e632f02b821917ae54b4370e6230906e113af02ab5a4d634a234a3071ddde0b5bf47205aa06e9c98136d4eb0322743261f298bd4ec5a91d850dee14ef5c3429a0cf6c69885fad2f1a0a2a9a9084c6c521399721eff04bb0bbd9007085b78edde6cfffaa3fc39e50e17849ad6efe8d4156f1cbcef92b1ae2c3aea5fd9ae6a3e12c1f40aa89b4eaa79a5d0dd7fd5b556773e432d6906c9fd2d0df68cb03bb990b6c61233f71810f2d3233af13cbfd7b7d5c3f4db5bcd0ea4e6b6ffb6798ea4a394863f53b91cd7e9219dec894be88d4aa22d66924f75fd67d56ead76746ae73199636ca326bdb9bf67d5c12afa28808e7fc239ecaa1fb25b62ee06354e142c1adf8c8e04f3559d4f5d24d7138206339b1d315360a63087cbdf50e4851e987a18a33742bd58d5ee6caf57e718c6a041c017821ec2330a17697e8dad546f20c4a43d3e6ea5a4b7ecf1610e6d6c1ae6f2bb8c4b24c2714ab07b65dcef8256d8d832a0f1cdbae6322eb448cbe78f790113ae909bb12c0eb2ce91f93a058302f403f9d9eac0c07fff72843eb9fbbf523b435513ce45eab5940baed5225eae064e9366e03699ee5ff90e66f2c67c2495478a04f5d43eab5ee9ecf168a9d7669076ab6faf85f6f5bf019c17cc6aa018eb805329b1442c3551c58e7677b02f0839e60ccb0692e956226de4dbfe1a3544ff6ae4b225717c14015dec1e99e625f02bd4ccce25dc4eb2a2c536325a7bc52ddcd081ad90c42c341ab0706bf3a25d5a773ea648d46dc8f1f0f76c942ce03c074870576ae2349b0985eeddfdd46a6b285831bf05a8aef224a991c7df7b680cd9679bd67ecc7faec8b9ff5ff80e5e86f6e347970c5e87fd9cc3225d4f708bb3bbb2361bedabc7b3862b1d0c0558b10e8efc288f96b68b1359ffa420d741f226139b733c78dcb5146d5ad2651f2d94a868a1777496a5a9f88166e0d5aff7eb432fb32916eebf39ae54c922a272af46c392175f0b4a2ceffe5b0f7e4759509a811656d5b84968682444573cfde82fd128e3d4c39bd533719fbb808f5541b18f421d923a3bc65e1197f948d777c190223ffeda94e07ef89f87f0738c2f47d38c3be4c3c015b30687268137893eb7a1418e5896bacca5898bac2bf1963d71a5158f4d09ca4fab6357d22d56a1e2573c7b8a002d2001fbf03971ce513933f6359160e173f80b1d5bf2c6c066f3b8f36d456337428665fa73424112b835617c1bb763112dde4b77e71ad234e1dd5bf3dc0842e29925723b78fb4c463031025052d98999aeffc529678a4d8876a9729a0d00de6f197020ef530c4b5cc21c226fc2c3ca4d33da5934a0ddfdb08ecd7b3beeaac39b751fc608f8021a2ab351e78ffa26cc2ad139e5918a172b8071d72deaf14677bb2515b008b01ffe2a3412333d9d5b85e6fa12cce7f97e98f547ad34f98b41b2a4bfa1dde95296e21b0ec30d1867d62893f5b367d85248ba55b05c20629a8e8b3ad8eccab1422aa26c985203e7da8a191058cd9e50888d1a0507aa28ebfc275bce622996b79b264376d014e66eac9a2e67083ad93516aeab48fbf0bf0b10b0af97e6f5a177d5940c718bb26d61f1e6c5a77259cb4527424594a8920ba00a4b67b921d563e7e140e6a4eb0b049f0a0c5f62df0710aade5e1c8b34f9946ced46d8186dcd37901dfe67163272d1b6b552c4b28d68ea42b0bab7419b38a62cb5a01a2924d659dd938c6348e96f599fc3015b69aa34ce06acdaac3b325ccd91621b2d832907b20ce55b9a896863fcbd67f0019b9f3b846940dd19aa33f9949bbbf267de9fcc885ea452b222f73fb2cf05d4d94d3c9c5c27dd41ef1299a934638e0e19765951aee31d4093e219f6ee04a5280ac0790f6efdabdbe987425ad70d7e795aea3ae4a09233b7eda7995af4d1e8a71794ac7dd091cb7dae85c017675afcf6a111d5e3ccc3fe1e035deb1bc1c7847c52f2b287210282152d91bb3456d63d786a07484000c1fbcc9ca86f0b4c195de3027b8782a3bc147763d95243dbd9294dfae4ce51dc64a5ddcd693df22bfe74c4e16024806a6524db111ab056b7b81d0aa3152b04765023e0181095c0998de7b454935f4791fdd074f3ebc4e2c3e828eba9644149a84ac3bb53b4769edd41ff322df705ea5bb502eededf4096ca5ec3c674a9b987764da4c8663b3b59672e0108a973fe62db68250908145b806a54d0cc1dbd2e6799238751b5799f3056add8a2d163ef7e929e4c76ef434566461ae54924de8ec7ddcee812bdd7377f1efe2f30a4cabcb601366c66fc260d36a19539e61626ce169ed1cb71e6254f74e0da3e93b86926a919b28edd46e6b44c41f1365cef0906133443838aacf08343515db6b45014977a3bf29a73b10cb61c25ebc6e899eeb3f6254e9936828bf6576bd71121e1909a18df20d68cd7a7dc79435606d2cb0d149ba2bdb4c999315872c225d96f3411d9586af6bd4d3a02eb9c0faf36b79c9d2bb52bbc8f3b377068f4de1afcf163099a6f4dcd9e56d590386cae9d0790598ac9893eafc2a4a9968eda4c37f27e26d6cdb8415e63590d4785cac0a5b7bb138c881c98d3fc0411b3a914767988e22471c83ce812c27984aae076e28d41c30a86a4850a1a41fed20ac905369dd5f3e448473770f3ff55b3b58be1df92b9bf7aacbaf86d5c3ef5a81eaa7d46e4abd8a02ecc5f48dfd8c75e8e42b8f34926647a14770d31e49b4af453ca5d3166a9ec56b04648e979e9eec99a3348fdd4be566b718143f63e69d277aa6970b652012784a5eeddd04af52216260f09299dbc1a1a694e5a0b08dd3df9b3e009c1596df04b43d2916b48738d16cabd35616668966af19b4a3312021c4662d193f833e0d624a8b52fff75632e219fa1938730875314d4c605e1ca05d8b833cfa0bd997db303922c4c17dbd8b675978e89e8c44c3d301323914f17daaba1b6d7e71e6256c6ebae5421eddc3cbf79a0c4f2cf4e81919e0d2ec95e075465aa70b949f7658c1688ad866512e6981e4448958b14f5811070e422940c800ee14b408a803ea59313b832bf55a5f8add22443e8ecd9372452c9efd1cb4e49095bd64b41cb161c9822d82a8ae56eef8247539e81f80ff261548e698e806544cf91fa214486408ecca0db77d6e1b1715ed5387d2e59c608662411e015032ca89403cc4458ae7eeacb7abd9136d7bc38375264dcd5c233bf8e7bb83194f1500ebe3732994fbfd8b1c5a2026a521f194d11ee1442ad7cd796c4f4f682db955d20041269f9b9f7c3a6bdba3321340c4c794858ba41545f2c2e960b3c6c9750e70493d340cd3924f13dbcaeacad5596aecaba6c9c1168fe7d14836b660375aea09f3e0b4b692fb766d5108fc628eea61653a9db7eaed9c04cdf350ce3a1649c7a33bc76d2e6fad086ff3307cda53da7c6e84bfd284af1e54d7fbc2b0690ea6a4cc697c9cf7bf040e990cf6c7ef2c5b40669595cdab7d229fe6d817cbecdaed53aacef47277493c409ab15bc29d09ed03342f8da7bbe70d270293a669110aaa68c17ecb2bfadf7ea385a622ab4dc2608d9b0e912baf22a36c6e06e61cf73d34872ce50573d699e756faa4ac26d7956cd64c00f2a126725577a4ba50b000ee1aac73f884e62f65f6a357642c12bb860df80d0a2174224cefc0c65c0c103e25462f1df2598774150df4e0d7e256fd1709b8893538541f17fea1ae3a7aeba694d87c7815fc54600aed954eca5d7479a1c7a9cdeef3ddc979755a26417b610dc259295080455089c04e236a6c0c182bb214c946c0d0e493e93946fcce74a61cf4baba0b9e174570025ae7f2804b78fb384366872d11ab5cf01a95682f823c664a6bf8cdf4169d36c057fa606e383266a82f8c56f131650a949e6f154d4bb2ff7561a1f41ec48f2c075d72565180148812654ff43bb3dfdc984090cb4b4e83b2e0e2305809a299bf1bcfa815bfe8c8f0aa299095f98eb82805a47ec2806dbd5d8c75f445f6854872734893d0abce7fa9ac20cca8ebb84ab4c21652b458620699d18e359defbfa2cdfd18aaf555ae59bb58246bca311b0e389b76c0d61ddb92e401ff2c5efe8a3450ea8f89bca15bc759257c01d452163bc8dc9fff9c508969a7aa3a0812a089f2b5e481c6a144a0868bbcb69380b25c3a2bb71742a03af3a6b1fae1d21802a7cdff1b30eebfe4e3a274953d5c11116f1d73fcc395b1f93ff72c5e1c27642fba4cdc90f881361a227d3af43e2d63c0aaa61e33ea1e507059fe7027104dcc65aefca87deed8e8eaf4a110d672c92157dd9121427191af2182654f0507792630dba636ab2121be1fdba9c1dfb4a1646cd04c4a48194a0d6dc62f7180bfcf780a0d8c2a47923bec66fe4fd12c54c3df7404cdaad303fde193ae1dde6252dd2516b4c7e26e85f07d93c33fc43d8b43ab0e3bc63c06f3102212ce6a339da8f715d6c530d20cd4991d39fc5b8671947b447e45ff4565f88f489ae99bf94cfd3a92bbe0133dca621dd18aafcd829f1e65fa8eb3b90058fa5118ec07e93a1ad2d05f0f9f2a162fe8a2cf2d3351240efc4ec022253bea01b9487e3500529b9da21d309c682ddc7a9305f16addff62a496defa8b8cf7700cbb446d23121acb5d73f4e8a885d89532123a8c5a5760a85e103846ec37f3d5fc0624185ca45a20e59fe34c372dbb06f7611cecd670c873e62f65e4c15b3beae0f9af33eefebaa8fd2955ae17f3dbf49cba1c7d3ed7d20cb757a351f513c3eca8496cd3b5d336b33be1cc2ae17d99d251e454d73aaff93c4b7a10e2ebc13854e2eec9952d587d920782d8772a34da9d623af9187f5ed2ae3f7d49b835976a35de8842cfa40c94210d25d37cc493913361462a2ef9fb2a9378d9ce36f9dc575e09d51826416fa31451c62ff563a4cc45d985471167312365fb372cda9e7d1cd906210669831b798bc91ffd73d15e9d9b0d56955b8107e1ce127c9e53e2c2bf09bf68a0ca504a098789f22b750d7532cc07607d74a910997824fe08300edc670680e939a728d9a29bace4a7c601f2bcb44b377f461ea14e74e5dddd8f7a232845125c56dc813773af8edadca5859f6be8d6f72e56cdc1f8c3f46a6e1d3ecabeff44870872849f612f88205e9b0fd52bb7eb0143ae1a2adc6b31715ba766b1fd1ed79e5ce0ca9becb105c44ebfafc82f5d39b1e2cbd17b88f8f876f198b0fb8b73ee0bff579c5014bf06e1401550666dbc0704cc1b38b38899d975aa43645d3ee2dde33fc2b3eb0246ad7b4ddab43f316bb04ac4e2d617eadf64d6d820cf8150456ab182819664916955362d3f0ecc4c0a5b2f1706ea27f8edf62d32b80bbd4ac93f0f19a9f6d8eb4a6ff1e289dcc1de7abd873f0fcff95091f51ef13b6de8db7f11a6097ccaba54ad5790e498a4dc6867473107051dcbdfc1b0ae63c2c01359707c93eeaed39b08fb6ffc061c163717b0320f9199379d57c541aa292f03c2c61c948187f4612e01adb2f4a1011df1bc57d5315b65032e3ddb9a92961e901ba2346e859d597297bffc8124da0cc698cca47a107328f1c23bc45e955207fd12617085c93aa3f0315704b4551ab186308c70b11f8669ec570deadfddee2244133ee24d323987fc1a2de9156b2cd7edd58a43da61d109bdd6232a937267343c691855e709c96ceb4c197933928232f6aec534645287155d4a6d4fe113f26ca3c72d60efa0ecb7262761d57dc72426027b81aa52fe7a64e8647f9e06b0d0534ffb2c0a5968dfbada67494ad4abf82ec16d39a3a5a7506b8a9f30dceed7b9a26ef548e2e6c65a33bf16468935c9a301bfe4511e1c62c825314e55eef63e4b9a3b27e2e4560289f94a9d97e5798b9c9bfc11f35f3c1b84e76c0f062af4625b804ce201f3c5831298eb61f40ee61b3c65468365b1e889c86d0583e21061b8d6f6505dfbe99f33414092cbc581e8245e4e8cd2b12a960a82131e293c7c117dd880163a2b3f216a3015260e27dbfa6ee7347f103cb3252aabeff0e42915566b9a1c64b0d1be8ad47eebb4a6cb472a968cd5a8a08b06304d1d74581bf5aa257da727ada2811b654385016f4cfb50eb3f87f96b1f4ae5dff1ab8cb500682114a5dc6b310f0d403740403357af198dc28ac5afd5d31e77f96f4b766cdaabdad507a2af379319156b34c225771b241a47d2ca84057e4fd4957de2012363d040d5f971aab90d3839b11e0269eb35f3167a8285d72975ef5800b0cff22645fd4e5425180d41e40f74264d5be6224cc40c640f19df05d55aa209e066e82a2b0fe8fad7cb26bc03c796b7ab242b3f2f6d9a53deb47bb8e80433f071640bbd9f47704ae23baaaacadd493342c16c1f497075f112556aa92960f8d954816da0b9f4b2281b1e72983a72c22e89913a2e8d1e69dad5ced61cb2eb81f6640cf68921f629ed10d6e0a639c1e9aaba995580580a69947efcad22d2d53c428044a20d67a4f01fd55a41e4565ebee9aefe935e0c22fdb435ff4a9a2a58c0163723fddc2fcbb705234906edbbb6f4b376f36ef2f2f93ce8e29d6bb845816263164c0441a46e62f0cbe198fd3665c5dd6dfb848e7e48d2626d1f3f1728a0a273f8e21b9bc3581715ef73e5dc95420cb3365c1c039fbb0adfb78b3b38e77ff63a11b35cfd6093d603005f5e98b20351a5684333a8746faf13e05df182ecb5c5cef0accd21272cc3cc17828edf58d85cb6e83f5e053c81bf47cc9f6a47df39c8271b691b1c8b82e9d5553689e0eea8dd32818cff69f0c66ecff6a66595447ddebb69d3834a3bdffe1da058d4be86635cdc212af99421cc72cf49eb8dd9ee55f36e6fc677bfcdf0557d6187f7e8afd60fa5711842f0f2cb128c17b6d3cb5b9f1d8c2e2b15d2365640255d4854628b4544ab640b07ba8fc96165f30c0a4428b7efaaa0e01b5e766bed7f2da3158658374ae95bbec44a6a8d89058878325da2cebc74610edf72396d4312a5f2c205fb571bd61d0bec2b4b0d749b7eca2a5a522b763b4908f78a4a44405d7347db5d489f74aa6e4cd4fdcb4bce032be7ab54dbae0adf67ab26a97b36ac621bdb25d22c7e9e4d1c849b9c1c7d62c9726b86be14b1cecdbbdf8e18614d322b0f97a254beaf0ecaa017e0f18023a7a076e6c6669062c1abf3d679c224efca0b97f8557680b200faab296686540507bc51348d913d54c5aff31e312811eb4759f30933ad11e9bce814e075176c8f252a8df5d4b27baa0edcc07ffca44bddbf9d127bb33e4a9f05c537ba4d4bf72edd91be82508b75e1e4b1c18656131d012ba7a44f2c1ef8b4a63740331c34555c9a950ef6ef1328f8b13653acc38bb5aaf8f9b9e83a5c7e9ea8b79d0524e4c3c5d86243138169ca8eefe35d706e98e33678433654094a28c4ee2c716a2ab028de9428b0b74fe536ef550b7b06d25cff430c8a2a5d84ca9da56cf5cf565857af7a5cf4b021fba517dd8643f3dd844f84fa4ee06f4634dc1e2e3a434114a1b6eeb7bca6884bc98a8032f52449bad26e604aa0c10601a66f71a4331028dd64f3636e589c67f121700d17a27a08662dbd82db6cc354870790a27abb2312ce4378339de2cf37d08836b667eeefa77078907a5b99061f6b92c37005a073c87957c32d510c5186ea90401dbb52538b4f124a62b795e8539efcd069933315c43fca93055395dd497784aa327570a5a6e48a44f1e47436bc3ab2be26276e12b10d6f2d658279d3a3ea77f3e4d7d64006ce66cd1888f6a0ad5f5ece72fdbd3240d3fd99d532d53041ea928f23571470ac5da8fe8dc053ad9493de3b161b602f6ccd020cc386ea6a7ead5f6e8434962448f3f9d3220090dd1c4891a52e70b9b091d8d01509332f0227b714ca37d53283cb49903d1b71fcb618b6b0572180b90980803b1247c299e34cdabddd175ddb2a6d4d69ea937dd788bb5dc1949f8b9af444d16415bb47861c28bbfb6414c8278940f7a9395331ddcab91","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"866d10a5c8fa1421f11baa3a03887662"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
