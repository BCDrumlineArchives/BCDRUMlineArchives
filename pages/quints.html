<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>BC-Drumline-Archives</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #2873ff;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #2873ff;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #000000;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">BC-Drumline-Archives</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"134db5035010fcade2e08c3e09156fc86d74b9b3869e59d920f92c24c96b2ddfa7507bee1863ead051f2e6268aac2a4d44c84a62f765e176df816ea323f0f361a2b6dae3eaa7a7298fa9803a2efdfccd55938adc9a49a2d1825412d28c06788cdbe95b2e1adb39c1f712bb39f74ddefb5787d1322a70493dbe55f91ba7ab5bd3202b08cb5538eb14bf58f77e557d91323bc239c558518eae0757594d4bb7cfa80c8a323add53af336eb5ff24852e5292142a25c4f7ab2ec3fb45dcd76a1f9f2a09904518749e57c3b83acf7736008e15e6831eda3002df74c7f355c66d0546036f3e367911d6b7de206c53b88b3d4d947279298462d9380c71038a75584692704bfed1935cacd81c65dc951fbcc343789894fde8b36152d31d4b0f2b34b09b37bee62dc764eec1fa782a39cdfa499bab4df6ff2301aadd635c92e7d53dccf773597a15534ce25cf2a46220cbef99255a6298697a132be05e8c162eeaccb55ee24340911837e962d0da5327a0bfcd343d4ef6576a8566c0c936b20a894b8c21738ccf1001db594509bb5a46e6019b305004ec26be40a08aafefbc00a499945190ede098053c6dc48de48e812d24db1d37ac741de8ec4c841053121711510af454ed46962de9784cfa83e50fca13e4d4ca5f6728f09bea6ce907b1f4d3ebcf482c0458bf5fb25f3c84748f1845fc3eb45c3946195a7941ba821531d98e4708f5fb7da2195c2d3fce1f8531440fe33bf3eb6a708ec4e846d7e3eca211e87ab28fd9609b1312207f335497e653270fcb1f7edbfcd1c25ef241304ec11bdc33046d5a4801e2613a03bdbd63e2378e47d53f7c759ef0f326b57efecd29ad16bef20ee26425db79a79a84e611d18cd3fd9dcb88f77cabbf413069f9756eaf0653561101e4f7fe7477ab4561bd501e61a45307bf1a35bc6f0673ba0117c233b4cba9ac6246b325b274354965fae09f00ae12a58446bde10fa8b24d7de19c09a2ee97eb139e8cb1984f0440f15c61d69d8eb8cb2357c74de1dba4934300db82f72cd51822e51c79152aa92a1006227f6f44b4d4233957c86115348f5bfd63fea212761578f68245036738d1aa46425e47061990c74eb5cc2c857dcf814d72ecd8a9e5f20818879bd4ef31d44335f3907cbef9757e935498aac325b6997504472cd4bc883acb558a7e569beb59151db108109e9e47752ef59902fa0b9db73613bb936905daf67e9ec2849585a09ed4e53875ab3fd7967c84e5c26049ca086d3e1caf70f218ec6ac7b1ca4e83dff12eac1dd225bbf0b5d589b6f1c31553d637c75711523119c3132b00be00754943f8f28b7e1c97f0bcb4d2a4f228224ac2c240aa37bb26aa46f8f09affd72fd3bd6891e62324648ba0e57a3f48cf346ee40272f3efec520cf2fe4ea68ed248016c605183f7ca53990393af20ce523f2cf0f0ab51422a593376ecee13de3eb41eaab839c7e80c2d6f0eb4b8233f19c528daed64643fc9e5840f98527d05829cac943946c5854b7f62d76f9656f35f9ed9504990316eb3c6983e1f3415b37f1fc7a4f28b8b87c08d369eab4054504e32c172bc1a922c3a0c61d2c8e8a69ab6f89e8a74eb501b87def6ecc3a1103bb0d340d9e84e4fdc8b6cb6493e4f3ac8e267a167f87ac80449aa971ca4fa2a56da27c1d6829c61209181f666aa3da1d731d2485ed9937d12cb523eb45af54e4c3215fd0b4bed4727c10c5a76b25e2944a5953022584b3f6af766554dede7ead314970c6ef5649c99c0b682b305c6471216596a0a7dcb9e7452a0e69bf2389d4f729507252f35f06d153944eb41e85f10250b62bac75ea30900b9c84789a414a95c9df5a5575bb6b83740c98f247c7470b4147926c6fdef7cb138165efcf55a54c20864992486f384e3f9f5b75c1fb1104fdf38235b284404539e1ca4ccf910f697c17db169c4702be0f0192a89328b70098ac65a4918d7656903c93acb8738ca87f969778942fb844a38e8e16de0899f6a25a276ebad5b9d9746a32c8d0e7d2d87419cc4a300bca287b0aa3b452a0565cab70f7a68edcb5e72df5c9ab16f014e62db4cc8e1da5dccdabc298a8051e68405d88efbb08de65c994c57cb878ed7e2e85a57a3c8ea199f511c2939701afb85b821beca48fe70e937265c877dec0882ff1f3e66e626386431af9f58d8ce378ce53d52c2b448356f3873de15f4ddf70d2a027a60acc391687c3b9ffd98571765f6724d9efde2c522bbd8f9e65599cfcafe045f06169c3b4f95ac8ff1db360d8c2556abcae9a3feb99a2bda381857df56cde944ed0e468a35139e63ca6218d95fdabab40aa3035c97d9203bb81e7208bc2938b132e2187ba565e3b29984abf94d62388e37f2574dc3a2e37604800369e6da9180cc8286c991b39645a1427db41f4db371ad2332701e0c19a23b6d72611eaa17e129f5fee87d308fefe2f8442bbca0978fa6c479586afa669cacd8d514f69552d0079231ca23deecea8bda8e2ef040fc9d6ee8c10417f0390a5a89206be920a9f036975789f999ea20a1c2ace80ca9b4a81ad3a8bc1cba9943ffbe184a89a3a2ce68bdb9b0625a6376a19e2eb79a3cf466b1b0bea669f1dd8ff05967cb91a986f370a302fccd6cc722f36bd9033be39eea54967209ac1b940723cf94ae6893b30ea650b3565c3182a7be90b5e9787701db5993304b22c5e7e4dec5a9face8fe7e4ad9790fa94464c305446e7503f54e085a083ef412f9bc9c653cd21b920f1dd2ad5c7784d535191b4b8a63b5b94cd2ccada65b180de4703a37935175b36d88b5c0819dc18aff2bd419a6e5b0d9ec4e8586511e870bcf46d8e3b82432c98739d9cf1a4e5c3d6fedb24d57815bc84b03778cf62718c6c95be136b5c7ce1499dafc71c252d0fa4ad8da2639fb2a08b78fac7fe4c970e5c0a553a6c4f773ae75943d3c9536e0412c889ba99ad049324e9b987c400bd2df3b426cbc3f4729247ee2851478ed0f8ab827ff1ca4bff29d05f42fd5ca4dff8661192749cce94d82246a68ceaf7df3335ab6cb47995612b25f1fd1e5d77b82d4f9572dca05801dd76b6fc6c35c70b28ccb48b85607563fb2b3b59b4ff0f3e79f330b4ae3d5a4cb0671428bfeea726bb34ececd74fa223ecfb1710a8657f802b21c46807e9d15cb365a9a886930b01c233255f19e8f343e792399271d95f8ad4541fad3a230d09562f0e8cfee357a4bf935d9df410af7daec8480b2211d737c365ffba309c00b4070609805bcbebe414a3940272406930476347d54950aaffea92080795d080999655ad7ca5154f4924e6bac7906fb715df3d81e37a3b6e49ff8122fc4a88185e6f63c0c3faf94223f29a8130d9a05453e6a87102de051f3b6d8144b5ffbc6012bcb4dec4de23d175b8b49ea435300141a0c72aeed0b9232a380a51e5105942aebf194cfac26ef849bb015830562393cc71c4e1bf0d4dcc3a54c25a5757090a812840e5b2c1af6a78ab653d9aa76c9202d42927a99d622c7b6c0ba8bb684ad4b4886edd970a69e8eb1810f44a680ce695e06b4134cfcd377707c43dd33e5a6f13d40577bccf2a979245691635eb23ed3f270c1230d5ada90393f262460f234e517ac3029c66d7a35734a6e316b3932f97d2a7907a284667a65595b44af19e5c665536ca076e5caeb5edfb81c776c61337ed8d43401c70f927ea1f0fdb14a2ab87e6b66e07755071b750c52b7194bd2e636aefd06bc410771095adb3b55562e592a7ea20256ce2238894a4d6e195388ce432c92115d5448f1a3eac5bce810a9af395dde091bb4b94632b17dc83f143262d8d04984fbb15bc283200af7e6d217dd16c33ba16dd19190e856da5e8ed5c0617edc85407e5c7ecd5166d6badcfb10e4af35f521f14a7eb4cb6ff44c276da03a1de0a9f24d52c471315fedadbc36edeb549431140798d57d9c4b04e3c9c1e815eef25f5e3f66dcc86f7e64ba923302d082cc97f4d59741042762e07efb8af54a36060b10e48077f523f7e6fb20902e6c3bc9dbf6ac94f4463056e272cf5be45af648a07837fd7772a2e20cfd84421a5f1dfb05c91f1bf5f9487bfb307dcb22cb68cea2af65641c27eed205b933f3fa2274d1128da65c2315d821ec8d515d718bf83f46c1428bd73b33239cdc6e4c449839bc0aab5b5c3c7e0a1ac530f8391aae580ab6304d60b4c4f27b6b912bc71b9dd619d4cb9427e7f4ba68df4d451316edbaf162856388c2281717dcd90064c9528061695c6aacc49251b5bcd86c86fe791f633d2154625d027a2d3f21a6b0467859814d44d6e7ae01738f070964cabb32998901906f571c6fb65e9e931f7650ff398ffc0d829eb947f68ca773e93c11d0ceee989fb413e1ff5744d5f14fdaa430c8d0844a1527e464842a4a42e6050976d33e72b395ed0975316ff1c97c1992f62d00793046e5f3abc56682544d2ebc0e4c373621d0ee48affe7e00fda060512b243707ef66732ecc82eb16242703a4b163418f7994aa0589b084a54daabdcf6feded0b38c5835aa97066ddcbb248c5ed5c3600cf05c851094929c9950d08665d0cc5b6c9910e742f3538027a2758b0aeffd46fd81fdfde2d1de918528b5244a3eefc57afaae5f7c802b7658dcb9af5ea1944606e54a6743a92090f88d7cf9cc30e633466079d45e9af966231dc07012b571891337fc83307bd6729362ef2fdc31dbb8e48e2d4563a097db89abf02823bf3305fd1a161bdd1c2d29311115e16e0634679871e2e03432b6799d3acb876fbcf94ca39eaab89f065d199c4cf6795c292a55bd6b355316f651fd012a8c1193c134bb1ccb0e48138c224228e471d92405fd42bf9775a30c69bbbbbac7e21ce9d708773221004ee606c5fd329d2c943612929d55dbf907d607737ffb704b709ca41ca4b3f299c0df7eb6ad27c61b824512b567ef4b533a4a380bf8d3444a2d016c059d35dfb8e664c2aa9f2e5c3409872eaf40e0ba31b477c5a73fafcab5366c7596fc89e604239204a536438dc5df017b618e083aa7832d9bf6ed60e5dc62a94c1e0e924ea219fcd913bcb92bca3309079f2093a0451d0fbb5ede6309cca7a46442e26f210fe8ea75d2e293d803ec71cf7f28cf6ab140c447a855820429e561d6f5c9bb9e04ee744e4f8859d1e22a4a6d16039661e96f919891fa214a36e5796133c6090c703fbe4eab213bcaf1a7ca42bb3384c41fbc087417cb5a9c8c19227df34238a6e6f2397894fa81d25073155365975f1c96cf65028c3ca9258877d3f35a7e6bb9c4d7d996526dfcb41300ff8cd7853a81f1c6133f1e64501141a4b907de9d1f3ded9797941704339ad82d1a714d1f449c93ee5e08fabd66c153d952900823be0c3c15b195f97f68624df63eeb02b9538a204804b63eed12cecf5310c936b8102a587f9420757f7b88ad01ea1d169c52e0e02082e5c8b8a4332671970c788e3d6602cf733b9744883bf0e105f152507ee777940687f2b58ffd82971e1ef97d11c2a1b84137480625979dcb92062115ecca6c00f731c6b50129fc1eb4d1892aff6ba405dce7bbf74bd6dab13a041f92af34ff565f2a925da4c3576250db2b11226a6db771c5f085c823c85363b3b29a47629fd9f8af404fb083c54a426f339d59bf234a72f48309af206d093d0c206d48a1460e493946a9c07e03039d4695da6c4dfda7d54a888f45680d67b243d1d2c9255646492fc793d73ac2334be5b575e795ab89a78fb9f69a4658b134baa9c3acd4492a8b180493a72b8abd46399675af4089bd2e96a7485527d0541916506eba428a121308574013525331c498bae876ca087bf33de0c6f4ff3765c06f29838aac19d6c2b73e2f838a28db21c641cfe4085ed532ffa3580709d60c56c198b01dd298155d2dd9db17cb548f3f1db9543964cfaa2ebe128d1fa4a387791e5b50d5912734daa69ac492d13b9c87e180616915b6f31fbb9c2b8316e178d4d2e2bc0f25f90f0ff5b538520ada06ccb267171de312a6ca226d0d3747f160a87479a6d33250ccf200712a0d96698eccbccb997935181e9dfe356816763665cdfd049ed06a632e109eec812031c49e7c7dda313e0f81d13af8d7a29b7d7d278f71fb250c0b90ecb517ce5e8335c894dc82ddd1b6ea79a3f2cdc75fbc67cf3f5b2cafcbc2baae5464d57b5b840993f0a593c99459b387617e156ef21b3b22125dd080cb83ea6b59bca05795025c961df93523d55e8818ac4aa3bedbbd0deeeddad134bd291cac1e2bac2f643ff2d8f2d68c17f26af0ef52bd887d62567bd6b6b7ddc9079bbf6b670095032006e5cd106233e2ff1a467fdc8a0440ae713e7eb1237b74b2f20a45fa7a39fb02d5b6d23c358a691b30ce663faf65dc5e48aefaeb9393f23997526b133976f74cfe516cd5979a4f60e22edc88dde43bdf6b1dc45f13238ccff2c102744ad752fe9567cb106ee309a6fc24253c5fd8b330158b112776e259e43ae658364bae5681b87684701fda9c0d157da1be686873804f9cb8c910c3230db12b458dc0e70dbce737b3ce355dd9592ceaa534a334dec87e64f92ca46d33111d60dec2f527c81e5e3eef0d8f956864b6c9551e7f180aa53d51c588c92f3e9447d9ecad726a413c4b158562cd0ffa191e9f704d8aeeb812c0d4ab6a836a6b76cf0be049d0e434839254c4337d33e15191d885bdba3b12df2a5a47d9ce86183da7c75072c1db656901f4c4e239b045eb224bb5e94e1ce4d83c32d7f59cd8461d85b6538f7ff947bbb5760673c6d9100a025833e5088b1cf5bcd6068d589ff6149007526c0242ac77bb6e866ee4937262e0d5b502b9ea270005c42a77a7a8256926154b567a8a5bc591400fa864777768e3019744f2ea99a198d27fa6ace1ca72dca8ff0146429e92fe3ea24837e9ed78f9e457c4010da87ca69ea65fc56d962f849bc9d3dc297d7464355400341213a07be7e146cd91ce72cc20c7b9f1dd1157177de644510959949d0b84a1e77fa759c248eb1051339f708d60d703e6a42472e8ab7e0ade566313a87faaedc8a2b7d4cb05b04461fc6a3db04dccbc6d82bdc0d507b44a58ad6dc1af92e1b74c935a5a32642efa6ffb2d1e89db5cddb77790da4df20ace9fe97ba34b2861aeae37a6c68eb33470ffd1ccff47f54f479d739c40b683db3e93193a34088232bfdd49cd2116456bcacdda5393b0db14daafd7a855ff6730c50132ebbd3803024cd60b394704e2c2e6838a1ca8417e6af12a57d60b25e7a4c35540d3ec0ee8a8b11c2fa50d4afcb390ae2aad4f90aa1e2bfe6ad4b9256a2ce7953a735ab5942c3e759f64756a8801ab822381998e4ea969d8fb2039721fafdb409bef9fbd00785b61cdac0c4c78ae1e8ad28b989274bbd4dd412e61d11430531882f43094e670f02cc0690b57c9a44ec8292117ece4182d6f49b857b567f10f839990aa1d157ce844271e2a022be4fef679e64e79a77739b9bf3a7c05d6570ea6081b4c3c8b87ba5e0e4e0f5591751bf45d13b2fa669f0a03741a33c1f7c7e0763e926ce01287c70fc820861e133ff79f0d4abe9e5fb3508d2d686ca8ee2a877d62c6445f4ebfa90f7835ac12e4d8bfd146e103039aa0ac0a9ba29d6869727ea675385190e41cc05d85f97194fda1985021836602f1f0ff62c3e7dc3588c5980962b62085a0a6e46d3a834e29246290e6d3bdc01de16a7ebf19fd2275553c0ff01547585ebbde5d08ea0d2540facac6c0cd37ad5b4151e8fc7adbbe4b791298f08209fd69f80e2959127529be432b35a6095e36ac738aed87276f9ef5d935e7c1b27145478735d750099171f0cb70f680b26c0f707ffc366d18dd6d7bb227ad8bf2107eead5c66f0c4b953462a68abdb2458a69722bc8e9de915ab67a8a0c41ae64c9b954baacc0bfe7fc960926fc820b61136177310c1149e080f56d4cbb8621762a5dd95bbc1e4972f3863a16e26f84d9cef12cf7a6329f4622e0b7bc45098b56ba1955e6e110444742d6fb8b8db20619ace29de00c92ccdc02844852ffad73f308e028fc04fc017932e28965e9115e024bd2d1b40657e6d4b85f0c1e3b452f7a140ceec833c0c8e768fa6bc2b868c1373ce11e59ba73404f623dc5ecc40b8f63afa7642f0dfe72cbf824084fd3b0f96e98aeefbf801562c632277ac4c84f3a9e8d043e26347df3aeb7787d9cdf3bc2813060042479b247aa3a0da3cadcf3c5418e8aa551cb6704ba092f8248d17e94e69eaa99a5f229dfb50564a2ff1a95ee4a9a72b743ac0f897a5128cc1ebeb817fa48a069f0b18ea4aafe35b9c910d3568730e2d086bfc4f625721dd0cb435bf828e7c1167663f76acf0735e251794013128fc2953890cf9f3f613ee870a6537f50beed7c3c1bc8489bd94fb64c41ff0276dcb4a177015e1658c8d23b356a477d14b117ae9c45d1e5a7276bb71779f4d346c7fd6be228774fbc20b1acabb90006640cf32fdd0cc4198fa777fdf025d3ccba261d5140e2d4e699ecd6a60c27298a7a17ec8746e97a8dfd07cddb219ff5ebb3b4b4b16a43d85327df04da63836cda70609d1cd92fe69880b54ae5370e488cd7593aaeb0ecb17e5dd8afab7c0d2d7d82b7cb45bce6d6c3c4a7e0f031303f6361ed204f0950d33adc5f3f8327e9a41c29438304ebd9757bcd89e4983ce7f98da1cb8270962d68f2bece62094ee58183837082d2bb2045ffad243dc167f7ba81c5e01cb80e4c26793ffb0ce9f6eff9ec3bc25dd933276022c992efdb07fdfa2eab0dbd1187aefc1ec3108d941313868dc60dc075ae6f27ee19dcc518df25a8c18ea0b3bd9bdc20e5a9059977e64b5b349fac4d865f5eaa2c617deffbb21624b1e68d679fc61f43c01e782d1bb58b42abdebcdbe3d41f4ec5f81896290261cad55cc4c732c7a04c5b2335e3f2f3c12399b850e25961ea0791508e8c682b1980caba4e21506cecf9b671505175e9418fb82f723c3e70e5dfbda7c1f4b89f50b1c49246e309861f76a19a8a97b413704c2bca62d8f1614101ec5082c314df63bc78d100c8a4260a054c407fd671128144088110fecfd43a0313184c1ca4d95e7f7d84256f49dc9492cfa2e6b6113974a98a6588a23495b2269e42c590729a330645adeeb2e86b011327ba464e86acdabb56f28018b061443adc0c47df4c358c8f30b2481b31009924b4b37594d936b2b69862df20c283997f780153174c6af2bc21e19a1910459a7dfcc6d7d5f32a2c0beb0eece585e703431296f07ff2e383232db47f80ddfe70e9330afbb3c2c36e372a3a4c160254f66c3e892799448911518c0143f9cddcb33e4f2acc6e9ff15539a436ee9b993b94ccc95d572157871558616b0039a1bf960e9b5017602c99647cc7afcbfb970f860f8538ae3eb601d4a26bb4312ccbec535823b1b3ebd8d4fc5ed86795dfcd574fb45906ad7b93dcfcf80d79c66f14b865fb39bc448269a9b18c1643f84a6c44f5e0435af36048d2ab0dad6b45d5f08f71b3877398bbe27181d1a6fdd79247eddcc77d89c545765bd4af0adcb5ed3995a035c4fe4dabda243f84f2c2f9dee9bc2c84ca6216ebd54153363cd71d2043d1d57b6b83fd1e3d50b1f7ba208f8cca0027e16fdf3183f30e15bc62ccc95d1400a777ee84d51b5cf78b882f4c362d89ba235d56566dcbb639c00036d5969e889ea6403e0063c9e7c325add8b6d8bc5f26d0b80944a96dd0b2d68f200004ce9b5c6373dd989bded1c01cd7f3ca9239fb7008f59e3bd293d4cb5b29639b12b9950225a14ab662a9fb4c8488806d04da74ecaccd6046ee0d086f89931c564e7a6a3d4637f563e8830b082932c8e989711f6c354764efdb4f9e43dc5c5dced742b97fd5bc3a4e9b3f09404cad74cef1753bd3049a98b9a52b5955749741bab97cd2c76369c31725dd5e509dfa027b362e19a52a8ae70b0c92def1ef6b2e882f4b1edddeae5972327e2e0860407ccff08344e4dc94eb0ec2d3bc3bba9c69e38053abdbe7fdef75e09467997a2b5ecfc6e2a7eab219a173ce90f61360691c4964b38efadd4b2374bb1df5e2fddab0ab2d84bf30b43a28f22a10ec9d567172c4091371cc8306ac8404169e10d07993387e0f61c39b247160ee345ab3b4532f830df083e567599b08ea1ad3392ef4fd7e725f7ed437115824b8633b49b5a7c722a8a168a7363abdcbccca657751251231b50799864f464564579784b67f14d1521a5f59296eb2eb6000299529116a3adedb3b0f6f1b5ebc33bf48458ec62756af97b2e0f497ae50f453f7095357255571fe300e715c6e097fc6b18d8571f97dc1768eff4fe75bc4343d1afd2440f3ec8be117320d73710071f6cd41e5a49fdc49c8a1a3c1c206b58b63544dabe50d54cebfcb2d8ab8be25ac1235865c4f75f1f6f8c5045823481bb2b48a12e530addb559e7961b017f68d5dc320e090880ef6e5abd20a4f7d7cc77a2e5905da0465ce84004f926d6d1fb92ca09db196c585844c9ce883a4674d46b07c7f2df7d0e1c9aeda9925179159403c0b8926002438bdec33001856ba480dd96aa2095f876006dc16a53905a91c0ed4d77b5a32711512a6442cec0164cfdd211ee6952c179725863106a15934a7130aa5456107765b815f3f1cc9f960259599ed660d46fb332a065480c1c792e9c0f55ea65e14d9c08889376373c627b0aae8cff33709dcaab9da8b2cf29f0b612be47d8d13088b816ab4f1699f0c7b83e2c77151ce54407e609ee6a5fa3b4e772b203fcaf9240b0e6331bc232effc231a301c642cf21ef3b4aa6b744328cb0cef0591c59310c64011420b7a538f2d45cec6f03c58c2cd4cf340548d64aecec0269aa07d34638158fc52f8735a0226a93cad14dc0c00d95c4f9bd752360aad21732de9a5719244f8bd3f8a493ca1f0a4d4a138edd090d7b25920ec45c3efa50001104fcae43b8cd53070ddfe3458b7ede6961a765f0892c2150688c2e4c5bb847b00f4f5a608308002e980db3e0865e8c49e616c90c5285e31b7e68dc215c0a4f5d2a0f6a528e7669648f5199643008744cee9d8e90ae2e3cb7d42f6b455cf7d0e8a8aeffe501d3e43b8f58f8027228675db6d378b65ed6e2831e91d4549bbd7fdcbae77a01841954b75626333c7a23f8b29c04eaa92f7a7d9b395a42b4e9d15db9fb5619a815f4ffc3c757ba93fcb4ae2f792f63f9add7bed118afd230f8f97bcdfd80abb8e9633429aecadcec65449e0621351f453383c0079bcddc6d88a2f3a72ec77945820ad03955a23b4f7cb166ccf480ad326fabc7499acbfd2a6a0a4ba666df8f9926ca4c895d9e69eb4cf420fd4b7912faf70cb1b9d286788d6edfeddcf89d341ee3bede0921099c57cfa88888c46884388f335d1a89b79220c58fbe0b23b271aae1b86362dce6ce5f918592d3de8ddff0b81c4670de88104aff887dd96ce8a00a786754d67263debc3963b51746ed57871cb04a05cad0b200a77cc1ca51ba7e50d48d5c46e4eaff709ada234ef05bf54af1ec30b9d1040d228d183cc8c0d305bd945e9fd52ac9064fad1992c52e89f3364979f9f7c04e51f06b3fed8d01deb64416274eb52801476e5f01a3502db020c1c55530f3c0b62d8133dc2f1cd0210270f701106204e6bbc9697a602d808b349b0417cb23aef9e3ba9594310d7a29642e5414fe4bb4d6c371d860ae6cc60aa44bf6c6b09d28afd934913e75c4cce78d8433e482b2336859bdad274ae522a41f6fb22abb29fae522d37969ff176a2f627aa5c2312223ebe5fc2033a6a8cde669253134924e5c92a73e52021450c97dfe9ae313ff56cf79214f9a8f2afbaee227feeb574e3a4307c24cb08557865fa08e90779f4907986611bf294108f79b9fa940e1d9fc61e64a0bd08e66e34e39590d7f92029551958817cd2311a76a680c5a8809745cc9348d8b1acfea29f2c85b66b88cfec642ed8a4fd0bef8851f2559428899e30248e230000b9efc39c66a8a18d631f418dc0cc01bfcc93f86b72262daa36797121934cec02ba6763b034d949b15495068ca0fb7e5a6242c08605097cf37fe645a4889b6661c8d07d9193552b5c8bd27f89b34ee7a3f49d0e27c157adeff0c115a28e43550eb6c79b9f03461a3ccc5b21d070b8947e1cfc981618c282fca77df8293e8e782495bd3388771125cb8cc7e1b4f735627a5adbceff29573969bccddbc94dd318e1866cd269f90e24dde34c6e718ae8179349916d02cd50dc5615606cdb817c0395bf3d1b6783b7b26d8bb1a06e45b5f0fdfcfa18147925e3f766ed45a4892b3eb45c62775e6be68a41f90bc105f731ba676171a9e1d45dcf59abef61aafe6993f5fd88084a97d5855ef4e06516ed1ef4f76f5578cbfba1863296b76b5888640e7160e57adbadbac6a76bcc49fd4ed25f92d40bb6f94ec72fd900166f7958c28a10ff737cadb4f7c33f184e38da28c06e2da0e634d965345d54cb924d88326b626363525ea2ed0fbc7e1b3151f9d72b5b91cbd22b06d8a02618633ef6050376297cfc776229e88eb6fc85ef123acf0a9de2ba93147f2d2cb28c9f9684f529e8b53a0ef9276e600cd6ecc7eb1b3b583f06bd6ecb04ac2115f18c131486ef8a47793f21fa8e72a9710f3ecf8aae8034a863dc6fdfe637df7d0ae5ddcc77b54af55c571a178637cf2710d48df335dc96870fa5ec40e3389536c5824aa0d2266904b13803589e3b91bcfebeaf33c79d55351b320d2826d48f5d48602016b736a1d730bfc751023506da76a098c911d057533ed11f85387da969e0f235ee0e467cf01c1ecbd7596273ed7f0eff47b14048f01a2e324b09f526b7306d829697983e5cd6dcbd83a2da8faab2adbfab6d3c02109de988fa280480a271b9cb93169fa6a975443273730664033b60c10929ad307c264a98f9ba7c2d35e5f2cb4d16fed50c2281c526dc95e22770942a2b6545ad6a2c31c0c9a928092279da4a22e87962ab60cd32d055af1328ef21b7d4059c95c2e60ff0b5a6255a095d4075660847ee6740cbfa55ad73393d705cbde1c01e2fb0ecd16b74c96e916320cc4a4cefef89a687b4ceafb6b82b72552eb9bc8712313c850c3982a63007aa4b6cf99d1ab4d56ac9208576df6e8789e911e8dfcf03d10e3d84db6bbae8ac1d4591a51f30de40fcdb654409eaa03a1a2390b8c43c967df8658426b822843109dab59380804b1d8dc73af043188576ffe6552b348fa6397f4ad82184a2d8cca2f0f336a062e42ec3668e24ae7a3adb86c39f1c634a8cb2397d838644430fbbdb1b073d45892c11f1df0dc90d11a08b7985bbcec710eeb7301f9ff22aeff701df1bb13c5cb13200031ee84328578bd6edfa4d756939d28b5a3d76e98cfd2d4c00ac34f17707a05d04d12e334745c9a08d63cc68b696e70e98bc51c3ffa9d6c22199c7d3055c4ce90e50c6f5ef05de59af07ed8457adf9a19a4c093b91359e5620e951a87c2e64afdac5c6ec8ee414c008a70e32d593fca16a7faf47f8dcf4fec8adbc01950f1ba1f5b796fcdca98a4b6123554d9c4510262ebd0611fba0ba22f0306614a577e707d8c52279fc59fbc1eeac46648d364f14f96f295f32275dc4eb620bd5b8812a3d0edf6b02556424b39e27bb9c6f2b37a053d538a379c325a023b24ae8d6be3bbc4a22ffa249d409f7c4dbf14c296cde6053d7723b98f2e5d011b8a517a9c53ce754984c543a3a8956f9a28d46acf1b2aff985b3ed3d8b52c473d4c021da47cb5d6c01845ab9508b4e8184b20e888d10907dd93ebc3ac60d64948f47396a95d470de56d2a19c3bb1c4718f6f18177cc8495284a6504b1e4bda455d5da43cc921c55fcc0da11e30c24a244e213ba0acfa8956a5e01a3663b6c53e46972340e13d46e9dc37e61fcda5188b088f079106a778e4d5fa1a74e57c8dcb530e60a43cd89fc9e62cdfe11471deaa3d0559aa0564d02939ea7e0803156d7504b7251bfa6afc3e2b577de118658fe0a4be3cb11e791038c8d0f946ae1a635e5ddf7f3c92284cf88f4fb04a5414ba0db98ad45d9987edf838b76b3b5bd8f1c2ff44a18754fa105c8b332155a7ecedcf383770f16ea5d63c09db3f65590eb029f9caeee2bd874cb30ef145497479c5a0326eabc3c0a4e654dc0b34afb8ea25c81d11ddc22f8f73a46db706cbd95b255fcf27bdf0cedf928989dd669f98e1134dfa013d591977763e8f0034fd07c37a12cc3b39145f0cd677dfddc1e159bd98fdb60f77c491ecf6ba9828c00c601f2b51d1bbc01a7858106e1274323fb116b6ae2888447823b7d24e6322c0fd5cdbe9a5d298f4b5fc78f5f922ad413c625344b51ce75d6660dc8fe8818cd1fe7ebbf00dfe3c78b2112c67353b95bdbea8152857bb431703f339c994c65d4b45d97e708be5dbeede27be6d7d274cb1c62d5a1e70ce605d891127b92547c82d1230fb57ff6b81704b56e0968d8bc03c17f0348974fb79eeb17e60b67506e82de399f37bac8071b55c38fdbb701335c13e70fb1fcaaa526ec31fe340fe8cbc886143c89bf895bbaf2e0e5830775d0aab37181a9a372896a7aa50909a7d768166811ac4433296c61e15bcdf91946415d312fa6cb8ed808eeea49292342ec060c9998e2aa3649c912c543e4abbc6b5787405f3baa28c4889dbf40dd3a47620d25ea14a8e482ade40308223ae4c3aac11ee0689b26e533f50462b153c4b8d12bfd07f91064b3c101fd088ac28c6d3af807e980771836254692448f8bc030f5f945b6090664e2afcea9fe1a6d21697c8e4d689795efa82e07d0f10fdab7e7804d58ea8f0108236d59a71ed40f26ff3d590d7fe422bbf793d9a102f854585e096ed871bca0418e764c11d7077985748efcb4a677d5e73aa4e52e814d7eaaf1a67b88f70a5f54871048bb82f198ba14b272e53fa2c5f8068f50e7f6caf46379f19c69628077dc11046b3301ba2f4b43c6b1870ecea86b5e5ac47d2ed99e2b7e07f1c3efb29b761d3b0954cc252c9fe51361e29d6ebbc82906d0e5d9ed7817224e2e1d7ed8f89f77b80eb0642e61c18700ab7b91bfbde91dc9ccfc7ffbf3ce5f4791f87f5ebafa997a87832620df71169f2674881a7b11feeacd6a0797fc8a2b7914187dfc6e930782a24d7af7a84b2727aecb5547b9873a88978a636e97e32c31c1d5a309d2f66538a5107ec6108491fdfe6c3456eca43adab8fbcdf9d678b1053493927feae700b5ba82f659f67b10f4e5bf145e89b45dc6b89b661fc182acd7a7ba7d40bc9f2de72cf1c66a1b218950597fa060072b454b5cb9df3a071f3b9e74237e3d275d063aa2a542914b7b38b21c21aeb762da4c8e33a887385c61cf20cbe9395948e3d654e4b3d75bfbf1748938dca3cfd086a11fea83fc9f3105cef967f55816310d2d6a7083c86a907804cd2fa90dae92a977af8fa032101633248bf53a9bd86c0b0de65b3b3ccf5c0d548e53fe9268d9ae3461ff588192b94e3997cf5a3d65e8ef1e1baf118cf846ab4dc08e002712c82da5dc6bf528aae1953878fbb6907644b34ed9a8627e065aa15d4e4b70bc89d890272729c5170a96621e92aa3631c994600318311d9c0268f6d0cd57cbb1cbe34b8ea07dca7ba2b9b5475473f03c254ca7c340709ca675ffae5838b681346bd35e918fee228f5d2ebe546182a85a649a0249147c618e957b50a8186db8d1d438e0339fae87dc305c95614e8dc2905a89cce610265f00bcd71cf31b71afe6bfba7f0b074b337f3df7f3bcd8052cdca3d70544d78dbdb1cc116284a4928e390e07d2ccab20a8c66169020166aede0115865fb99a172564781f8429d093e7dc4ec77e5ccba3dad48fe211d4ba42373202df1a113da3fbbd9c28ef8f6c2c5183bf28403300ae1b891b31d1a84f6f86e7b93e6b314fb11ae70f31c92e69be54e74fc5651a4445af91c7be2538e3ddd847bdfd6cc919f86165bffce7b75e1050f55f639f2ff18bb319f5310e6152f48568ec58300e12dbd6eff995f359dd278f3325bc26e83becffa47fcc8777aaefaa18cd2a3bec0ab0bcc1fa7c2516543ef0e84d490e09944403f55f836b324fc1e40dfd8b1e20ee9f3fb526996aabd350f93c8f84b0162cc3771b77d51a996d11c23e7a7a3b85bb1b54a9bbb9fd8e2daf5c49c163c95fb47173ea9b205c419d366eeb91b17cedcc188cd41d1b035bd3b90a979ed05509cddccf5033753140f1c44aaba6977e1fc282f4b116c9a4f4b0f410ddeb93d7507c2760f120072832029bf9fea5c6d930cfedfef8dbf2e43e56bf5b9ed7da18479176db4b05505d3e2387625a366834471cef9272f25318565ef2f8be4182e940b576cdf6cfb69d85196ffc8215e05abd0917f0951d0b1adf0a79cf4197d84cb3d4f13742abed82f3745dcfcf7f0a62da3ecac27a8b98d6ab1457760b464b68791910dc501bc631347ce93f8745407edc7c01d15f4d9db726c4b94c2d0ebd6f5857a5b0e3bdbd5a3f77c0472589145c31814757648d261e7bd6e458084799ae7c9aee33c2bab42c484ecf4b134300b592cd184f05104cd1a9c40177c0889f312731b925d2ff4ae167920f7da93318fa82f69e0266cd1bef321251144200ae32a27d92762ea7d6cd3ac35b62c5fa6855ff2c61630d45af6a46ade3b93219e5c106a3d595f9a325ac4496c2f0e2c0264a39f7f871e35feda16fe6a8d3492c088dce6165aff8a25e5f080c22ca443061623e6d1cde94dfc8143c50500dd7e334f203cdab53608aecf6f88a1072c6c36e8817348bfd7808cdeda06439cd56e3caff576043ec7be4d8f9197b790f0d6e070a856b018a810b722492acfbf65388934feea107f66f003425e80ab7b67f0a2da299593e15a23a8e13fffb8fe70a9f40bf7c735a0b30445f24399a275e9255173b3e7a8da54d86e665abeb4c738754","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"866d10a5c8fa1421f11baa3a03887662"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
