<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>BC-Drumline-Archives</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #2873ff;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #2873ff;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #000000;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">BC-Drumline-Archives</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"dbc66926863e7e622eb2d36103d9e05526ba0fda1ef31efca0ae012dba3a1d417b3c9b8030cb3f021d76b959f110c122fb2957d3933bc31a3b6b0658d5733c6986edb21e7acd33e7f2c8c52052676082562e60be6571d9b9f600005841ae64a622494c7e84e866aaa09e5b8d61e26c1b2bd2bf5f37c73dadd918973685e71155379f39e02cf111fdd80d661adc967c128ae3086ae234a9576433f39a872d909c44ab634c0f27502be816b22082d794aac0929bc237b6c2ea08ed7567feb20d02e21f1130859d76c27ae9e0105c80fe2a6cfe411752531b9afdbfafe6258684798afa9c17027cdd44cdc8c204182dbaa48988a652ac5137fe308ac8c2bb495c53ece11d3c7642e1707d686eb4b905f24c1515e38d32289978f7ddb43b0ca964be2e3cf8cb0953f61950ab18d5dd379a8df888b7b79c2023e6717f59dd4c783fd5e9b11405aae3eaf0ddc32d63ba971d311bf8cb9d91d4983cb777d46669ea0693d31eff8d475072fa87fad7d01adc653c43b2debb53352f8665bf4ac19ec928eeba2eba0e15d6d4e83707287ac1dd406bad1bbf30d1c0e1d0a6e18f71168eddf2e21e210c8c3d6c75c0812ff63497097f88e655e5994c809cddda8ce769ec8b0c29f1871328944d967a6ff4d902429b1cc0fee9886541a0a175dfef4bf4e15de480a65ddbba32ac06e048cf4263d52061d4450fa4d9765e2e0da18f6561e2687b973409bbfeee135128b10cdc4fc6b62d517d3d24b47d3ef8b3102dfea07f10269af8a33d01a9efb7dc8b746dd4bc2f22bd9690f4dfe68fd448763d6fb29f87492533b9dfc2a8458467c5ac4f5b474a4bed1223e85fccd1168ada3457a41f25df12ceb36c73ceeb8cee4175faa832ffb573e3943b116a0e6b84da3c8278958bc0b0238d3688880e8022fea6bc4d7577f40076f6ca13cac5bffea2b864185993120778fd3f68c0ef0196b511879c0cde253d866d969bb58d6c34a47e389b7aafb21cb75f360080e843fe8766d814a573785a858192b7c5a563230837f0c13f609c7975711c36b115a3dfe2abd96aac70278edea28ded2977c8298ef8cd43a6e503872ed84114bd5af6ad2af94848adff9ffeb08c84bdaaefc907ee3cf7f31cc29c6df2b71db1ed5b3b54d62b1aa0586eefe4ef934ef4b445a158408dfed086f0cd0102b505d7e09038ef47e06cbfd65e64a66f4fe3f301ad88cbb07d1bfeed5451381e09e33ac9db59b2c6a0ec313c695768728143958e08d6cfd0b1f457c51c16245d11a18f27f2b82082efc5b98bd1d21d65b781a2ffa9ceadf1ac597d912816b329a95adffb5200bad21b87bdee392b75e08bc0a906304534cb5b214c4925e802c47a53e4395ccc605517727b569a3524a088d7a1cd08d112c3fda9a36697406eeadf5494ef641cb058a0c36d68690df72ac04ac4660fb2233cf7d7906dcfda7a4aa0166a1cf52d2bde5469307e2c2c38d14ab158383532281c740fe35a53e6e4069c00089e76ba7f08f1e139d35a6fe02790185e71f08ae3e3eeb6d0b099cf310815d20552c9eb6fb98a42da0c0ad59446178a9c6e6046e36d023d2a263d4471761efa6c42b5fa90db6213c78b74ad96ecd5bef32e93a4fbc2537cee7cdf4526ae90a1a6e711ddd33603e843831138591e111a74072893bdbafb44a1624f713f9dc3902e4f2816b51541528280b73f6f8d192e241d60d51e64b24795c6de29702740602af32cc60836496ae369ec8e5aacdf498f5e79c06f9c786e12429f7ebb5244c314f55b4eccd0e7a23149527b83ffea2c87868b19658ef49dd5f1ee1c88180aaeef64f64df874eed5db076dd13137654c63f5db89d2b55e18f58ed76e38c7bc8bfaad7f3e366070d4dcc93e94bde0b0dee811fe9d7aa8960e54fe30e6d122f797a541360bf86dcee3a023302679bab641e238926f0feff4dd3db8b6e5c34e963517d321254ddd1dadcbe5024f3473b8472092e031b7f0db200862a6a3261a53ca97fa60281962af2a64a85e81b8a482ea0a9564ef6b024aa899e99e70486bf8c17d27e0f9792f5266425923c031b4c338e30a8456df76f4aadf4d645121d6bc90fa9aad7c8ce27c435eb2eb98a73a9f9f90c9d606b85016c97fd4ac99b900289b0ef8e082ab7c6891143761881336cddc8ceea783647a4c0535dc1bd13fe55a444d39f9f4ef384830d7fd7fd1cc4c36f294aecfd9e4168f782146d3dc0976b5ae498ac81ba8fb244a5625c74df29e92fbc267ab96d308a20c1b8297f7d8c2633916f50ac32851ba74ceec903e75d1e14a7fbdc2fba0b547245fbbb50f92e7266324805e10d4f56cb3ac20c994794cb1f48d22ca4b01090bace62c3eca5b4d5cb25e7169a7725ccacd8ebecc633212f391678a03fe428c1edc7f09e86992969c7a0f437eb1e1ad38fb107f8fc3b8bec7225a57d7ddbdca89123b01fb877d18aadd40a093d03cdc2d4eec4f6abb9cd82c88f693dcf26aba73ab0971763e69c863ab2e134da961b1fb749c1e0a5455584ef9d2be0012e2e833bc6bc9c3a321fcb0f6a506f49490b2daaf59f02e50e295a0e25241391050a77ca56dca432c616fafd749ec0fc31759485b20b3f6796d60db6e7e1b420bbd729dab04e43e1d2598d05ccbea0b8573cbbb81d3632a155c994c30128fb3944480ee3bdb7e0d85169362cb069dc3e0ca02da47ed23442846c6966031acaa18f5865e8efeedff3ea3af1aa924972806ad4db55ea144ea0f5f7bda73cd3c7920bcda16b5a04be02be017fc60469032f234cb03c4af38c3cf92cdd1e8208bb0f298341075fef56c2c11240d9270097202d07783063ec72e4081e21a9be38a1f197afdcc56b42b29f6bf09bdba23f463863ceddedd337f5a8da2372a7d2239c8a3a060ac4676a23d1fc18eb4ea938b5150302f77afd0b3532e2a0fbc43eaa22e4594a8b1b5881bf9b62f875e9cdd9d977484aa0928a78be3332124a6122849a62f31012c7936898b056ff24be1b911beb30b728affb94b412d8ff0d6ab5c3bef8bae16c988cdaa3d6c8f429ba12f3153507b98c98d43de476bcf7f458d168ec6406fb5c8b4f1dc6b75b7d7d607717e682074ab5f9cd7ec22d86a80bd06154acd651a346d4842c9dc86bf8bc486ccd68d764505cbd49a7a72e22002760c77843e682e89440ceca62673c924bac06de5fc111fa76036c429013c3d101db9444e4e7e82fc4db836d49e330c9fc8667f4924d569253769f764e7324226d01ec566bd848442193de06ce937f7767491f25f1e9aa8d9b80bc59e5a728f96732ddbe137bdc4f4a657f4089e70c886a5e04b852a66ef2f8c1d3a345545f7cee5d4fe357b07095cdc1bef42030f3a65cfbe7b1fdecfc31804a8daf235cc239665c24c944bc6b07de1103e7b18f98ec6c8cbfd1d5cb07b01755293c9aee41bd6026f3c831202797242f28ce82522c03de223c3bee4eb29d30238709cd724f3dda7bd975b89d587860df9dd3a9cbfd63db31d0431cbfd7d3c80ea5881ccae496e50c7cdeb6f73ce56108d2323035cd37d1ec5717976e18ad3db749ff96bee20d6b004d48907927882bea4964296dbfd9a6d13ba67f57b43c68e8237fabe77fd3400f2cf2cd42645eb025df5a0df46374067b5b498921415a3e5282afd13a185973bf45e27d45ea681d1e91f06094199e67837b273187c992c99fc0adc5f7b40590d3ee92db037979d39bda3c0298495d65a123e2995735a7a377144171c80d6eaf7cd3b859c99c77688672c29e4c0695a120f412abe1e9a465fd57ee710bb90a21e1bd605a7536b150add0cf35b7a254ed4597a6809a9e499783bdcde3d421839bc404937d243e902bac1926a678bf9cdbff50d517ac0df14aba446be4b08f6160076e959ace3c695ee029029c776c5a2f1a9e72b5d88194cf0bd00a61ba3de847e0604872416972fb796147cccd1f67185bfe8fae48d0e6f3b20f111fbfb53bec91b4331ee9727113698add5fecc7be9a311fea79378c3c0a1c6200691ed3c8f09f37905fb19e597ca22bfb624f1583976e82e6b9ddc402035543928cdbbf4e0d80334cb39b8132020af7d6d19f5c4c9829ef1ad30842f192f32fe540bee9d6a0c8474a3181f6760513b2af4d0a9092496880e1dddf5dffc42e4048a80430bf5337c906b8c92ae63e4d2e9498cff5c847b8195e15e21c74ce1697e751227a619fd433df2cf6e690d0c6d4a9045e4232cb4407f3fe3b143902d1450c07051bc1fa2f30da83aebaeab20193fe48cc22d70cdda50ea8d5bc4083a195142d533cc638f3cd394943427c9b27bff00b2994fa0731dee5b554bd33380ea34e9f774ef90da571839ac199c3726fa73f5ea23c91e89b0ecc3945605c6167b688bc59240019cd7c36f01894a65ee373b3082577cbe7245367ddf0989b8b115d83261b27835ab828cd432210e1551b12fbdd2e8f3cf66a1f2118d458a4c32e97535d737eb49e23ec367e4536bd00feca6abc40349a201b3c4b7470e4a48927790078bdbc66c609b7ae394f7694274ea57713641e2dd726bd97912c230b5e87e4f5a0343a0103386fd205d6d8866ed86457362eaa7a55d5e99ecc4657514f949434cf3470fabc1977b6d0212c43f419b55f349f881dc88ac88ec9dd073a90f5057a3372cb76357c0cab231142e3581da58a57c27815d2430d549545805c873e4447a1b4f9b304eb0cc8884b3710a5c68ae835cabc21e057e1eebb407b9714cbb90203ebd8e261dbb923ba1f7510661348c93b4bf271388022b8b8b7d8a3da6a6d9d86663025c59a33e37772e653fa19c137bd31ac9fe67517933dd09c291fc919eae6eec9b328800858f9eae38ea1d640ef07211f47fa117748761f1efa64e144545ad28e77ace590b59a3ef92bc4c103c1771ea24842f152d2f655da15387562e3f6ab79865ed6b0996f646361aa6049e29761f31210fe8517460d7d08b8aee5e1354b60201fb1e863daf47e5a3af423244729ffff8698272f805ff07ae7e94ba8e55afb968594e86f7d417426680b23b36a8dcc5e9862aa07e6a79e2192887bf7cfd7fb544357398a3f2d0782ade78a03091f564f56881e21d6bb4bce012d38477e29e9b8d53b6a6cda24100cab7296d34c24f6bfe05d3fa8c6f90d83d7a28529370a8c4e56df636765799a14f2778094388d72d6fa98540f8b463d9ebae14d6a2dea060c9f61ecde21535862ab6a4b2fbd347432e3985e68af4bb793f0004e85115039b591dafafe1a6839bb2dc868a4edf4d68e327c48e3a3ea736a8879f80175afd9e809c7bb897e41709ca2a14ccf4fd36c856376ae9f3bed0ad148e4c4d6f46a370bd57b8935d5c3952b38a4ab205e085e440e01592697389f3c50889e7479efe75fbfc67e5b94586dbac8e3641f2ef72518daa34c678d8b3fe9fc1caaac0a5b9d0fe3446be927f404cd9ed881bf6f240bf2c2bf44141f0450b2fb118f8cb1a98d75182f91288c566a60bdd7e7f12ab0b3068a56881366f8014f58b498277452eaacb1f1e33be16c07c9d9a3fc83db154a3afae1222fec91db1258f12605e94693f8b913f3fbf56c924a933333d791d5647c9a5f1a96ba23637916d4034fdaa98f44ccd872199119fb1a3895ac2bc9e91e7a818125036f43fbba334233006df7c93d48f12f163ef1fd2365246f7a769caf2aa1a676a41fbe9fca2f8b847e036b35f2abbc5bfb3943cc26d493764e151e4d1018b1aae388706e834a7cb65c831bb6063d1aca02d766c48c428a4877e984f8b25d8d9d41b50a70c62dc3cfd4664443fb92e790a6e73265e90d071926fe6c0e7b44d453876932af2a9dd60b2992f8c28490145e397e2161ff566c66627cbe3694ceda731d7b951fb9a6975e3c991629d34884716bc445869b94b4968893eb70ab540b25e64002bb9ed71ab87e30671bdb3923a6cdb340fe152eee2f1bbcfe49d9cd55495545457cf88a310f24447c4f233fee57a34a075ee53c84932069f5bc4d221765eda6590187f1ba7a451e0ced234a37c3886c7c69ad9912e9dd01e461e49fb82ca0ca7052816ef43b4ceeaba8445f47dd45235227b9114127791afb40e290c99cf7501e90cc5769578c1dccdf1f214c50284b202bf928d5e9916d11e02e486367afb690bc3f6569654c2c06d784627d46dabc6d6a87c3fd7768bf60fc9a66e5386a861a57866f794d21cafc1724bed41a788cfba75fef9a43b3fc2f84ab0ef97bba2944e0f0a58cb8173aa9af2961535b19d7af1692e9e4ccdb913839274a65252dd1c3ceeadadd205719e8a33ba9d989d997dead2ffc6b98def86fb8980856eaf54c83b1ab04e0d2f10d190448c387c3a5a888cf2f343c0b4154d1dda02ab10ede47bf37591b9fc9b3f8f1560ea9f6d764315c09184210c0275e23812800b379a35b786a2f8f1a5eb260b704f45acca6bf9c1a5534519f8adc64ff366bb5c5fc56855a4d913ec67c14eacda48d13e23863df73b22c8fc54806fb2d29430327e76f8077acacb3b449fe52aaeb8cb5a53d0ca7b0a5b2c406aac15df86f0d99009788701c28795dd2073d0e5708d8f27fdf65339ce27d9b716cb750a53cbfb877061b2298233e0d3504eef6f4198f8b7fb964765550d09111a621ab2a1a5c203cf395002f48a18940fec3bb2cca6deab784429cb3a37f7c19ef971a31d9df48a2d81d1d0dcf36fbbfb4bfffa6a1d9ad4783bb67ccb283f4f4a77d3063ffea990e9e306f585539421ce7928c1e9fee7367ba19d66dd134407559c88eda960ef2bf95716c07549002e71b6d691601832459040377006163c34c00a7e099c9eeac870592abc6eacaa7675526a4151c52a7a15e754265ea1ff0702bb6b9522863d3837f0b75d6acf25ffe45e14dc3e75ee41ff81a3180f0de49551fec035daeb6598428c5b929aa92c66b684aae125041b95321b0633b7cf4b1fbcdea053b6207883518675ed486a25d486686d86243e6141a3a04d28c21c09a898dbc870ff387987fbe9da722d420db338dcf6a53a08876104aed74fc55bc21b9596faa937b453ce0ae13dcd569957cf464218e7238e538f89ebe336bee0dee69be9ccd3b21eb081d427a01fc889728935e0e333bd6b4116eff30ff7aa172f887f2ffb6b5f78fb01f71e0ed80ec3fab9c7b4f3b28759e5e3ae9a198d6d3927f1007454c8647154572911585c3e04ccd9c2072cb023534c9d3d16521a268f65ab91ebd5602b6ae97506783759ae66b81509b94b6f458812386bfcecf39853986401e8348cd514589b66296e109d340ec900c06d51e3c059e188fdad83296d2316ca9b4742f9620ec23863c8b6d5996694e77fdf419ea9aa5abad4262a2c568ae7484cd19074e0614d43a6ac87270d682a94b4402eb926f4de1264ad3c32f1df6138bbf9f994d49bb77b68824fdadabefb02527f016f1bc78f9ba36dab9718d3cfe2eac26b217f103594d31b6ffb945bb1d98f8ef298cc68320f4da37bc5984f83a04560fb364a097f9ea3ffac90e61e8cd3f2a5760730f3c025a68a9794355d90d07b0aa0e1b7728b8b2b6281732b1b7fe4a1ada754a3272bc2c32f9de6b114a7dd8f94a1359cc84901125addbd893128b09e30bee9b317022d6b5792dcaee8c873b4b1733608053a4080483cf596e0f743855d96248174486987c202f32d9f69c0a9476679294948ea8660da4d6e9e11fad24a32fcda636f5126c23a91acbc33d08177c58c85dd9797a17e08aa1c62bd035f88bd147d62058e9b7ea083877b21c62b53792863c2445958c5c9b5d02c9afa7435c6f9770111d772d7c9256f17b46d3b8eecc82015d35c289e40f7788c28056cda861f40e3b8b36df9d465e33ed318acd007a0593f9a980bd41eb13d0b6b2529ed62d2821941663721b10ed3e699e87142210af5e7fc05b1b3a1c82279fdb26c8f934954c1bc9cd062f6c9153c4e9bbc32ca2a44c2753f24ac7d57907d4eafa7203d42ae3f8bd8d4c2868011c7ae037543a07bd604323d68abcb3bc974ff644fd1cc23d5f47ac101251265136409df7841ada32e7cc0572b4730b1be9b8d844dbf9a64590d7dc0cc76cd4d237edeb6dc2e997cdfd9c45c23d9b2b3088e399dfab6635717bbc7475b81eb08266814890fda30ecb07eea7d1dcc6314df299fb7e7725a40fbd650a56a0b301d3cfdc75edbcaa7e3372bc24bb6fa832159eeda10a979dc88c293f73b412ad460d6fc76ac19774efca6ce1083699d185e2a41613382c41e4f5672da0e001784d077c274474b1bf79b2daeed63890a826bb442b92dbf71b81490de8e74da17248e5a9df48eda05a54a16748a31b2e0b9e336699018084dfdeee6c346f7557c01dec1d0006fe981d023de7901a8d8a70026f27e83d26d611cc2a8df852b2eea2743a212de94d1289856a3dc6788fe36b4fde9d719c91f4665f15af451f6da49afa03e2fe9e17eae5c71aa3f51cb260e21dd1e36a756cbcffb82a75428d3794cb75a95e0baaf4dcd6e9caed6a392d3f433edbc9f47f522ce8c936f1ea7120c518cd68808fbf15341fb520b8f615b6b96012777b5e734e72669d38cf9e48fdb077427054e05e780a1f1d4f428592fce32caa176dddd4e1d1f86b68878cd549ee6a21e89bae7f570a1cfd897da56c065faaafb169b6afd237411fae431f002fa3c9966cf4278935856f9edc7c17fdba3723797207910b7695fc2f967b3e3749ed14ab54f6202e3c582b71636c4123f59e625c2928ddb8471385792f9f41320887ef7806257c80827e959212b608e96789bcfa74ad4f0485031b79148b0b428efde324b4ea4b037b41f3e1ad3dee9ef3fd3d6fdc2ae8e77cc65ac0cec29f7f6f65048c8d386bd0b38b23bf8aba61bd3109eee00f0192569f86e2fb24b63032b49b03800692ed3f77cf64f311fdc7bbfc4bc16803dceefad0c1b10ee26049c1907746f6785919598f7829df3303bd190042f21e36c8bf42ca52212c60f77b00b7666cdfb67d78f5d9773ccf5cd0888997267053a4ba43c063fde8b828d58191882d35f9af4124e200ef618b2d6919a9169614dfacdf06129913489a22b3e7b01c6f51ad6adbf1df60b4a251539f953492a117fc94668880f1cc8ed69bca2407f4fc99b8aeb2894eba624086731f7661557abf99ab2aea8d3f4b07861a642d82c5106fb92e3f26a4fc183849f0002037827ae6ad7efa16dd4ec0773cdd33880c1c46561b6144ac11b7b79b9962f1b544f363aef83dc3186375874d5fa4603f4a58f2cd3348009436faa9d2b7e629210dc33311d7d3b64a3d839c032628db06dcbd2e04949811a56ce22156597d7dbb598c16dfdadcf051e8b36c681fcc071b4d47f94e34ea1b26b9bb330308fc03c144508641899c47c26de15c8595523739d27b66d675ca776b12d846a1f872cc28ddf3baaaa7c87206312eb6bc9b295a2b5ac00e8efea24073a92a698421133078c68f0b9412ac930b0b32fab5f93bf657848082f2d2560ef169df825cc00a2713eec07994039965950c6b786d4554f40cafd93d9bec60eb0158abc081e2d081d1e5af7ddd770cd7dacdb728c0272aa13e919a82e57988f233fe403d983ece7188d2bec1bcb98e161b4e8812e5cac38f6a468548db563e86b7aaaea89e7aafb5b0650b0d64de7f30a4fd539d9b4387ce4c6a00fcd7ad5f8f53ca374844b4f5c0cdccaaac44c8111c832508315ccf0b98982ab02f411dd774a9cc7f7fe64cb39ec140e090f854502c2be05b37b6d49c25d2855d577eb0ef5bb845ffc60d26d1ecbb426bd784e3092d724623e7bf4fe27fcb7c7a3d0f2a1fad690bc2f93aebcc98a8c0a5f6877213d00380056c0eb595e9c7c5943161f9024f3e9f41c249bc6ef7d9947069b53bdb7b6a2265d8a055193e2e3ca8a65059c329c1b288eee65d5237213cedd2771402991b7ccd63cbab757dc5e66b236e2cfe91a4aed5e5c090b78f67e06437c9dabc77c2038ec9bf41ae83b300636cb04333b984554686082253bf697a5b4e946f9ba107c314314eb29ee3323dbd12a88e281a22ec213b10e69556a5d28c2dac67f4931efad0292c31e6337d73ee6b8b08e4c85a061543f23f39c8233654b072e590c9fca195da5d240ba52598195da28cabae73906ce8c27c26fbac8bac694cb22ddd0d007f33e6ba4d5e100d12b001713021e5656976c4d0e9430c2d1650ed90d475d7a528300837adca1742b21f92415afccab8f3261118c698875b18f956e7cd3df40f5027b50493b274947c67ebb63d411241d5922619dec1751067df439d5b049fcd58bd5bfd96703a3e261a7f5dda1189d98164038da0f1bda4da6ea632ef76a036bcbcf4584102963875ddd773a04479d6faa9b74115f696572e3238303dd51011e57156c78d4a3b6e53c237fcdeb3fa92c638c1cc696b9ccda292b507562c19406d858cdbbc86dc50bca651073b782451a0172e055c33d52097deca73ab28db0bf5a087fa1f4abdc113c4b41f41aa7e1f62d6c18aa3e5340d2c5c275d2a6bd79db09062e7813d7af00be4d870cd127dee691772158c3e57051662fff73f150e135328aa93d9b6b9293a55b778aabeb8e354463dd16c4a97ea5c5f0113373c0bddfbe38d86313adce52c4ef591e94db4110ac0bc4922079f710d36597a8519393810420e61bd6ef36037038c61b7c86320cb158e809e20818289777e284fb986dc56eaab984f2999e593507e2af6da67e912fd731415363b4353fda938c4fda3c34760c5a9ce17deef854d64a1e2e46ee595fdd5201efb52debacab079af6b0bae1754efc1be47c4d2349463ba7a1b4aa2a0a82415fe47f952315da2bfa7c400a2034e775d08f1a243bfd086e181bafae23bc7a4e9ff877c36765f8e1a17dba6e542442e1f79ed879355476797cd84714210dc0b4b336627452b7286fd65b73cf51038923861f4c89f52666a6d5d6b51ad4bfc25bc4d8812bfe50c8c116409597de046bd42c2ce0f1344a37a4d1b3c739bd5173e5fc5a0565f306f274f249babbf38c4392667873a2cfee5e33a36990c73ce974e45261232f75ab2659d3a11ab9332c025a81c985b482110d22a2461f5fd4a8cd5ef4cec5c7aa975f697e39ca2f176ff244f3eba23a56a8a88d2b3618feb1332bb91778fdcd1841bf6f00f5d76dbca531eea80ad700cd001fe842f8f219f3e9dc64ce79a30e17d4a5e19692744f558d40be217699ce90bd29f4699c497b9277266eaf9ad37953b578a37502330638ceaa50bb58090a8b8474f8a84113663e5cbfa7f3492da639ef71505b63409c5c5c7ff11f91834c7603a3064fb6940925f6ee1489c202f668d13d5423f25ea299bbb3a924e1f7c126d39c9c8c850b6710250e9434850cd4044aa65db959101295225e4fd8a45f981926d19e286d150beaa5b5dfb980a21bde3a54740cbff8b48384e74e24910a3ce6decbaffd8dfa3dbebcd5d90562f5632d9c62e719292cfc10710af2f9d7c6ee03329a6a0c55104d20b8beeecdd5a4e1d1776cf101a1c312949b4aae3030cc97e71e94a17ba47c806c59f8532006f9465eff96be13a2143f1e9f2cf097c965a2a45403dc18a4e09aed0bc983cc1c3ec356d46e0e6ec4de4890a31f85a6b4b5b17ce23b446461f7a16df14f35c9ff60b41ad5bb38ab230695913dcdcc21ee8e288e3f25d05a8b196974cd99a4a34d4a4c811eb2102a9fdb021d4e56e640d71fe06edbce61806dc93bd0a9fe66081e75eefc00e9df98913b126e921abb9826a1627554670542a8c01665e0c0ef6bb4ecb7b4023cedfb5381304527f2ade4cc689740b882787493d1d169db9227e2729805d72637e05eb5635405572b916c2ea6d9e3a0a4a0b45ef5ec8d30412d13d3bc0637a81adb3cb0f751e5fd671531ba7f30df95944849853b40a99071e33bde4a180954dffb891d98a51d96691737714867a7f49242f37f780555c453144c8c6771ca8a8bc095471e7b9fef62a7c8d711aa5be279e46d5196f5a396ece8154549ba7c86c7cf58fee02787f3663747e5d10614ded9c8e321eb36f4099a4d938a446e5aa2853552ac4432b3ce9fd1c35406d291137c84ceb0d32659d5f03043abce349bc51afeb78e08f5f625701ec0f50dcd19c52a9451c905e0a26be2156111222d05b58f2cc781043d8b1f9a83aacdcc13ecd161a3f31d86ab22902c3d58d48a599abfe8c99379dacaf1a094050df031084bf0ebf8c50dcb3cca680ef76d42be68681cf03f0f37040aabc293f902255413d264140f349b63223287fecde60f750548d899e6b0b1cc26c0b34e3c4cb3a45e8458c3f8effbefdd22ae466fc338754f90eff8e8e1d283282ab6b8121f71f644d2e238d734c1056d7c5254bdc23fa5314c4ac94703209ecb904bb53538d50279c281a35d9c5d597590ece036b53a60db84607a76a9a695041438977b8aa7d1ea5f418caf50552cd760e9048ea9dcee6aa32770bac83d5ea4fa377269bb15f29155e54b92dac77087c78af4df057c58ee9a8439fecd01603b90c1f2b733d617fbfb6da2ea5b0f6bf98fe515231d80172e48104d7b983e0d786c792397a8c4ed494e282750d366f3bf54c899ecf57a8885c6356136b7c2f14723a5a5388061db6ab4c7d5436acd32aa7ed15f7964ff80914928f8e956018a5b79c59778f08d6d478386d7543b4d0e18910726394e847bb187d052370557b334708382993ebdeb62ef897f4d63c5e261e9c635b51bca8a176ffa94c85aecc15e817c24a85e936f9626e476853cde11547b1113138b7171e2efc6edfc5c6ac85580922cc09a947251477ab6aade71a64de86bc29f3d22479d15565f14ee13cededca7da536d7aed36b5e713eda8c1ee6a8a23885e051d4b52343277cccf428fdbc7c2725c99412d564a7ef67bd21f84352fe8fcdc535634f7d8346948ef863c933458406f32e8dcf0a3f634820082cc95bd3fb5447f714dbe8b54ea5e198783d1d22c0ec307177b0cf7bb05c90c577f5766ba2b79fc5b5091f864022b98769ba7ce2786cad7660de9965dbd82b2ec55eabeda47c1d8efbe3389e099760ab8fbebbfff40a24579cfdc2ac413c8c2b5b92971086299ad6a7d0f22e3ec85dcb76d1f0cf6381502f0c7b3787a023e3ac93d8fe35c4b5cc8d803e50fa453ce091ccef69d0c9dbe4b2cfe1cb7e5c9521cb4e99434bfce16de7df7932317a4236dc19b2e24231fede4aff3d9bc459c6899da9bf9c81a3d9b4eaf572f1a5a9ca97bb21a399cb02f423f72a44f78f351e7a445eca71cdf1c9953e61563b0e76666afe6d58fc43e6674da10f4d5a58deda048e89da49d30259fd8a20ae67158f80bc652ad8f62557be1d0aea40806514da7efb339b47263394846be47aeb999d510d2284e8e2c1c53c233e8f8f3b0d355dc4eabd2391a06dc05d60111777c8572be9d8a3d0b1896fe5c53b46e8c250be6df7a79d7f2b8a784053ba6478da1c1005d159126da9839834a412c61f55bb2ef1c4cd8793bac46d90700f21e4faf15f94e0e4e310dc378c307c7ec4297454ec638a3ea94f09d9d1cbfff4ac37b7e14743bcb7aece11bd4282f77c1a16875f74bba23af745d57e4c46cb730a64feb4b5ed7850567c35e53594511988c80ac093306e2bf0028dd4797a75202e3cf53c0b0afa1e8683a6352e57b600ae00ab95f7898cd695cdc109605cefadd68146f9071ceeca1ecd6785212e70cf30e40c6f701b1bc89718be7e62bc77862d289204f3b927eb0b172b50a3d393770e98fac0bfcc5352bceff9d6ce85e35097e97db6e5f85bde2abefc3ef8a28513608247463debdd7e8f6aa6cfe96ccab05580cd07e712fec8d63995c4e795f5448676f39325981ef88ddccba33e12b247c6b708ba6ba9a617dbb7d2a039b3b489d4a23f0e64479480608d12118b10afec46476ac3857307bef0a4891613ce814f6578205d7afe08cfdb37e5d59933642a8dd8f04f970c587fd236b80327e2dca4b194020abafe4323155bca874e5d1548d5606c6aa9842572b42c96c5a57117e900628588700a07329f61dfc287ebc29e0c456f4047bc574727115b88384e0ecc12ffab1bb0d99d0fe5e347fa46bb5a97bbe28d5c11a8c7ea81f950f89527f2109ba5f83d0e010fdee20ee9afc0ad3b7e4f59c1252956ed633e82429f2b1a546b9267e30b9f2151ac33c97c64fadfb37d92d4c8221df43fc3f1fabb0480abaa10dbc543db853d38459cece1c903b004646b3b7af3bd226c31d9cda3248fea4a111ff4633ddcbe9574bd623092b61e05a18351f6e86323c0e9ed524d3a6a61982457ef37cfec08731d048a935aa502d9247f6f72bf25247d7f3dc041b50ebf35b984a182a91a4fb0659490986f8903aee3ecd60f4d36d2bbca26adca2262e50a371d9fe811567aaf1e478d93af336aaec247e0ff9f004150d4b57cf2248ba2cae5d6dc2bc8be3568435347f982e247cc0bcf21d1313e95e2db4b5fc9fe1d5529f85826494aefac170eb05eea4b202630dbc19f802467dabb75b7e43ab23c4c16d5e428fe2688f87f7ea80e05ef0099a84bc6cdc5dd0ee0e05405f01e1600502bd54a44e0aec3a7103ac25b12abcf90afac8dafc33b2897603b234ef8a7f55b26dd03272696462c936bb80d46c149ec20d615ea87fad95f67945562f001ecf77c12a05f7a7a025c74992b91a945fa98a94306244f316da61d7a4869262a0b17535e7c8210744f1c3a2969d2cf8282df1b1394603d84e655afcbb2510b30b889e488adfb152b2bcb33e688faa5b07fd09d1bdb91b28ec447e2334d02ad4e59bd19bf1490867d887a6bbe31d04756ced808862da6672a84e02608f83d1e5aa67cdfb350997a6b63b8de76bcbe9e0fbf3beea4b2944695b9a2cafcce5b78aa8341cdde5a753483fff1fa83e914c445ae48c77b3e037892702242108ec43e495d324781bd2b3932e3a6eb50b9b2d321f87d3f6e7b89d93ae5cb0e27a36890355b476db09be20e67f3e1f3e39acb87dce58fa4e2522624b7d37fdecb74ef34cba8ca53415f2f798dfe8d67ec2972e7675d188b6006767dbea18e7c74f8d1a5c92a970d992b8a3820d90230770800748db15a0f1bf919c9e0a4fd1977c10bca068dc965c75cdae18d26bd2f3b941ea630e527158afef605aba33a177cada675aba7371efa261d7f9412ca84b0ffa543a3e9a2498c9be4773f86fef6edb4f4cc192001b978ad85f876dccd7992512b9a9089d9d219fcc5aa72d6e0097b2e80a161d02897d33591e7d52f2f3265b09523967649f05fafee69ea3079cdbf20c554134af2ddcd3a7fee6556714d0dbea3874edf6d1e2eb3a528dea6a6f50b287b23dbffa30a7d3c961019b16db5130de1c8b3596c06926675acd18781e0219ebc297464cb91c5901ddff08abaadb22e643574f936807d235caf3bd4c59b49986578e9dc17d31930ae77fa5be6414a873e03a4babcba42a3a43758fe116dbfdcbda84deb99ba1d0d8f4757cac948a2f2633273c74dad60ba90e32a76a07a2aefeb33ab9aed8f302f119a853905b61bf82628823e15a53b26eafd893f81a70895eaca67eda015ed649af1008ccb23c2d910a148c84190356c767f6ba6883141181d5684bcc87c40c280837f7a1942286b7fdbd8d478da0b1abf3f30d2f4d793994f3dba98463e60683e36170e72f1f5e50a0d3284462d3eeabb9347a9139078445869d143f706c0cc661e4e62739ebd8203a1338223e450243bf591e0ba04bb75f0df7ae21af49bc426be687194486de31e1debe3475d901ab1eed084cc921dde5933edc6e8a58d2a30c5243b5cef377b47fa680dd3ee1fbe5008a880b93e142850e1615a60bc3ab9946915f1562e472b9e71e0bca3076815eefffb34321aa70c840aa80049127491d79bf40c871178f21e56e6f7c5d877972e716a3de3338fb254f9134b489cbabeb1d24caecbc05beb843d1aeeeee3aeaab382a8452f4df67c054fd7fb0888c58a5c17057674798928f02999d3dae8f651843f924d622b25e6a0cc958fb9ce236bef65626d0af9200e047fc257460cd52d2882052666388df2e967928b67ab0ffe1f7ee00841d59764034e3c2166fea5ce78ba322268d8e7e96f217a18f9e4bbd0366997f5a384599dffcabb9d9e05bf03aca18fa22982b1419756623f0e2f2a52a342f0f8bb37f5e675197be6a007626ab807a89394c3ad8a84e6c96ffc9331785b86e3ff319a4858f54fb3f9c231c2cdaebafb00f10388a2b07c79ce1850db0088871a699b1c8f2fa566ea4bf6e5e59db36b610153c357526b10c35770ed2942801cacc498d5b7f68507ef8b013b4713bb583bcfe3997535e91e318c347061f413f5d60c14617fedd14227ad47860df2b26fed5cc9c5957fd95d6a1827573edf9d3622106a1c6d3666d11bbb61b180d5137d5cf10f72d69d92caa182e5b797aa3575fbd1ca82d651e2d26316e253829b586b092991a41bd8098a02a2b45db191c2bf723d9ff56c0f1fff5c34c89d9bce59dfeac336c4cb7eacd7cf3c3dbec28fa0de83234d0d3dfbf4ef7e40b504de9624327530882e519a1fba6128a17f3a78e6748ad708758f215831bf112d512bd94645c51aaa52cba0beff40b5b29fc41eb838e64b16800097720eb6be9eebdfb8637965764c243cf548555be421aedc4fe3d6f90185740710ce18b8af4e543b05b54112e093da15710a69c10e99933305712c4b496e547e2901da039303f7234afccb1a5b12b0e330eb1143c961771df31a890c67ded386d776991b8cee77ef6614869f3b3ac4f403a4b4ede172dcc5ddca146f220ddccfa22a766df97b04583c7906edc6e268e72801fed9d95a01e39daa5411f2ef313054f88faef475fe2410128f8d784dc95fe9e8918a9a92fd78219d561302828942b115dcf01d194d4","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"866d10a5c8fa1421f11baa3a03887662"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
