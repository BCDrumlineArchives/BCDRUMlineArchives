<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>BC-Drumline-Archives</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #2873ff;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #2873ff;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #000000;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">BC-Drumline-Archives</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"e72df5efa3d63796612444ae623d323586f94fba2a2ae2da80dcca20e23f14b21f45195d67ce84ff68afac36cac7b2473aa3e5fd187c729d5ccdf5a1350c2b43e659157058fa8f4630a2b7497887cf0ad801833fb004406e08f27e2fa99a8c00099a27f606436fe8c53aed2d649b9d935e64f8e16ed1f3b5be9517bf0af1af7952545e1a63136dda774df3d6f64b9d8b0f80150ba722b07b84aad365511e4264f4b42bd4e55316c8ac6e22114294212b4f96bf8023f12207d93a05cce599e7fe89c6f2edbe0a3bf1af716742fcf5d23ebf10beabe9bcb92a4418b7d55524e52ae717ff80fbf00938d354cdb34c1b5bfd3d78e111210d8d41c7b8290f1e36b29f5d0739bcf2fb96b726f503e2ec8bd5cc83e184965c18da9e9fd2571c891d294b37cf76bf97f6080c00e8a8176ad9da2ce9945ee41afd2cb7d41623483d5351eed7b75232a7fbc410e0c7a659e144387ce8348356ad64c10fc0aee211725437abf439bd2d0bf7175c93268bbebdc4d17349973111e2941850a7f60ea7e10e77f5cb96a6b9a156bbb6f08416831c2e5a6818e732aaf8486c282316e8300b0b1c6366cd2ff566fccc916f54ac578c2696c5036e3753f9c4c638b5d7e53a7d9a951a35b350dc606291a7a3176319914db78270b5c9e587bd24ab1aeef4f2fe8a33d94e4739bf20b5a98566c98215e1a1e94be46924b2112cec98d6417e9b449a4756ca78f3c8d3bcaaf8550eb9fd95b047daf6ad6f0a6f4669a13e9adc5d6ff4dbfe673a8d9c1f30c79c4e0675d7c06d9621461f44b049669e9f8eb937d9e8f7673e10200e0860aca696beee8c2ee2b76de335120cfed187c9be888498edf9ca53aeb466131a52460be0f55d5cb30435983cc22b97003c4c6f52766dd9c6cf1595e31c17357ef9d4d5fc817989d91954165348e23169566f9b48990f609044d5e545eaf8d28bb33b4b78c5ef42ca577182a41a3584fcdddf54e7e018fd20d8af87dec9ba6ccf3f4f0246943857f0da109c7141d2509863ffe61bd19ff6be02e07f99c762c0a86b296e849534c084e49bb7e236f546a8783e63634ffebcd38f83823265a846ab86e308ce912dc17debc995ef4b21454f36de09d90f9fd3ac4a8791baa8639a2bbe11336319f6236e8037fcd78f20fc02ce975b31e66979d9da3cbecba74849d51e453772df212535873d24ed4349352b01847a295fe53b2486a24c21f0747f200e57a0923963e4409b4aee42966d17eb4875df7eb56cbfe2abf97647bb0bf20af15d7379a86aac906c2e95ccd5b1b76204387bae39a32bfe890d1097baff4769bb51beb4ca01c8ad7d0b207bdba3fc4b03677644b4861b13124c72e4a51e75bc8347e4116812b5a6132cdd7ec5ae8523d1c5bcb6d4c893447050e5c3bce03e2535408a5503232542d0f108bf312d7cd85d876758044b8e04f828248a2c1a666e178da3d10aea9640330086aa0ad58e00596d066beb2da9cd65525ac30543c3b1525bc4afd25df3dc8e7d08b67bf1bab6d0a8a4c95de847ec907d2f430227f6e5c5da92b2daef003013e69b8bdad2da7726b01eb99eab2beaa0f0d53094eda30d301afe523bb5021f082e9487a60d8bdcf1ef9f7fb595a4888b55f56b4dc3bb6cde440ac1c85e080876e6ac391c89d91934fc5aeeedc5a0e8c896020effbdec837d5e3c586336ac641022345a7810c2396129874dd78a9956830e3da33f4f6830c97045f5f3856fb354fd67a29b0966503a9944219cccc9a7835f60004b5259d0627900d0556fef06cdd5c6a31f3606171f57d8abaf921d613d691e76d21dd1818372bf4eef94af9b5a8f078643780d298ac6a7aed427290570dfa50aedea598022110e08f2c7210b1f3f734e4c63889eec2587c822737da86a6304c09a9efd3abb1154b07576f8d67340b7a8823c60fb5bec287bfff158f1f445943580ad570ad7eefd825beb84317a2b9d70772cbcd72b2cd75f8c78f7d248e064be7e680004cd3450f4a11c8bb7e01f7b38bd8a37dbc27326bc01a70f02ff0c8d8102ea0721eeb249f8c1e70261b77777fc9cbcb6aa4860dceb0d046c9b3e2d2bdacf264189615240139c16026e9a3af57225e4739b875ca51458b1e33be72f33e2925f52c595eed85aa427d964214f541004659fa22a3e9f7fdce943bf470f9b1e13155905a711bd5b651d2033eb5ad100b0d9f5d9d7be0271a4e32ca16c73ac7c17d7f5442319db40ecd128497b320fceea326ca157fa331e6e9805af267f8cd9e12ff21f8a6ba434a82daec0307782ab0d6a12839e0f9f41ffc9c7480a2fe1416cfe0d31768abd9dd4521b38c060c3eac0ac3d328d6e144f13025df64c1a9d640e5e0422015aac7a45321d7a3d4d2260bc08840acf451f2ed0416d7805e6dbcce9d66264f5a5e12c94336ebfa76cda9e85861334977a6b466f965ecb514000bdf5b170eb80deece3da49869ba8c4776af8cb81a1fd0aac50c674193bc7036e5ae43f432260d8a2134eee3be170d6ba8751e32929e8aa4b8e579cf1978b727b125120d022838ac95e9b154454e353193765be2915ccb53d3275047f9acdacc52e5a25e012ba149a353e903921686f4feed261f4124373fcbe3983c46f1a8e18307747cb3af7ba946af2cb27a0f114b98d7ba8ab6fc6323d966648bc87cc183c186eaab656755286dfd033585d3aff7b21464ac68a1554deadb76b1915f3106feb968833226a2a14d448303170d000f6a8068fb9ddc8e1c842c9ae1d2298e19e46d60414d32c920385fc6dcb20ca5833b25e9672ba081c5d0ae813de65a234a1d065a80269fcdb577061d3a2ebb889821897f108cc5335d0a320aeda7b8298630341e695690af11ed1b0058d499d461d66e2dc754c00c682ab49a425dca4d84295e6d2d495de15587bf7fb8adc882bc9082f66e676c219b552567d64fde33038241c24e7774419e019deee37c2431515502cf9a5d4845dec58463745373d6c209fced6996a9532eb823f81cbeaecb6658f27b8accb30862901781b9143ffbcd9cb99a5b87de1b06f06c3b9ecad3d72d66f83dc626b5a8b1f91d56857ddaa34ac47372bfe4687375a79f1671d9685a55fbe5e3242e7b5ab35a95dd83bba886b7487fe6e0750e921aa6df41d933b6538755b66a3dcaa278d6e23616c2f4fe9d6163fd5011355ac7b0119834c30d102d1d192bd04283a5ccb70639206f5c79ffa53f2389abe4572d68c36934fd0fb1bff780c3f11483f431253f1f2c06486fce7718c45730e987a2075d2a5fd1862e64578d01649071685b678e04d1f307b4114b8107555edd957ded0eccbae7ae02751b29f664ac64e41dd45fc8a6b67da3a5d3e0558b340a782b4ff4d80e805f5315f3654fb952241b677b4be237c11f304f267aa8c4edd4fa00be492b397e9491ed6c6e40722069982ffae1e0f84c3c07004279b45780e8ffc273741d8d1ab3593d48388de6aaa0216203692d81a68115ad401a1d9249b8edcc1a0f611bf3a218625042135405cbd1e57558bbb6282ac0d68863dd8f5fbb0e88982adf05a6f6ca395b0f2e240bf159fd6e88ebd567fe1339d5b77e57868e5f43904fca13bccaedeaa0f271be22fd3ac99e555418cbe0125e38a45c7441364a51c61ca54b05a36d3d82acc4d84af60bc9641b61e4c35ece00f92345a6927428d9b664f006bc98c11ebfe8c2bed74c948bde2ed76d98f998a07cb71cfc32f3f4be1571956ac2a1aa9fa6cd53155384156410112aff5c75c78ee245ad0bc403eb616f24ddc6a1fe005cd75fa642bbbf6800957d828e61bf1e6f2d11393425f101a39d0ceee7021b25ad62f8a566e9a7b8009943ae5b573baf6bf507376291537d109cfc121a14a6796cdd1deeeba5ac3141bd4e72b249a7ce03d515f5c75b4fff87aee7373ef51e6a9dbe1c6f414852e94325f98cb94cb2b7b432081cea8579560d8807e93d9612decfdc3b4fd425099ea1fba6d1398151c228f92c3ab31dee6a173d843923741747c66b59870589f6fb0b93f0b0afa976ec3e6534596232981489e467e7a184e51257522b8b154de90130ec23e417dafc0cca238024c3034c8d26aa9de2c34aa1c605746b12bce146b1b6106494cdf278a8516c166328cef259b2a6202ee4f0d6b41f06d4912847269857b7c4eb08e1d4f4d9b9938d017bffab0520d2886381f68478400d113283496b0392bdee6d61a9fea06ae4c1ae13d170a8c1f3502c7051ae77a10f42dcf85a4f9a5197e5e9826bfe83af61bfcb6f5b0c433fa08dcf87561e93eb34037a041e548ffa2e99d22b86186a513b9ea6e6140f93effd37e619716f854ad69c9039a6ba75e9b51e659daef494293f1732d7c539dda2fbb76770066f1d7936427893f90ba74b74ecdff37564e204a03e29f256505360e361af9a75d45cea1fb6ce0d53a47c13bd924ecd50cb5a6baab6452f056f308905633281d208b2ad08b58acba7290573cb21972e49015beb34a8472dcd25a1b0be61b98d199969aabd5eb64443e4f99d1ddd401ad0d05ce6685ae3cc8df4ea20a58423a94798b2e5fc5104932703896a85f68403c6374ed00de498b222b87e6071339bcddff144da7b40c962b8124611bd6cba6286c48f113b34d4598654de77bd657e661aeb60d95bc9e9ff9af6391ae8c06e315aa96f540ad23dbfaf020591c93f8a128382db59895b46427e1ef33f33651cd5e8883cbd3c3dd0b7084d3ea92d10dd09c1489f2cac872491ab021ade31fcbe8b2c2a3e4cec6926ae08f627ee733610be2fe22eed64f6ca5125646a3c1a4c83221c5b4bcc4533990439018b9ca09fc72e016a3858dd39d0a0db5a46e0736020415ab178220a525ad6ea85f30ee1e0a87c59595e6cdec3117507fef91ae6866868736aa41be95c08b3d96806b11da61befc2d9c4bca56311d2a1c55832993ba9d223c05f939cd1122bb771998fd32bccb4098cd13ac25806cb2cf36e74440b4fbe838951751ce4811b477e5c0c3bf26c217708aae95907f0f3ca915755cfd2d76b2cc44b33c47c63c732ba9e5c9aedd1e439d6b97a17ff4e1ec22922c33b544932b278af5a6fad327599851edd6ebc1cfb9128bdc023f946ff956f54a4b97f0ca25dae43dafc196111e4e0307b74394b73b9e629e197d6611dd84158246d89236c3347be194863ad146dff2d82d32137de93372d6b125de1256826f3d59bcb96cfd718916cfabd5622657f0e505e530b1091f640c217836ddf2d5d4335f800dcded696ce6f0dd921c6eabf6e27067ba070ab445c8d8ab289578166970fe400dce4a61ab55de924908afde65f5b8478d1d98ef4a3171755f948181de31caffba08a0a359737e43275eef4c544165a2763a56acfb1e883e0b50afc16b224fe918d34612a2a41079323fc21e9b00dbd958b6e0e74e939de633f72c435226fee40bf99ffffb1ad7e6e923ea293fd2190090a6432abf4662a44594c753ed54873f360a803c855448f973a6eb32a1446311c7ff6095e75f0ac5b57040204d4f4ba318277861c426b8ed7ebb275b51a519fdfae08ec111a7e9220aef3db67b3108718dd8491ed278e2155e2e95158942b15201ae552d485d5869d0727831230f9b586b49482dcccdbbab4f71b58e70e4a58b0f827004f6f4c0d23cd93da9b28c01467d28b52c958d0f386fdcf73ba45a49580f19c4f10c48e72e8732f13394f57a4a3b9f8ce1fb1f4e6aa665af52d6afcbfb6a8d9c4cd9467d5aa390e1829e1eb688bea0640bd9452147dad451890970f56c075372553d20ffad3cd44b837c654e1c026967d58af9f0b2f6c7c5d1696e88c5b9a8ccc07e20fc8a4d2664bc508c7ab1dd342c0d4ed9751b4f78a1dafcfb9bd767fee947277d16583a7712e4c908ec95da6a85a79d0ab57c9da41b76706dc997b1cdabd585bdb06ac829332f4e566cac6ce0a23211e37ff9f35eb77461779033814f03fa834415dbcd85f263ceb400d881d7978b4f3248d58d9900bedc723eb32ceb23e7d4826fa3d516f37efac320feba7f6fa1a1155bc0269751f617cd8ffe56b2c434ab52304560190c654ab1137244f7144d13be064090a44ab94eba25c47b182f42756cca7daa167846307df28dc42d942e607d1631a40aa60e013638837df33003b1f4fb1864f69daee5bbfdc2865479450caad267b6720aca6d925faa8d4837679a8edbc2cd2e3965f4d63e57441889a27bbbd4a73f80ad89e2b791ecd02e97ade1a3caeb72744ddd453af4346bf54914b9230ce4b75dcc85ce99c3a060a1f8b6fd72064007824fad4e4dfa78c89313316f4b5fc87d4f1646489c772b60cb63252514893c6e47d9a6b1cd5c17f31b280be4cbc9985d157b9191fc817837447db6bb7f42a3277d5300860ef2df302ccec63dee50c9ef1d75937a85466723151e31b1e495bd12e9d905a4c6ea2296d2ac311bbc827d32ee2abfdb3bd68aab713457f93f0033e1c446055e272563f1d9355bcc5ce8725e33cf84c7c6145a5f2825972fed1b0096070cf5bd2d1fbb1c57456efdba30556afde74219581f819f9f3a11d30dfcc8f036497b2ed32062dead3df9cb032a9d12a0a00b89ad5f016021236c9b7d66ca576baef610d591f1572a267423eebe2dba969bdd03dd44dd46a8957ee43765b6947dad20e4e2dde39099c03d2429b64c943f7189f67f977be3f4c03209468ac051073c20322c1abafcbc5c8a1a1f1cf9dea5b3a307efb0825604eeddd9441d890f7a69db9dec1c2add4b85c4a45d0afe817e2dcbf9618b472bb36b526a8ef242dc6045f6aaf3c34a9c42214663b89604be9b7045e979c407759f1c3eaa707c0d6af2596de8531e4b9b3c02eb31f82ded033ca9298a786bb8d62e5559f81ae5ca452d0b7223ea78a84b817a9ad805f802d422db985bc2731dd0659c8c4459d7b4358eb5b09e04ea174880a600d4c8b5555ef169b12795390bfd7185a56239ea793afe7c297ee1bcd4f7ebf222b9d946435f91b916829ddf2126d8473bc9d8b21419a8c386c2c3775587abbdd5d18eb837c347dacb39cb17f053d3bc518c13431f2eab94f839ba4fcd62e068c2642cd25951422a050f149e618f2b1e4494ab73e7a8725bd1d95fb69accbe3a51b95356355eb8b05c485d998db9e8c05df6e40ee5c7aec02208a177f7029339d43051794332af2aaf65ec10419614df3189182845d6dca27287adef309a18934e12608d11f51486b762438d94326c5ad20de5c6d3b607c73073428e299186cdaa2a2a22e42edcd25e03f2b00fe5c9d6a2235e8b91901a6a491deed0088f939205f1213ceca5d5d3b1355a9ce7b462c18d835852af18134c7b6679e96e2671887926a67654828e7897f9cb1ec625ecad743ce8bfdfd7cd7d524c6d373de3287bc211c88bccb290f0a9850aec53aff76f29fb1342825e6617f63468277d86b05baa1752f8721aabb2a0e5258d0fd4c8efeb2464f2aa07fd7d737f651639d0c2b5dea652f70052182b3c0efbf82b4b83742f26ff91042989382393a4d089f30b9b1f0cd72b7b2eaeda202bd99b3f67c62c84659a43360e09ed6eb62004b8f93082dc9b09d90b09e647e0f5f43059cbef3fe58e3b8eed4fcd3c59e205d74c3cc76c1326149425a128af10d81db4ffc805ce6ac08bb85f6ea0b19ad395725b2b05e29a74e4c915c88d6a2ac67d64d60c92fbcf518422c6d4180fc3fc2c52d8247c116aaaa18488e83cc03b4edccd8b4a43845e7890e3523644d00586efcd0752d86887d36e15486bec8980a6f84b551f1a7adda43d89435680a182770281dcae5a1f49aebc88b8dc610d146ba1633abe3e862ebb83cfda659461ac0f29d28bf9c374d5a4f2c08b2660577f5387d7c7d9ee8b3e297e6867ec36db0787f355d60e3e27c03a93866502e05d4ddc7f9d05ab0e54c6f7be7cfd9e83e83e61fb5b06025d45c322a57ba6d18f2ba9a9ba0c09fd2fc801dd7c5e923c6cdd8a2a3be3963fb7059e464790190924b9f825c3d5d02989acd8601e448b76015086165f4c88329237610745ebfb8d2e030b774ecf554452ecbcafa2da15ebfbce7a7995f4688d40e9a233019dae53940ce8c5677448469a37a83c58c747fecf4ff327745efd7f4dccab17048d91e4271ef3221e6b74ee2bbe49c39e5545efa9131c71201f6de5f2393055562eda29173fe3bd2b0e0a68c9189088e51d3c93e060a369ce9908dd627b977625798a27dc41a8a86fdcf60c360b232f0269bad02d0517ca94ab9ae0d7386b2cfecf3f02f66f58f5b8c07db7573e1135c25d9aa96944b9e26db9115914397bbbfd3b87b73710eef79e29a119c57dcdf1ffaae541e2e7f75b6d4772ed46fc9ed51adac9b2babc71018b8702f865eeb610ce081a964c8a4709a381b47b50fcbc7383b3d7c681c756d7fa649fe439aca10da766ee0a1018a179c2b9cd29c32939f31015ca496a1ef41d7b3bd8401390d417bfddf521d9b30aa5e152b50711717594f7d171fc324cddde721e649c38bf26c1edb1ecd3e654894a35579f2380dc2dd41c944ba44c1f094fc7236de4f1bb3de6998627590115b44b4153c8d4ea4aa9f066a5a8fe9b8fe9ed2b0fa460bdb4abf55bdce0634542d3109a9cf387f2c7dd857c896d701d03da7a9bfbdfa5c2b37bfb66520fad97323294208effa4136fa785071994d423d8cec600fd8e742cd520a9d3182a73451c50c34694056fe6f00fab6dfff604a02bcf60bdbd32951141f4bf811239b54307d34f0c36254c4301fe8d10c2db533d364cfd3db2c57f733dd1b2766553b328de1d653c27d808875d07add08e0f3417301767faa0c3963209f1eb7f8767ee3340cceb2a1f598fd9dba9d73d5b9deecc079814d80da8b9ae90545f1dfb887cf809a1eafcb7060fa37353f43ab5fbfb7cddb057b772b7e57a5d7e214d564edffc32f101c3441beaaaa4477021c8c56f31740e217cceb0a94d723c6c3f2057c32e768fe8cd0f501ca7755d148de81016e9bd7a7f6eefa6cbf1d3147e1c7507a2cde5659056eb083590322a9bf621d697ba5f05a25f9b4f43ed6a16aa83621e144e4e15398c9e69390bf9bbd40d0742da4534ee94c35b05b7e8b5a60d398bcf28a2a84d235fe84329e24d3798da7dab73ed20b65ac9e16f7ecb4211b825dbcf23a5d45efae876f28ffc7158556be96d13a14bdb3a8a9da954f37673e18e5687f2141293546ed07acb4375a0be62de9ec8b23ac9983e1c7333515f61d5fd354daf2b2406e0171fee627fa591e899404bd7085f02b6b46361d9adc2472c7edd7ed89d45c9e1d6e89c086b983759bfa71a63226764516e9aac3b2dfef12a8c34892f6334eb6ef68d26c0643d8e2ce534388bb161f021bc4605c2ecb335502bfb3281c6d0c42a26cf56df59a9cca8222490161cca3098756a90a33d0fad77af060a55630b8a2f2d63b09ac3d5de3a8be8290962c18dd99b0c92afe23ded86c660b75dd0457d249f1bd267ecd10e35784dc8eb085cbe64152bdb749f2eec49e4894ad5a5b767d7a72b2c41670528a0b8df84df512bc7263b1aa6188311814e2edfc259b9cda4b773e16120c87444670cb792c66367344e7e0491e1eff86e8f11580c71c0ec6e854e578aaf9d69f772760335da55bcb526a139f32cf3a763c0d2c162f765116f2ba8745111595557076562b4f4dda47f74d4adcb6b15f1150850b184064368c2b63592e5b2e45552e07674b83d6eb55ec7fd6ab898aebd56268053b423d57e24bde0432ba95fa3ab5fef3db5c8ec795cabdbaaa44a09cda0c4d762b6cd9bdfcd232be3ddee6a846ffaf884d1025ece6409f9cd054109135ae759fa5213dfc42f30ec4d86971d3907141ac6381f95591289b4993765b746737f3362fb8d1f64406720d5c70b507cebe85632ccbe200dce509ec8219bfc01566247c0e06cd4e85f81a0ecf5d077db51dc7559e549498aec04ec421874ab99a4db41c861e96fb29b9c21aad59a1792111236e5b97102a6a85a7427a3a5b06860ac6b245765f810c1c0eb24c65d8cf15cb80731bca629c1e395e57401d87729a9b36fd6a69fa5db8357c8c99d3c766530bde9d607975a19103a40fb45fabbc3d3e72e472ea8bab2e3b282b60a7ddf6c62793a4221d481bb6d7d92d5c0a5c44b4ca49ffc9f3c483de67e99acfe2195d208832b50881645dfb54172d551da665418ce3c92733f9e4aa931a41a267f6c9d6f64552a08357003d98cd8fff0b776ff32373e5b447c1ff497bc0cf93010cff9ba1afb6b806c3a326941195042d8b7c4b5163e3a7ff3812f7d993e70737bc826bcd17945dfba1a6221e05978f1767eb2cf15b0fbfec24416ea4742945ffb93eeff8088279ec835ed49e0c650978a63debe595b1eb7d237ce8c7df565e4bfb8dcb7035546107feeba86f0a9d97c05708571a72833f9949e3b4c23ff6c835e4dd45000a61eee41162e96afda1e8951934fb7e64569710a8a430d4a6f6ca09a5ecc84149fe8c407a275f916b21285ff10ec2ddf6426b6ecc1c7a5a1c48df7b8e60ec6bb749e62f1d4aa7ff345d983334f306ef69bb328f8b3f53d9ee6f8439e24755f30c0824d63b56f7184391403275d25b9ac8323327c376517ccdf6094f3611503e141b2de2ca22082bb30468de8636dcefb0aad62c1ec01de7ce414a978eaf66e6b14dfbe08246e3f2b457c4780e9273473d0a55fb5d7be6f930a839c77d252076a5e1dfa60cb12558db594ad6fa80682bf9fa804ec0820a1fe194efe53ad4b15059abede2f1313fdd46e79e62a9d99df6dee0c0803fbb5aba230f3f14b4858a96e87c17b80ef9a2024e2ffc4b4cb1530c7f726682b490e42e10c31b580114402a71b3237a203997d7652f4cb9337f30af78a589f2096f6be3bdbfa6029ccfd4ffa2f411663d17c5e287a7e8f28f9a8f82ad94699c7fdb85776ace8e6b939edcc2daa46e250d7784d781636c47f8612e94fd2b92272a0615ae74985acd49463c088434d38275be9d5af5017396bc7ed510fe800da2df11333e8e57b073a12b8ba791a3e1ffe0e22016e6aff6a3324d4863be1189c48b3f7316ff1e0e056b9ed025ef24ae1dbc040fd9d3125a15e221d954b568b90986e1b33a3e05aca75bdeb88e8105ff20cc90a136b21e6f81cb7407a8e8745b7b1b79bdcf941d8665cdb422d496e16ef2f6325f408f331858e79f6f38c626fc6427385e4d56970fb3d75e88525b23ac96cdca63455a21736b10cbf9e4bc3783532b4bd0ee320ff7a00d9c04032fcb03398581e0e17180e68cab195c59304b2a63fbd78e2523981d1fac4767a36f1577f723577a6dcaca48a7505b20cbbadb53fd0a12d000a72d28fc711c8d8a130c136c7fc7069dfd026159d903ceba9813c089e58eca6ce362276672e60c73031b983f84b446a9509f85f2bba23ea00bc0543b7c8d2bc444048a0eb9cc436e197798fa7108d047e2c0ee51ae7207f412eca1128910c7ca017e0dfd525b11ab60fb4df5f15ac8654c3f9f7f038afd2059853639104f7774809f482dce5b84d659ebb8f966a0aefa231965a82360ae1164fde0bfb05ff40ed1e942f71185f1ce39a4b17713456e01ba0992655eccdd2c15a1e684e4adf8e6bb976cbce882322138f970f3ca9de8b82b37ebc523f897c208501c1657f7fadddd632635fd765231e2164e305e0d8956a5f0a9340391bfa6e3ef6d9a317dd135c53c29ef9f518317b80d18f4c6d509f6689966b807cbec787b19299c90937a00fccef2befd95abd1a648d90fcbfc46d53c13646eb0267603df78e9e32afcd7eebe318972cf5946f48b3219ccedca92e7dd8226c49d5df77c5dcf7aa20f4748fc040855a115570463c097f8752f25f0b95db2f6fba59319695af3bbb524970cf53eb4947a48c0f88a3b2f7df91d7993faddc4f62c624a4bb0c0760285d52f57134b454d5c6e6f5ed3f7c436d3073bddc01a6efd04a03bc765fec4b6ea798144ccdec24682af835f955253cac8ec0a11f58144b128825588a4adf3a1f1283e872956f13e2010ec175e32f7dd2b455ddefe7879da191bb0c62c1129974c5af84cf2aed112d580876cd56d255e33a44515c6a4397f4a131562b627baf718975ba4275f2e687ce641623b42adda332b5061d1c5c81413a3bd0fb0488026dda3750639426b1f4514d5072a70652d06c88d048fcd30b0431c1440ec8b42581b2d3e2eaaa8c0994f451b2d45b514ba73e7d9b1664c8d8bab0633b8b6ed0963e6ceb83a4faae035c27b2386878938b6f8f34c102ed8541d13b753da4118864f34def9e85e0111074fda42e20f3225f4e1b0acbac13db10899071295513ee24e8a32b79c46b1694a03b14108e7cb179d372586837229a53636a48fec1007cbb2cb7cb5c71312a355b7ed2aa63fc513a57015cc360959a620b2ee2292901e9d879c96a569804f73d7bb98c92eb460d92e36a93e1ce33fcc8a833a921b567fad00fcde5624fc18f09239ae65b0dc9a81f62980f53133632cd34cc543a5bf3469de97f042391df6415d2dc18103a546334e0aa351c4cfeda0551aafc1a024168f942f2cafed7e644418004419b676e9f0718246b06b00d1472ff49bd926dc2a00c11dc3a0510724375042d4b638d3e2372c287c5b25233e44f51bbcc220a437ee4546ce2c0516295ca5df946757376d1339c65aefba100b41f3bc1b8d2d77c016a87e3d6bc2fc1802d4d385bbe5ffa8a08a42dfea29655d8a2d3ea62ff8e75a96fe65e71c377b250035f6baad213b41b78fac3626f3f02c32e4f32a57cfb9521f05a49cf6ba9413faff57e2975f42b4bdad18f7f3844ac9f868c00250ce8084adc0498252786b1b2a2fdb718e6b133b71e6c201980a4b91a896ced19efa70bb5aee3628ec17ebe69e739b2fec2c5a108cf5f59e4364575753dffec6ce69b40edce39f8927496f342debb7b10cd78abdcbd5af97ac95b5568b387905b490908f75de447e0cad18c8aae51a351fde049f83ba0686818da808e4f464cc522b1d95fd2d7e5b5f9d3702fefa260b96c3601acebd6e6ce91d8a70b2fee0d68d898d5aacd7707c2fd75f3d9c34022bcc2dc7a9e0ed5c9b0296435ac1d0224e26fc8238432d1b33caa48a4e5da887477daece05e208a1e41ab6fd0f3b30ae79a5d93e41be9971c4ecbb13f694712bfb7566bb8e7e3f7b739fd369c5463aa444a7d73d1461128eec5dd2c910975b5377ac0419021f97cd24019f398955c67bd027a50a7f94261a20f0342a0f098b5991e77fa0725d384905c1068d812bbf9c4194168392e039a4ef7de3f08fb507009071fe47775322c16b409c3a13b5405bb7a8ff7834f32bd8a412d1975143bf9e4400af94853960e3360f316433099d2e7f9bfa4e674e0cd8cc5c0f4f46969e78d16787e9888b5ecf97e03a9e31b26c95be1856e5e69d9f3da4f9e26a72ea67530c27d5ef04fe062576708eb9f582c56f0acffac77c75d0f720470feb6aad92b6b4c5e39ca81640a5385ab750aa4f22c932290cabd01b5c314444fef6576f8300970db0c552ddcb1899ac66bac683a425ff904f1435c77d3e094def0ffe6818fd2b37a447358b9643455dd533e311f641b560127690ba702b843e391abdf2eca0bc4af357e3295377a3e155bc7b93374f661fe490d019d8653b988169a232decb672db4b23eab272b3664a7c8d595946053e42373e2adef2516320490a3904af6a09dd1f19203a4d29e954d190b9dfd40d13430191d415163dc438eef2202f807fc418ee7a5062b7d3521176f0dd97eab6f41c83ef3b03c6ceef7acb7a0aa0a22c6ba1ca6e9ea3cc133258529f1c6a80d9c4fd03ca3c356ede1a4d2f9475c4ee41d37fbbed9a5f25f3ffac798acef2760ecce638dea8317ff1a20d85a0335187c55848214433880d0612e6755fad74b3c779e4ee042e2c7b72646237f9c1cae47be0ac99a276db0c68ed9d46cb674581d45d49db4e7c55c694bcf0bd1b7bd072298bfc4d8af7844ec051959a6778e05aafc41699c4a17914a4ae252079865e644e4f7e7be47e8d3b49c8af11fa510e4c9f4b02898a3a5942c68f63f6f898797faa25dbe217818534ab018865e2595b4b19e998bc41ec4c55080b31c65873976b5b35822198f3c172ba7bb9eb997336f3efe729d4667e00fa9f6cecafa76534f638f3903f7fb6df498837f934dc73ad38f4a4ef485bbf275cd79c1280262c6e954521724b1ec957e75d9c5c0c68ab5dd06295c38526d2039cc0457667e20528e9f2cffd2e5e206e9333e0092a4106a0d58ee7dc821b6fab63ed8deb0f905082db14c72e41ba68c064738631a397aaa8174407cf2ec9e653570ff110dcdb82caa8769432e6f3cd330c45eff53075da902db011df795e134e517758a1150eaa93fa7b09467619b9a340b85fbc684a1821e2d185e17ab6694b9af9c2b04dfd4240a4df3c6d2519b42c0ef381ba7bb6647159b726b5f2a2f7ca7543d62ee9a9ad32c0a594ad628e6399f27ef828c5398b9455ce010cfae516b97b7e8172e35e78dfc106025ff5843a6202429c9a7ef6bd8793a61bf62ae9a159acc8a3d65ab0548d99460c06a5ff4e88fbcf7a429f1a02660edd6086fdf5723cf337247ff01e0f003627c22737f7bde987b64aee408d2cedcf04233887dfe863fe483507d96b195421d429f8e1a26fe40b4338dcd6cad4af0127157dff913c716bb4996aa723271363e1890b28044c6d426c816f0a57500e733585fd723621b0ae86cc46f7d7ab6ccf674e4e93352dc72a9b3380ebe719e4ea5e698f64e16d3b86b6c63f7d51ad6aa07e9ffc4577440eb38a5af1d71e6571efa79749995a0fff2d6c058311387aceb6170562b4de482805212b6137168cc2882412926cadc03b3d6fbabb1e5c35b9331051dd593274c7cb59e9f4dc514555f4cd0b84e1a57f1b33488e47050a41066564457922e1236538c83e7d70f1fc8c9c8b8c94218805a64172cf036557b8b65aab77428e5cff739dfff430fc2d727f871f162656569a15c0317c427a2f1b2ee33b8967a865bdcf7ad8100cc1ab4146a1d3f53bc32e56d1413be45b6eb0a8bf02cf3a897f31dbe78d78f3f4c0ff4b1b6a2280738d934b7c0037403da0a5ede3e65f215811d911c66f2faacc8d0029ff0a731f373f3fa6f1f87aa3e312056951afba882b3d353a7da4c97863e960eccac6a425572b7c2ce555346134a433d398af494cab137b5c2bf095a7b1aa3c462fbebd161db6101dad2c0425ff0046e9223ec2ae12ed3bc9dce5dda5ea4d9ede04f74b0891708c80e3384bcf31630fde31e6b07bbec2dba445d35c5e681cff1135f478d96cc49bb209e213de94e2d9731183d79eb971d7619edf0c302edc1fc780720db4393a1278ed989edab44bcd87914d254ef2a28a0c399416c5ec8212f1a51f9823526b8369fa06f444c398cf030635197af10f7b87fa3a1f8e54ed8efb6ec250ea111d5cce3fca440cc6d5a82b31e91413a56402befc4b35e8e52291a8cdd569fb43705e2aeea86a1f43b701855f25b51a11a7be4eddcb0bd9c02373c5e2b2ca1cf70f7a856e58b1767331cf089552a4f5583e4009d1fa10163b6c7eed2ee75c92ae43135f8b39770e64baa87ae903ed85aeeb854c99278f17ecebc2e626107bf2e6f57b900525806c0663e1c37e3fa8c48aec13e0007b1ba8f926cfe36c97a8f3c75d07c8887957cee24c9e03ac085e6375338f9db626d05086ffab9878183d177dd8e03dd577aba9f047dcd53f29ce45f6c2e668e0f05fc8ce6b48255163b6a6b51639a703a0b280bae9b03da996ff89ae2ea6a3205da7560301136b9544db6cf352f92086f8679957fb256b12a222f4633b74a2cd0fe4b1694b1c2550a013cc984a7036179db95438db1abe05f4d2b3a455fc2ccab9a493869755b33964dcbaa79cf3c34cd31f44d2606656ecd24126e711c02d0f871e9adc3f817bc0254c7c9e1fb88d1d67b57da73039c255fc9f401b77400c6b16d3027e8ba067f480155ef74d0edbd5256dfc7fdcad7aec608a49ec6657e83cf795b74ae8a0d1570d39a98afdbb5773a86edc452709776fb2fb3b5720454c7bd10e76acbdd3f33bda902a5d8a9d9950f86a77c70e75c81a0f047ed07f224235d2353216efd42357f0a3ea5a6a5a7e5d9856ae25007e6dc8c391eaf0a08cdf3b57da945e4e28b7ef8bfee764025b68850c1375160772a0697e9b093cac80e69ca9a594686aac0ee58b573102606a5e67c421130a1ba4c848ebb1ebc699825d890e0fec6070a9daa8fce0802464700127c801377adb602a38fe79d1018b9a586f5791a267c87a6a8f5ce619df8451ca1c9b55c15c411c27f1aebf291d4669bd9868a12f50e0b327d2262a397c3255bd19e03ba18e6007d13cc266a43c6e42e3ebb6b612f28e80c82bbb095b4ecb5443aed3bb065c6100b9b747d768d9905ea0e134ddadd75f67efe39bb8b5c1d90a956b21643379d1491ae577df013504cbc75497f72acad2b343b254dfc05d2140097b31d5be236697cd443beea2ffc8ee547c355be100c64a83af8ef7b805c8873eaaa1f3af030f6a2da07b2d70e28b62ae14d7ab945fcfa628c58b5de7e70a7116bc75f3187e9356437d3a5ba29a116e808e6862570a219944393cc5a9fe58d14f2a2da0d55a8b6f30281ac7351c71335fcb1b9905e36c4b730773a7e4cb6a43a13f0b6206ee5a81a7d4c73aead864eb2a1713","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"866d10a5c8fa1421f11baa3a03887662"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
