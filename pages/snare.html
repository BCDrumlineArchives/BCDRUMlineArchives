<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>BC-Drumline-Archives</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #2873ff;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #2873ff;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #000000;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">BC-Drumline-Archives</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"3b0574726719637fad1a8e766390d42800471b84c5b7bab82ad72c9656c1829403bf6c665743a595de5ca0da4c777dcddc9bb3d6f7b28738e258319388048e73239c43bef07f696a2f497ea0934128c36b6229df08213365218980372b47f3962827e863bebf7bd20f2f6ddd41e7142bc59cd4d6d257c3dc731a029b1a1ef60cef0d1028c84bec77b721b2faf272c936fc997c86d73bf174a696c24061391b40a1df5a6caa0df66d3a91ee12252d64915048e51e2d90fde61f761a75dd2d5445089bf222d68e7b81e7a2aeb1931017f7e5256c3a466b2f83691835ef526b6f927704ac48df4656961d0b51bf65155326f5fd600a8cccae8289145f84bb3607c7d8ac503fa6c843fdcb3ac3938f044a3aed1322b58cef9d7336bda858e719399440d035a657ddfe8dd337be370be93395529d12b1e1a5e9b2bdcdf48fddd0aee5e85d6f1fdbfcc2d302b2491b30e8a7e9eef1bc3135299549bfb880125b3ae28b10b86672b9b3ea18eec2ddae17273009eef8d7b10107cf7e1d087b49939cdfebc171e3cc3b285493488a21d87cdca188e067bffd488cadecc7ad12a349a09d9929d080b98161bf3b092f91fa8cd04dc1aaff51d87937895a5118529118dd483a23f43e0906e4117ad5507633eb59d194f16fd67fc5ad2ca5f320d623d5246627d182350b58f04c14740945e2919529c45a4ec425dcb144df72e8cf1d11abb1d9db693ede7ebcb7f030e6cb8e2896ce74451a86f313e4d3bb7a81c3c0edbcf0afd788cb04bebc5663f8e6ba227130c88b0550b6f37873c6a60b61da429e2724063be5561001397846a71da48df624588e573ed52fc5297be1f666af830538738cf675fbe2a4c5963f8e179aaa3ebe756ff09b05e1763477f97030eba2999793d5fb27c74cc403f475a788e40d9573e1c47103dd4baf2b565062867909df8bb4cb0a43e3fc7c3f9bd90a3b71e6ba524182cf9703028cf2ff113e20c3657c7eee48e2af600c10195b9e5702eedd1418b67d498eb621d73ff043d3bddcb978a24c6330b73bec21ae22ccd1a3df41ed5fd1f1fc8b538be50caaa3de73b4a513c16152d20fb3df7fe6c34bc9aa429a21afa9eccc14205e8f0e14791d6e1958528fe404fdc21752621a6d3be2e0a61fca39a33dd46ec4a760e0f10fb48011a1eb211239b9d05a7721a8ba02a218e6a0003269844271522704a9e7e8f247366321565d6f67b07dec8781b3f87e9d5c532d6e1fba1fdf45d889be55f8424ba54d8ae006cd5e9309f4f16fa8afa45c1fedb70b6a0def612618fc4f3c52b273c95a82dae2b85fd775ea2493ff100aeef7c985b345992143415db8e1b9d3a780df10e6871b704206705f5788f7a5150a3682f5371abd91238a13283979dafd950c6053c42f11995b4a9720577c1d98b8dd3806f6ecd31f1c2cd2766f499cf2e4d31ab16de65152dc4a3cabebff37d2db0ecdb6340be495cef8c4d08ad71b04c734d1c24c3ebcb94c494588ed263cdeb9bee18a2c0d9af8676bfdaf3de4da1b639cd613ead9fcd88cd0b2c7c5ca0bf06562bbc25b173977390826807029cff1de121028e970289824afdd277ef2c38170eb2b5bea906d6679cc61564e995740ddd718fa6be2329437fe08f8f415272ac47008316e4c7ed2762e033d5a1e15f42fb6d013fbad4198da72a1b397b59a1dcf8153e14d832336a7295a7fb735e8fd740cc1240d24fbcb5082b0b66b405a9777271f5778ba545134dcc537f317860fceac27a38e488b6fc522af9fcb3191e0b87524f0a9317d9bf5ef81d7db06975604e962f87f0fd656293e998948abc59afc372f0305c8b1254751900c257532543b06f197e94d2d538d7e78659800736f0798a224ababf09fb22c1e5cf67c3b8dce11cce81c0b79ac790331ac16ac8bdc6270853eac39e454fa1b539c870bdb0afa9ffe093260a21a306c446d3e4fda06500e46aeba06c6777bb5b1cdd24a47120835b27ec4f431a084e5d4d5fb340ca30204eb5e24dbcbb0030d490bae6d261b039626e43c48f9db3592d890bf0454a6b71660dd362e27e4caf0521ea16ec22739f89389a9063b4fac4bbf971ee6b94ecda65bc076ed08ee9f6144396e961b198b8bd948bc25526fe7d73b55b81f7d35754bfc49149155e06bebb72127f3d8aa77d7fe4ca5a679c416f2ca9b756d246c2640c05b43bf8ccdbe2c0940be1e063c81bf4083f54b5ced288127fb5023937b4f8ae116773e385fe41417ffc61ca85e4bbb80a3699400cabe1fe0c5c1217e13f97a7861776e0e0c4f679aeb8144f75b5f2d31fc4eb84eec24ffffc4e0b4747d388694f4bcb0214d3c6bfbf392570c326557e4ed347158e1994a253b274fefcb09086e8dcee2537a08bb6d7936d7cbae663c58114f3494daead1ea96eb3eb2c3beb17a52427471e92054e7cc9d316085f95bc1e7a1b1e54ca52de967843daa03718f000eedf7f5c2e7b68111f23acee980c718967f6fa4de6aad450d0329da784c1803c40877e4a4b945dc494b4291e858fdddbf1bec9b5838f01ad957434f744d33af5994f36a163e15efd277ebde740e084cc9d6316027b63af3aa37bcd6b44ab8202639283ef113847968da4814bbb90f5bc88133c9ce0eada4843f16c8c9cb23371a83ea65ede4e3fd14114bca8d441834e0a5468d50faa35bb4ab43fdf3317e1c5949d315e6b470ee163665cc117c17218e566fa60837ad558ee2493254facf57d788c1817078d96b7065b5162b5fca0595397ad41932cfeee509f217bc8b5865209399aabd38b7de9a988be2483ec457e4579d184b34dae7fce6e7fe6f1c207adb5423c28a2e1778a2028fdd9e66dcd29ae1b8595934f0983489eb0c3116309dd466a98e4cfd408164a98f9ad9b4352887f4d2ffa3499382d61ddf30977498f81a9b368ad77091373e069134495d24f58a6dfe1cb4a26e96b4347f50868e0d6e9105f415a8a7404420f4dc25d9648fc297d101b68654da67521a1ebf3a02dd78ab2983921b8bb26c11c2364bd4746631f07cf4a05594aac727f108d569a4ce7e024e22b7a83cf45120d8d7c4e3af6b2e112c2cd17a44cd953ddd64f0425e5c157da45a0cd1f52d49346ad0003c18fc3a02c09c0f448e9445542a41e1d0e276b93af2d5c358f3ac035eb6d97dc40aa987b1e91a5ea18f9b2ef26face66f997ffbe750de1afeac062590ba3c4d17905b0ab4c0c489a5fc76c1ebb70de7268c8fcdfc3890b95b2e71a8912e5c7e7a83efe314f04a4895c498d9c8161627d7016352f3557b2917ee399ec0a07f8434d84fe6df45ac7d65b4f9ac682c2b56edae0593fdfa86d37a27d4130f9b484afae1a5dbaefd8b52d1a5503bb72fb54d73af67ee6add0a0346f919ba637e50f6525e7ba50c179198e5b463987dbbd8244116caa5ff1f2f05de2618949f789a7640b2fec4cce2b568ca754e088a1ade3fb8be9cdc977380bebb3bb1f7667e924db00341f5af3e9cbe70a5438c979e08a0ea4340fc6fd85df6ede55751f02c39a36083045f4245321105a730b7ed415486fd550ce8bf4ec6f626bef5df235162921b01155421aa77e58b75fad6a165e8e735b653e72bb8ac1cf44afeb0360f8969d1a15661f9b2b0b1b37a695a488c68b2faf16f85f7a83d5671e8eb785116162c4f930f9c42b34c1605b26470ffa0dc3c8e2dc321c04d3822177647f886618ce0ad64394867fd84af728ba62c091456a8f349cf9e24df2c654988f946e02f3a03a5aeb0eb361b9e9f7e8fca4af2d63605cd130a7f797b54bf3e56bc213fadb611b20e450c6d06186b92daeb0389d9ce63d386465f3ea8d2738c8f2fb1d00a324abfb308cb408bcf0b8876a42767e830a3d28b3c406b7822a2724b32c1b41b4aad9910937085474262e177dc1b2e3e3951a7e8a97eed9246442e867a542351e7cae22d27a80cb2ca9e8ab7e533f947360dbbfeca6febc6fee71dc2ba143c3adbfaaf80bc93ab09639bd12ca71b7a97dbfc11d1ab88f6140686437d67610a5b482d079b1d4b126ed97cb29e1f961ccf7d8ddddda5fa5cc48affa4c6217098526607522d1dd516a2cc92eae17927c8074c6f46413f1d4bb418db6e61afb6029fe6b67672abe3c35d51ad7f665d82095f4f548946587d839ae228868d6ec22788dbec1194babc6630a94f394cd3f19edf5b8ea71ed2bdc783ef3bf6614a4f3ce2afd311934300d7bbbbb252865a38f74f9c28b5e75b882093546c7ffd5e63bb2916af48983d4fbfa0b985169b5f183de2d3478917b01e6cb5d373a99c9b8e14131deb6508462cfd17cf58f40a4b129e2043586c388e61842e030d04dc69d0193ab556ec6704f84019d8fee3e27f15b1a7896a13d0a33fcd09a0feadfec1ba472e2588d975113b46536824462739909aa9180271d6f56402012d9926be4f7e09cf4bba15eec880a0d6725c6c7ae382b1a65e30050eea938ced39e67d3c2068f1e051bc358e996b1a7dd0ffe624349bdf5c7226372d3dbe59befe1eb55acf87898c0104c4bd27c0e5f5de6c978e2121a5a620f1c296220780a99ac905fd766b3c281ef6716b3937c43cf8929d562567f02d850b87f51ee3518ca34a70118d8f7dda689dbb6c2e266ddc9f0d3484dcaa8d8b573a8d607388cab41588825b86c428e5dac40a72610ad504ef7929f15f5ff483fe326fae67baa1ef20b490f96d4dd078393e3b50f7e866a783687ed92f9e1d307543d3ddf2561b22a88bb3c1abd3eb768bcac596c055713aa67bf253494d19853babbde15979c192d2da2cb9b61cbdd96bee402ada52e09b672b051c350309a3c94deb06c59d68b73ae235b4dcba564388b283ea8d50688c3ac84084e6ba2736a80aaed2e305749cda7a154aac3ee8a8f8ea0c9acff442b0b475d3231a97dcce37e44754e61fc3f6062c84fb3e94c1e2af9db79428aac32aa079d4e03f3f3478b594ba88e43295f64e13879fa43908fe66125618a829a8f94579d7ea5658334c375df85787542e32b8fc4facdb8f0d0326e3eeb6459e669a0e6ad492a2dd874acb0bf5a0f92b25e7c26f32ad8fda18419589ec211d01561ea63347b73b2fa8c5c054ff962561f82e85dd56129062116ae63dea9efd6ba95228b56aa265e61cd7c1394fc79d546eeb4bc5c2c07a646c8af82313fd92db345bf257407da2f399e8b5e8e7b2983691585f65f70c21c48e87cddf1a8a26665cf87bd6f38b1582136c79a5a8bf0087039acc74e8745d9261f9ed6fc6f2c7963d241fff769048604cd4affbfcdadce45b1429397b414d0b07c07e6df2ed302fa28636f2c0f2a06919b577620281455b3d9e7c3b14423658b4cf7f35df3f162e422034985d858424469cd52101d4ce9bccc93ca1ffd0d4b41fb8a84f9066d23c701fd168232aaec49a900c2d17c6011a44817e6c65b4cb12b364f53d8290c775befccff24b87d72466aed05ee4cb49c8c53d6e22fab1a6e321f0e5dfdee1a5c32727aa016363abe10edf32809f309c809fbc4547dbf76bff958314abbf8a6ba0471bd5648827579f43ad52398f59efb40a1303cdb0b7ebd7b51efe2dc4267ad1bafe13ba4f4833490c086fd660045681ceda67bf8c27a3e22982cf82144248321be612b6061c7334dca462cadbbcf274ad70ca4bfb7932fd2b391e5d42bd725c9798f8857e8f9f9b7829b94ae03f791bd3de3c94ffbb7c19f68914394dca4aa77c69e9af6fa299553aa0a2e529cccc4e84e88d1ed712c7d0f89820855590c2ea2b349b54c4eb7c5a8884d3a7ee3cdb245e170fb74a3a082adda7236212f49b4ddb49e2c675452946a594abdd3cae949fd893ac87a53258d54587bea6e44758e6f23a56b7bb73ba5e9c2b2d830c0eb49849fe0c76d2dcb67b61b6b193466bd9922a68ca0550a5c5eedd125d51e5d612851079850a8cfd0bcb8ed603da63e484944c79c7de142d9f3ded505ed77c4c82b0d3afc38a5aa2eb60f539087a9068a6b76a2883723d601134f6c41a15bc05d2f960a951df14caf0f0afd632616a5ebe0808a1d2cd76e8eabeceed53bf400eb5f814f307644beda49741fc261ccb9d0aa16956cb38f8f9c05f4bd5bd852cfb464e6cd11082be87b3b877cb2df3f5e5686a37e35546522e929fb1f3a224c8301876892209a30b58186a0c972253e9a6b2f9b286045f64847aae4799fa6b5304f94652c62a95fb10d64af9ced06a31ab59d142044030b70f1fcb98c30f92279fba253aa5f0ddd983a72169fdafe4547475afc9a98d789564b1bc7392515d0f6d8fe362a03c02c786f1d83d9e9aabc8ce64321db0523c37a074f7814727aa4b6311e213a7a02cf3fba1fe965808b6f66e64333a7108db587de1dc7f06fb31b0d2585a2cc9d293c9ac03b32084eb9e2b15fa1a5f12761a2ce5d258a0b45b45a51e0ffda704996a13ac688fbb26a12fe9da33bdd717ee5fac0b6ce974fb8a81d994b1ab85497f61d66407238d1a963e8f1dbf257eda502fe6c5ce208da0e692bfe535ecd7464fc133db4fe0898aa5dbecfced45e266ea56f610425efa0fffaad4ed68d5248eaea98b01b6039d35fdba85a07aafb96d60a71532ac865634ec25b39d97d6e4fc8d6e4d0d909173a7c7d1d2a821e81a327aca6323fddf27eeec8713215f422e51ed0caa52c2843bf344cb764bedc94d4b5d9772ce39fc204aaa76f45c0be506db998a281d623991194569a13051eca1d0166dd1be0be654f459d1ac2afeb6b1dca1b7094b8d8112d58d870f14b152ea04bc098b458e492ad6a83c1a1be19c7364ca66ec4b68560508fa0c3476322ac49501da854bf84884cbf5dbee1346d7d5197e386447a79d40b7468d45bf329b58b020ab7a7f3efcfa207a0467c56114043b323ea8c3ebd1e403ca63cf45a02eac4fc4c919ef275fde51e4dddddfbf0a90f3b20d6a3ca0cb2f56e66799055753431bf848bef66a24f8600673454c5fc51adcb767cd7eec6132c2deb96af3f0301aa5d128113aacc55fc52f10cff04fed31fd6ed7d9f002a08fc1422020ddea5f37e69102487e096350413df9093abb36a64a6bcf44f0aefea7ffc9ded828bcd63aa62fae7c924fd298f4a27b7db269263b66c0e5dc881415a5b6b2f4e95bd5b7db2065b5289edec9e3a1dee6779330676ae882371278d96ccc0024f0bf0f03fa0e8257dbb9fd875f262de051ed7086b6472e0c742b4bc66b23d0044aabe2e06e802ad8f8709c428093dc6ebc18bc177fb60b30f478cfdf0e1b1c30d6f65d28be6ae104448271d345ce7434e7d782f81b8fb805e656c7411f0f38688a5d32ca919b22329d1c33dba708af20ea6a370a9457c85f0c0a3a7a70f7848a808c58c7754aa1a5b5cbcbf8d523b820d9881f2b8319e563525d8e07f4a0bd9daa2847c8eec7be0d9bcb2edda9fed6fec98b29c044ea527c36958a5acfdee2a7b32118ea3ee8806e60aa9630830c3caa994ca86f0166adc4b2e4c8d494928d67dc7090f896e063d959a3c9fa6130b2c1bab3c134bf1ca959e2ac3451354a310b1c73d97a047e83f43f99835a298f4bfcba43ec07ca65223601211f7a8548af93808fe298a6cbf83c3c058be8130432c6d3dfa99f30d8a9d15c99643a3bc99670c5c3d468bdf8503d54b7410b3fa8995dfdf05ee4ff7c38b5a121abb0bcb2c844183753f2214c6a6f07daf10d090d235b239831cba218d13f7a870dd9243fc8df4e5d7188a5e3cbf4355a4a5f451ce3a232c998e4db5ca12bd2898b763f977c20c24197c4a25c643e35d4345537fc393333ee1d0d87d51d0f3db2d897a12e10ac5df5e04cfcca9cbce86833c27155b259e6fa51f55e7b76402558da73bb85ca9e2de995769e90cdcd9b9f1e482df1e99bffd68274659fba390a6e7797c9b491efa1c3c3a11174fcb364713b95e19567663634331f8414d084355ac6f153d2297f2197e3b8b71dfd31fc78f8774fb8c480b6b6014c0fd2d2784ee7032581de9955cec888f1c15373f2f9c3adccde73dc8a8f57b3c00ccaf564e884ef5f3135aa6b5a0a027d0e085deef822a6104aba1adb059146cc0282bd3224421e632a922bbe300ca85d6717049761877b659d2555660dcf5dcdb4fd0e1579924aa0b38d745727f0cf24888645ac53e6b64fdb0db3e8b7e803ff6758326e231dcd1917bb8e9aa3d70aec3e73b77e2cae8afd194f0da9d09f9f129e4c9634650bf2ecee173e131cdbc1f540a711bc020f7b7ba7e1ddbda649d7f4ad7f069d37f494495a24926d4e105ecca5378fe925f107c068aaed2ec76edfc890aa228ef851624ccc7ce8a4e6878204b309cc0a343c172ee065586c1d5c2c9721669e6417e18714454f95f3ef4a3a7e41d0869b46baf633ab60fa993908d7d42f5bf804a9b1b7a67c8e1c9e56fcc00b5cb96587c0e03f435ba5e3878347a47d35e3142dd11664facc4a8b04b18f641145197f6b93dff93af70e5223a499ee8ffcebeb5d6defe193cd97319ddd0b9f9063fe5051681abed2b23b06ae9ef059232ae2f57d54793f0c47a89681fe1fcd38695dc9786e56dc398bb6450a2d37ebeb6a7fa5d52896b30617713f2903ef5e0b2099c416e6e4c74c94f5149bcfc91b303f2ee22951074f392400325f414fca9b46696bdec9dcd29c083cec716ed939a62990b52998d10364c8a5d77be3c8fe6540f208ebce89129cbd41c311b325fb04973ee71d21d6565fda405b25fad44c810a07539c475349a1fbd2d2ed15735b0ec85a5b665c0cce94a1087fc2c8850fce9dfda257862b74a1c26909f9a02bc0095647795bc3ded4953d6a56d2517bcea97b99dabcf9dbac747511390b6c4401daa6ee2494f9d0d19b4c8f9c0e6f89cd6da39e5849e1356322cf2fa9c6d0af28f2ec5ccaade006e6caa89a24d0e73545de2ac53707bf6f12911fbedb637c8b00c78860aaccffbdb3c8953d1694645e55b91848b68a02c2d8be4b6408b372341b60f58025d9a7947d16366f37cbc312e5204564156f316ce93798fb03945ff48fbc7fd687b7c4250e44258df3a7e95935c33e4d7cafe33228e05e74729001fecffd30b6a88edb7ce554a674982ffdd00b791cc47571582838763e7bc9727ba5db384df0e5f63d49a3c0d72bde06bc1f726a0a3047e602f3cc56e1de3c5f51a1856fa996dbb47c9353ff693e59dc56611df5aeb599db1911645c333cc46c18d4e0d1deb19b8295a58338674a21807aa28cfbb5708858e3cb724b0322621c7984de40537b06a727fcb131224deb0638d23ac85423ef1c751bc09f8c5ce4b8b4c1053bd5a86ef54f76eb70dd76642a049149b602649abac9aa35903e5c7b56a9179021944a273c2d7e9b9d6b19d602c1e382b8c736f84b45a9704adfa44c743742d131c69fb5c23f67ec98169ee8415505b2686c0324476ccdb4152abb8f28a1b025af5547f4684338f3712556faa420f4e78e142aa3a3259f16355b2898f00dd5356d1ec473efe3a5197bfc28b14caaa58fd6e9aea89a7864aaaf4b375e766b5d7a1355f7581883072528e87c93b191e077b5309474125d166fd61ea0dcc80a7db49f211456ab361396bfc8dc0fb2dc8ff94267de9e0cc45fc8e3b1b6feb6c8eddcec2a73e0483336e26a419826c6d2fcab836d8ab8c693fabb0fd1e629ca1a5f1913af1c7dc64fef5a682e02a9e517325a21e2fb451b310d2edfc4a3748d50052606c153e0af13161fce5144b22153c49916f8ec856d8ae9fc1e26b01101228abdece74e96035c247edc4a81987559b644ade2f9543a382b69d7a4eda29d7225ed843ea04ebc6da554d19ee23a6f5c4e5bad04ba0ab4078cc846090c31a79cb6c50e861d1153f0b6e8ace727003580366d21eacd521fb41ba45a60f0dd1d0a04084a31a7fccbf66336347455e485904672b255074111dffec1e6cec2958887cd3cd6710d9c08a37f62ce3b028a2af9faf7fc2ffac6b59894e59635f8f63e4b427c646ad411821f0d1e4922af2d7e01f91ec9c1efccd57705bc36d6c817405f99337644049176ea5077cc690a18659f26712697960fb605f70bb49386fe54bf668d6c965e1039000d487ace30592d914683e774c85a135692d67590305acdd3c230bcf291baf8a701657dea10a2e1c8d8479484f58f35d388a16fa155194cbb9debfb95be0ac17b626596a5e500d6dd96ed3023461485431371c8befd3c9b83521471c127a65f44fffcf1550790f954b59af8e670c3abbaaa412a4e87801a668dcc0b549eecc43f8d8580fed2a8145c005a28a218c616a90eee7f0812d87ee58ebe7e42b2569d26872ce3c811bd350eba98ed5fc9418fef77c9d72a0f40985f980d640f8de6c0b326fda8a641605602631e6b291b801c0009476f86d7131ee0e5a90ef26f8b5f6e6094cac746bd41db12f8b3d77348067135a69577982e58aa123d9222efbd59eb56a5fd4ee774ebe766e35195c009dc12a7abd2e329e118c434692dc80cab83d2084dcbd3675bedd1564605415b0c40abfadf308ee4b63aac95449842d2fcef2731233aed4bdcb4a12a750aa0e8f720708224a6f56fa152d02e81f69943ee06309163b6fb1ef66c021ce60cddb2b4213568c8930f92210de20801e02d1baa85572685a49a2607fb6f5ce543862e4cd8112846d3f8d2ceda0d4c7ea57464f00c1e2d799191734bf1c0631d4174e37080245e9246f6eec0a985b39e2c31e11e73ee6e67e502cfe5b9252dc715766c3102f271f4ded3b07016b2d9564081ff7be1ec60c6bcd80ef84fe890eb0657a285113d28e9ec7b3cc5d71e858035c7114a2e6633a9400dc99e9b4b9ccaad093087c4da2afecb5085291426523487cda866c6c1211dfb9adb1e76c8e67b3882d36336d6b6db6a35e5bfbf5a33ea2529bb50110ec11ea0b749c8d4ac94e1dba4215f3bf11b8a9fffb8584e3f9143066c389743759fe5971b92ab9ce5a34fae0364cbb799eff84c4e1e8e79fdb3db146ebdd5a23921a112ac6437b69567f5b4f3ea6e99782781744d871d0f30b3d653d6ec325d09abaa3bc66c08a2707774ae90c4badac0dae5dbe7710d98b2cc00910a416228a7278be74565e4ff20aaaa0d7f51c90321090a277b9b73366f831f03ef33343f2d25d0b292184720cd567b15359d36c6bc6f0e9cd039d058bfd43578a5afd686892bb6c8aa8da087cb97afc3c5d821d72f99fd76cb4de6f179b850944008b71ede23a86b7d9278a5bea514fbe4deedefc062815f66e6dd3c1327947ce959c2579b962438acbaaa3dc493f6ddc2e026a92b53a006f99ce63ce97f033e076a9d3e881a562af7c5a93a12f4310eace2c81bc73de984d6883229c5788cad307b5eca6af84f67907c6823cb71a79fdcaa6fb740f535255da464ce118cce8ab7127a801a7087bebdefcc0aa871dc3ca769c0db482123f43d36c66a555d1be4ee36359ba19bfc260374272a00c468682e795bb4ac9df3e96600db0af3c118f2116b9f3a606dbbf4e9cf93f0f95e92425302ae458d03ce9b351e501899b7f29442216e3f5840c4f24b02e3359c063ee4a0abcd23d691d95bd3a04df23360aaa07a6ad49641b6b575d81f1a1b690e7fca30a6451090c49a05063ef5979c78a19fcdf2a8db8b7f8917a3daa3462a76b0a739da93f7c0ec3e48b59b19f3ae609f4deba06635bcab31d545d48658d81f094b2b756e1434a93b9ead160c967d3d211a5858a3dd62cc19ef4a518b558d7ab53be278513022c39bbccfa1f07e7ebc956ccf059923aa5c0ac6bcb3745a5f15b2b181cf9992627dc2e47765b1baa9a19cd2a9b0aa438b9c7f54dad3d23e1fbd76b24cf8ebf9e15d70286c0ba87bd1060011509cbe0eff672d0bdaf95e56e2c0a1c89b7397a5759036998460be056940bd00e2a64841254d2d9cdb044244b955218915423294fc858ec9bdb251a9130e8d05dce0c463440d2f7920c58f21912615f3f46dac26a2924ee76c24ca27b1ac3b89f8acb571529c5198f21d2b49cee4e8d931781894d90cf4f61d929adef84546ebad133d0682e8f4323f08e5401ba92d4cfae1a690c8fd6effb3671d0322cbb10f0aaf9061ef32d56306cd41281b3c39f5404d935113e6bba9594248899422d05ea1ac91dd338727cd4eeb0423ef9925cf512bdefcd2d8369ef4b57863d3dd59ba9aa9ca0912232c41381be480ffbb305556c2d626807fd4c68dd86f4709137d803a5fbbbd6062e8cecc6073500c69e1897cefb872fc7049598185757e49eddbd6b0ba273ef21af11cb9df1f4d712736efc9a9b18751a9591b4cbcd8a916783031deb2bc9d583adab6eb53721925e54a289aa15bca274b31b384f3b435fcb907ac4f224dd94aec77625c20f35e22bff8ce2bc9b96633abec89eaf5b31edcd9e1cd3d00a9b8878da4bb75e5977f7ea24e94ae594241c2edeaa712741d534130bf1815d41bc7abf2c3dca74984b36ca40fad721c101138502e65aa5688e0f957b60f0ced57c392781138e024f4bd98cdf262444eefc3089e4f2f63f878a58f99111c063b3e4f39c85f93dab0652697eecd28880776129aedd5b6aaa7b66e3501078b54c821c26d1bcb476e3c20c9247ce77c7cf91ed27bd61927a7f1e43bc37827269fa3d98a6b8a3f12e1b73d7f233e3fb1eab0e63ecfd95b2e1e2300b46e69b68bfee9f740fac4c6ea16390329cd22be7f016802bee0054c90975e200407c991d9d66a5236051ee5abec1340cdc813320244c0c7fb04d1cabecd2aa5f099b9a1e9bec602b8b77085d56b541c42b7c78f854f4cd6c429151d633a1d90ab506813bc8bc418248d100a73de28afd0058e2537dd550b7c9763039bdb81f965578b1561fb511b0b74b09b126a5ee5990c5de031296d0edc3ca155fb36d64b669922285cb33dba5fadc65511b5c1370b0eabf9724af4eaeaf11f06dfbe765a55a2721257377c24284493517182908b0b39137162f12647d69a0809a39ff8229255bad0882e0e2f1ae421ee4d2ca7628dd1b0b3d777b0c3678923a7085a046f108d8d0265b15bff5e88fbfe76cf32720a53e357ab116e9c631a73bce87a3a9b54fa7ac313e1ce7749dd9729397f4ee00cb4b95b4875293c7fab0b9c3b2e4a2d509a00f14cdfde0d0549e7dd8bf54cb865f46d792af8775af9a3b6cd939c496e7885bc5ed6987aae4ec6eaa4f7a9dd4ad6b1f066009c0f4a51fb2601f4739b1a4f7e2af2de55e50f36e2bf9e7128bbb44e17357522a0f1584d0470da29403885a81a00d1ac38bebc3c393f9d8d59fbefe2913a1ef9b6b572d57314641ba164dad4ad4b2be5ef4a9e6578f7aedb0de071d39f324decf462568fb8765498317f813d7f65c202d48dd37430372c03982c2e11432288e150e8e6cdbbc869c52fc09718cb782b0c32a0c6e906870920bfefbb395e5f3165a4082bf1fccfac3ece49b86e760c5489b4594b55bd1e2d23c76b7e5d36c4a317d325fee46980a243148afb73fcca01c8589baa2a33d2260ba13b45f407bdecae38213d430c6ddd23fc731a2fac99010d16f0097d1d33ca438574bb641163cef5c50a942cc902f35c4c12af110058cf8bb03e1bbf445f95efeca370b51d59800f98c28d9791b1ea5b5f5fc84e50aef51488fe4c1570b71c730335a2e129312324954e90af42ce58ffaeaea1ec12d920c2b4a96c5a2808678daded70aedbd9733ff9bea0b0563a3074f16d7ea03d9ed5cd03da971f00a7467642b73645f34b9f5753554ff09c590dcd84c2af6fde00c19895141b94fa871cb7dbe07558a2ac9bd66298d2edc1e23d9fe1e1d55f2ba351b4cce7ca616f5a01a1d02925076a600e10f1d6a3f4744b5cbd9c7909a6505a96032bea74bf045d6a56139c47de86d26fdbd1fc36be5ea230b145abda4e663173d12b34edfd9f24677f819d3735c38a5eb03aa74a148d3ac00937b899be245f4656091dce13bd85dbe62386e27a174756dcaa979fce7803e2ea989776b910c525b639a90795f3dc96bbf60ffd94a014a57b7df347f252ec7608274d39488273ad2305a72516820ed44e3b4e0c9300e6c99fa937db9377952aee217cd51519141261f395bcfe2d91b0e4c9908fde5d70a9eabaf040c23e54e8ac153dd0db12a91f6ebf2670e77e1f11f3f5ec5771a855464b9548f87ec47bfb2ef9f4a2b61adb3fc4ed3a33a858b36b5aba15ecd18f02bf5cb8d8d58aca69bbef9aa86a528a2a39fbd8743398df97ce318936680691113c3e29937d10cab7b27981e89c063db90efe06ea6ba93e4998054d8408f6e0ae0d9ed18f3986637c33a9bef8f71946e33b6a41d40d560e5ab964d312cb9872b18e3d471bd471c40c0234c3b7f0bbd82a101fd8dde8561a51b2d1a4ae4cb822df3ca40f6e39b63f8f26c1db58baed749184fa8a55a9c8bafdf5614dca9dad7956a6f7a370d8e007c0dab32a36e6bd984bcf65c5edff632ad6c7910ca63fe170727ac07569acb84999d86ba7b716d428c7877b3a811005c2fceed52b3cb945c563ff55d013a93053993a5f946103d62f52257d0dc7519bda24712df160e7ace5a94d0cfa4c7aa7e9c7f624c6799b95384f0095310359db1144277a68c22d0a828809b646ce2eadbab87b01489cfcfc02bed346c2928e5955fa42eabbc064b99a38150a05e13d87d2b663fd05b133252eaf831dc752f08156674ef33b957360c28bec7190b50c86e34fc32e5eb209aef9640b0924e71e8044fee1b4eed693388fd3057f2d2ff0aa9a55afbde2a0bb4b4002d51764f9f029fb77c9d4580a42cea7d5a6e94927e3a0c8e16579bc45ede7ddb15c4cf54d411e5646645f9ba4a09dd46187a02d71ec3f52801c8f5524335e9f5933014b9dba2d20026a5f099895137c7f8aff1378d56c03ea5e9c63465ed6ec4111e9008b59ff720e03a53bb30a9325cc1f7748eaef4b694a06ec661e8c7da03f80df2abe4b824caab79987294b71de4362afae07cffc3d7e764f2c2d5e70df264d4a338b4c185be2f6fd79409d7f97a027377b5d0c18160e358f5060c99afee74a3b25522736f263be709b61764dc843eb6db107c9fdcfba08690f8e05f7a97e32ad10f080304c9799d43ad789d67a610f383ff89a6efc267b6b3e0c37bc916a251875f6528421508847d293fc0597e345f7b90a44f351ab419c767c80805cfd4d558d75be486d510f44e0640ffca82d3402b41fb6c32d141523ded1eac5cce1d606da483eeecd97406ce1dacfcf8781bb4dd28b562bf8dd396f5335ab2f9bdaf2aace607da3f1e0a7a2a52551f88d7582fe4109172df8f57373005b6a82be91e412e2e084aeac441f158b05d0fa42a65786af08a4779cb5bf2081bce6d5b5dc7312f841f47cbbb301bc51180166cbff8c20f3bc7b3c0469e9735caa925954c323c58cb72d268fa677c6b91543f0a3953a60872f147bff7bf017087f3f3eb8d06eae67f9dc6ca6f7451d9cca3a4c4a793abc5d9e6f358f889759373ab0c51bb9c167f23f0fdd004b7e5b2fa7a939e8e70869f01a25cf8c2a2934fe1ffca325b70030c2d07434dd7a7ede7d2a9e50cb49e1520a3bd26c016b46d86988067d8e015d7f8d08e59c6d0aa44e8604d9703343fc6b32b630b9779437deb63ce99284f22a55e3410163f01cd417fdc6c45ae2ed1e180bb1eab557188c75d0a528c3458f34ce390bfb2ff8933f5cded66bb9984f81dac653595c03c65e7e0536fb008086684b26ec39b07214a539139a18e905af71838fcf91a363bcb2508837095c889877927d7f30a1c7c3b5c1ef97d744ac343a8dc2272de0706a39f4778d0cd99e9eb9eb24757ce22eac9455be7b5c505973626db1df724d65d8cbaff211dfebafd3a21e0f15d37269b713204e967d2d00973785b17491f23d519ceb0609f7fbcd1e3255fc0735e9a09f358fa9021f237cef66b533e72e02cddb03457327b106a4fe5568bd89a72e37f7d1dc31b84c4ce650fb76bd626e2a4dab150479050a2673af097e9a654c2b235120d4887797d1c4a64a2c1b2987f950421c00d252c8133b3aafa7f9b24982f22925c59cd4201a1a2eaac9c2dbf9648002de333a6ab09ffbdce2e325d853e093791ae6b933a13b79ac0ce6e8c3bbfca48a689282505163660961d5881fe930ec243054c6817a2bbd9abe2ac836f5deb4462e9c83c68fc855209d83873bd3f90a1504891c8c083008df4efcaca6be54ec4e33b56aac79e7c4fb5d992b6c23ac3fa43fb47d9581eb9ef13215dd1cf8b598618b97c0cd23f732e6cd866eb85c650a9a59362be2c4225b6b6662202edeac36bcc102bb2e64142edad7ec3a589436c331f2a4f3d376d129720657a8d44d20d3902d2b5466832938fcae243c9202a0eb80b73a36696d05471b2623eef3c9fcb9cf24130231344da3443566d043874924dd35062e15a47adae1de9ada0df4dde4fa4f82d30d4af360833121e25226603fcfd326762ef07aef42684b6ee425308195eb8bae73d8bbd77ab4544a60dccdce83fca84d6e81a6df2aa5f158d302f53ebdcdb32b53dd1d7bf530af89a716838646ba18808ba90531ed5610806fe30e858c5fb06062c1694a00833f08827ebd68656eccf678dc7d8832fd143e3f4dafd3c17ed6b6fc2dfc0e9820218ab86be9c3c2bdb3872900905cd8a80b16ebd7c4f814839034f8407cd87af168b1534d55bc49195dc5f149a454523109d30df8f02594e50bbc27188f0892661c13a8c41f4a4f5fb5d349ad9c4233a45be3184b29a3","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"866d10a5c8fa1421f11baa3a03887662"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
