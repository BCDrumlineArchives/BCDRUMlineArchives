<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>BC-Drumline-Archives</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #2873ff;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #2873ff;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #000000;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">BC-Drumline-Archives</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"ccd2b721ff8a2d1ec93bbd97f8cc09ca75257b28cb33d1cc92985cd95a72401ef16b5bc5fed1fdfe38bb1f1ccf026273b9ed88e20b56db68f32766daaaabc96e774af1f7a1f79b8cfb294b3401e51d9cdf9a2fb47ff74c8f4e717d21bd25936ffdb437a32365043b48fbae02d6e5bb676277761159ef6eaa19b32d2fd96ddc4a37c2d30cc56ebf22286fe765affcd6fdcfb04e679bb05df63a350300a3ddfba5e6c3c3db33e62a345fbb1cfbcc7c7edd1ec1578ec1f9a914729f0ee6067135614c9dd04e8181d17f5d4d1847824d38cc636ae2aa6628e3abd3e6052c108c14d6e5b9aea65bb9e2107682ed7bd6b33e06d2dc6725e0941912f611b2b182e0d495021ef3a70686bfe4005efce37c55b57c8ed941846d05939ebfe2dd4ac6a3bd738eb3ee609af774fad729c92422d0da13fdf81ee46c9f429649c821b349b95dc3d319086255267cedccdf575fa325ad4839f2be88e76468587f2a31e607872db3e3e229086d81760ad572b5195a9cb217a8c523af3f06025c4fc45a2d502e8ac4bc96671ffb843c34ce92cb79342980a9dd7918cdbb36d9b3f2b999b75bb8b92db081ecf2922d4612367839aead0d4b243f97e10e349ffdd5beb523d0631fb887b03ce26411990d02e1daba61bed70aa2f228cb103972e43e25b061ddd6a9507c1272a0ed15c4cf43444917ce18121b585f238e9fb103cf6471a5035c112b91c90b7b5b98393e5c59cb36b5c6dbe7e0dd70ef2e7650ff934150edcb437f0ec02d5faccd7e1140898c3db7359da59656f05779a4ef8f451acfd79db6a48572dd89899ff7f7eb559875fb07720e77095afbe1d7e17a3b715cf75167a7fb4b4e6af1192e9e3b5b32aba719c9edf88c72a45b69d67dbabd9ea5df09cf736a3b9e982bee87188e91cd4538c0c7d407983648f9820ab05a10a213ef6d6794f3408003e22e7ca437a4bdc5b0f32c6364af4f4eb9f5023e34220c2594dc45f1d5b60a4cad5088e549f888bdb5e90bf88a78e81bad7c27dc163db36b19e407549a89eb3876cf4a9c5dd7acc1b860415b805da70d4ea1fba23dc48dfabfa260605cf6403befbf3e64507e5c3883a784b401e00dc33280172540e7736b7336727b69c0c91ff80238194c98e1d84863916b53d092f9d1008318990bc915eeffda773597cb0a2c71637c3c51c89d455691921d5a97cce6a8afcae2b65a90b1bcdecf086c598641ceb5a24a3ec4007d400d0499574e89ba728be12acc1bc4ed55ee6a674302a4c8fe3105ae5959caf2d972f4cf63fc6ba592cc86e7fbd9c5761b29ddc303d737dffc288eb45c077512b2fff731e920e8748779db6e989c24a63e9388a57cdc9990fd3d7b31b275acc5f93544681724f7ee666a5f8d70fae3b90271c3313141a00e37ae651fb4b40f7c04400e84430b0aa6a32f9fc4603d69db92f54e7843da0b845e6b8816e183fea191cddcc03d7f28c08c1ef36a4a2f26c0f6c7fc2fd1deaccc2bdf871f49d22cce07c9e08625298820ad01bb8d5444265cf62bbf334bc3f846fa58ee561cbc9fcabd98d474c88c0125fef16811cef9cd7f115d3b411dc0adcff271ce04794d18e4dc963c09d82335a14f79e22c3a1f9b2402030a0fd46098df58422cbe9a731936c32640b5ce900f66851c060186daa84230254eb173640532faa57d0d91fef2919e919fe4feb0321090ae97343534e062b33a7dc7b47faad9524b2e50ef29bb9db3da70a8b7f8419571f9c221c235ed27a7a621462f3e0a6d1e2c88a8d3261b9eb021a2e5ae5a863ae4d8d931b6174b72d1187ce062b9104f98558b56304c511885af706b27c5bc9830d0a5a9bdbf87f8e02a5d65fe6cbec45ad0d11346e2224256d0a4836c788b787d9e577fb22f4aecaff6c8531d1048d84f336a941179dd186fcb217a0cbe745cff59ea9d182becee5132c76faef19b19d3d93b14046cd8db8ec9b89a5b14a70b051fda8b2e5d187a55f2a42b20cf960ef6c25c48c5d9c6aea56da83b97d8fd75ef0e8ee6626f0ac0a2fdcd09937210fb3bf04212fa707ee6d618f3ada03e593948b3616906b28618af20b2997756f3bdcce246b3be95b0cf696b57ea0b8735bb7471b7a0a87a0b5468635d4d3b75866d13a2a7ed221c88542b37c64d3ff22799d858ff03b90251bfea55560bb074cff30688c9d9e252bed347ce5bd589874212d711579ca550a5d9d18ff772f4b021092461fee1274fc9b2e0e29bf48a5d16d99fcaf2508919a859abee475a43578c5fdb7e45c71a543e4f91b1dd28ff25cabff6734f64a0384df953d1c44e397f9d5beee9e77277313c058b31425567027f4161776d4cb98b2c4e4efc02511f05831c32c57f116115b1dedc301fc52e42ac25596b4d756356076b0eb3b68126e6f1f519528c4c4835b02eb0749ee8f657afc616a57e8a2630faa2894df7f2c25326f6e6e84647a9d97080e6ee8c0730b66c0707505a21327cbcf1b1602f8685d46becd8caec09f5ab94ff84e4e4ecd7afe1e710e3b505d92f9e1acef02401786b3bedc8182994b9d8d34bc7fb36a9d7ee02e4ff40cb1f6601c3099337cb0c7c3f946a08f9413bd9d0a310d39001259c6d506161b2b9fb2ff92bed3c83cccf03b8fa377a63b9a0144dc27634c35541c0cc766621ec22a2fc09544ecba3482cad1af25eb10139e27205ad95ff20dbc72e682daaf93f9d7c0322a8cd027b2b0f31bd249d9863a874d62e98e3c80b199b21f1660525ea31b35ccd5f3f511d6b9884c2a595aa63455018568d2a7c2b981b024fd60f82eca5aa97578b2fd4fa3b8ae7f641c8a35ad30ef48810933eabf7883420963e98b231b194eae7f7cc6e5e68e8fce5e495c81c54f240f5ea617c6541004bf1719552e9b4ce8b10bec294c40854f52ae917eb126798c7ba31c991ce58678ea930998cd859bdb5269271a9f7550d18fcc6aa7c4951c1112eb9272967c4dcb2c2082669ff0d5de57758cbc2444200ee7061f8477deaa1d55f316d8c4bda210cf1c61f0aee86349e2550e7b34c5aaa935977025a3073c21c58a078d91ecbb4d3d9aa480969387572c013a15dd1ab28cad7a005cc82a1987c24ca23fd1b56ad4f4293ea6170a1e0de0d9be084fa9d1d23a743b837bd0f4305c20f8cf48b9aba43116843eb0ccabf61fff71164a533c566a5bde1d8966d625b613ae63e2907ff2931c42d7c113edecfd9e2687b3fea7dc4247d3c43aea6dadcde7ecac34e383dade9ec4d5951b9eb5b889f0cabadb0a0f592770234c804f1899be4572bd4d27626464a1b3c50b6376901e0ca2c0752f40755d3039cebad0d160bae598af75159bb039bb2227aa5c2f5478121a58b357465bbad331f9da45a59814e1d493934619102ec3bcf6ca80b687322e5fe0b3400f49964ca6ed5ff2e3200c0120a2e9268f7e6708c58da16636366324f88c0aa4b449acd7236c29ff4f5b5e7d83f158e8d17e6fa9abd2d29b9c761fb0f965b35f4efc06904534fbfe176c42d98a2a0f05f5ac10c4e416f147d5399010592489d83038ef91db3fde00079aec096c1041c9373dc73e5175fe3d63e9598392aee491849a5c8cfb73e06e0750790f40d350c8c0b4f973dee29d34724c1f341a5c251bb79cdcca206404269d6563c1b54e25d2e3b812021682fd0a046f49d49dcbb45230a6d1f0c5786c189618e31a53e52ad599d15efb7d66ba3f282e690359f294988c87b5fc9e5aac8282090da9c1666aa7de6c8203d73ae8697a98be6d3d6e1b15e6ac7f76bcc952ddd00035a49e6afb70e4ce27556f8358a67a5d7f2235f0dcc4ef544e149a8900fde113373902ba2f7e763601806cb11adeeef1f3e47ad70bb0888433d9f2fc51af248ee9f7afc3379f375da4b479f7b572425fb6bce10b342cd4569b768d65c53a28f3c1f2d09e99c2544e256767ae54969807b1d591cfcb40ca7a75c74f2ca989d445e098fcb281db721b89826615e4e66312219bddffe6085d593c7ed4f64dc868fb2a49640e567155a1a83f08811e27de5d54875ec54e03dfb3e0f563f049762f42457fef1aaa9283e2df504aba0afce5645b898b3683dc49e36e6b775092d69a6f42c8545c957cade7aba6b038d24d513eaab470ad3b05a384430864e267e3719b6dd324866663e71acef15f448b2e823172a7e26ce1a33d0c99acc0c9b69c5605534e09a90b1024d9a8487b0c9e1f1a583dbe5253e5a9670590d26439bac84895bbe5acf24db699c41d1877e2db33a8c78889111c065754babc7b394194003d680969dd7749434d8eda3252a558b3ad4d76b382462b6f9f44ae9851da6856d4a1c8bf8e61cf45e66bfc3d4746c8e86e67bcb483624394b5468f6ff3c970aac207ef6de17c636f61aae14e80556a44eda3dfd8501fa04e2f5f47abf6d2c833ecbd20582ce80fd7400e6c2997694c371df2b917e505c90d4d66df402d5dd4598e14d25ef7f576af03292bb00fbc11fbd8901aaaf5776d9ca3c39c7777c1818abf220c00039c4da1c8facc5f504c0a3554975e56703b3040eea3114e80f4a8d56c65b39521130540ecb28b1ee3e6ea733e6907e610f8702c9c808efbddad8dccacf5316cd740f878dfc47f3aa82a3b4080c32667571f50c645f8463ff5939bae9a3eee81416c16b7538179e8de9a205d43d0a8ef329bd47781689fbc84ada8a272a31e3383123956c2d36ae8c749d2e40c7a86de5fdba1393f179d9dde7ce4acf96f3b8f8f6decf51dd5cc708909873b5af80c707ec67f65be58fc858c5af35301bc478044b435e0636b3e6ce4925b522e57fa8e592505681a3ed77e5a9e076bb581d49fae0aa6dab8a314ebca2d1e8ac7dec386ccefc4475dd1670d340e547955c4f2ff294466c15541ada8bc2eb6e84061a14d24db15ff8baf700ecb7437f6c83254d9fae83b4f8b122b9c129ce97d0a71d664621efdff97f40d3b3e789017602a085b432f424f84edd809bbde188c7186aed834d620aebafd9a5e3f08bb5cca6c3c2cab4e9ef6b1760ce60cb7cabc5524d46426ffc72254c077c426dd4c903d3491ab3d0c11ae57a1fc23832d1aa1992be5db91fafd11fa4c14f6f37585bc8b2b4518adcb1a3c41d0d76355cc9731fd08e319cdb223de9d9e3a58429edadcc707f1d15786b6f1d119edfbe39b336fe27095ff27a187a2b5037ad3d35efc6b824acd218f51df97e8ccea5df2d555aea02d9b3ab2938862ee2f22a552af3c59fb5d6aba1c5b373254f7952fe4d56733e54b78467bd39f74e44512433dbfcdc3fa4f1fb8fecdbf680987e89d242adfba0e877284eaed17f296c2daf8b6cc64ad23e367e73f032c52df771e20d73dad059544583fb975c98783fe08f3645a079bdcfcda9f23d56375d00990e2d6a9d86404340f66aac621f406033a71cfb69dc020697ebb57de5d3c59cdb2e101d2c4755f614cbe71125898efcd1007c78dced1361297825ecf6304e37326f01ec00fc90db26fb1798d784cb276775f3a469af3f125f6db05a3f3299c4352a6ade6f61e199086d0f48b1edca2f000e2481c4e1efba086f23f60d66bda1d0f56b61bd613220cc68417f46d82b13d421b608967ab5b0e9fcb5a6a197050d36d8fc8771c1c060f8b9855bee1bc5a6e44656d00ca467e2e410d67b2b64c2f57096c21704d9a39919c60c40159a4906e373bf7fe578bd45ba8467eb76447e2e282e226b93ddefc191d6b056ac6fc1830cb0b648645dffd3e1ec3784bea9689bd3ac3c2bf34e6a078b202d8ee28685ab1abcb78ad1e97edaf828126a112b8a11c793011db377c459939465eb7fb7177e13193be89fa2300d5380c0b341ecc064a5bccb8f96c4083b0d67fd3afcacf28530eb6b317bfc23b60aa2d5b1756c25c6257ae045d88d8e46f58c6ce8dc9cd6af96167757f8db0ca912a5f89a9ac148ae6f591009390aae28c95eb3915da58552c4785ef297784a13d5491ad6f29ee050e2c4a554477ef844a3fc75bc09b8c7638ac2667408cb83a575391a16dbff3a0cc1c0053f1a13ab4115180b0eb5c60ea081c2d2de4cb2dcd739ccade4a8837d56c77c4f32b2ee2b4afca0ef5e0cde107f16fa8cb855c98c02aa9ac55ec955f234797bdf2695b17631da71de8cb9438e2a9d50b744386c74f6fce48a44d7beaa0d1a9b08faa336eebe102bf5b79ec5aac8a6d0919b20eabaeab4a64f51c1b550c3d765c6f2130e658244ba9ff99b967c0cf6189af7a200b96fe8e30573336c088d3f8b2c815d0098f843e25eb3f70663d6b69f69ce01b45265b757e222483e14d5d501ec8a6d8ca3f08a4d861cce23ad50b5d99e999199a4adfd619262b3ea55b2e1686b22c54e0eb63d660059f5fd929109f6debf8c7e14ea51a1cf175be55e25ad434e0339ce898ca72901d24c4c213711a82575d664fa0a87586189255c55a0394a5da5a72c43105e8f547a9095df14250cfc1158cfe8908c98ecbdd660d83e239315543374b0ca533bc260187009429c826ff431e9ed479f4d3849c30169c249400638700b3f6277f3217d9a28874720962470dcd5f1ee42b0d48c5364f85ea2a751e726a4ed4e88363dd874ad9e02e133de215620d7576a990984da6ada7b165f76e787b742112b38adc0127812826b1900204da10f8ae37ca8b0b5e2ee59ecd0e48a766bf432f34f708ff765ccffa67b3444cc366b4d2e701a576989179295eac6d3f8d11c233ad4a2e8ed0dfa259cccfe66b396b473b3ff2b59204672aa9829f56f0c01125383fb0d8cbc746865ef89eee42bb2733dbc85e44af4455bbe21644cd4263176e5e925f2a2e0126c724ff4309dcb2249e7b6143bfd12bb17c7b864893aa611be6933fbad19ae17c8e04268a3628ee3ea5d8f31a620fce63a4ee0031eb067cd040d38fa8ff16f0f42782372c1525335a780e9570a6bd9ae643ca0146884edd72a71a6e71fa5fcf02cb34fbfed8d80cd9543c288272c0298c9d5008993016174ab2c5ab11ed67c1772e27193aa67676321e8a03ee3fe810df637ee8876ad1e520108bc3ecfda911d729116fc61282608b95d2da5dfec3580231f1c60385e78f78d4afd5085239f857577e58ae187ed5c531427fd41a8088e89110263eeb9065dd0558ab6e61801cb94fa93ab293cfcc4c6425a83799f22c2c882db10995d96aa5ce964565287230c31a4a35f537fc5ba6cbeb280e2b775b42a58871196aa8a5a52a103d7075604393ad672a83d144d4a04b8aa1276bff58a3e14e8d6f69bae859a770fb7aeea4ff79440053fdb7f7ee03899147301f8105cf58422e3025aa8f3b2585c32fcbc22a0124ba60fb73eca7b7206d71c87aefcc25f15fbef338c25f65b1d9fdcf2df0efe1068344828cb29eceadfa16bd2de4dbacab452747b15b8ca99147485e28abb87c7be46d0d8ad1c074c840af2b3b5f24202ec387860ed78baa188d885669c6f56053ce0f69ec63f4e2c1ea43a6fab4a7a3c8cd3aa60e9851c1ee15578e1b58a419d5040ab73321b4f3bd8180f9ffecf401a47edc91cf79cd3ae11de6bc98155e69e642179fd6909cbe4aae6ed0ec706775496f57cda91facaceff664fd3bf5af77fbb818ef4a81cd44337ad23559d9f46d7dafd23b6fa0c1a82ecccd04040952caab3254571ca18dacd20524a15b2eb5990402c60e1dfb0c6b6839b0e0e01ba816c11ce8b72cfa40252f591c6ca23b8942d6988258e04262aa07db41ce7da55c4a8bd53b34a68711a909f6ed2f5a742f98bc1ba1155e3e525885a0f55458109e7b15d5558e0b8833c8ed54e971f715cea65e9022afbfb1779e7da3767f565ac381518e10f185ee1813c190a9f08dae12a00d8da4d1f3d8ada38adeee964110505942131d84a43ff0b39b96e45ea78742d4e9b078661cb725d7d89e002bf357d33fc6f7dd0d9563d02425dd79394078b5c916639f07e1cdfb7ab90a6f643a050b0f42c354329768dbf383e5005d9040ba3fc6fd32c795c38b27b777dfc9e4ba31c403ee0c1861efa3b65450fe7e4a9b0307f55df7e1f3d873de7d29554fd7e11ddc852020961ad5f98fb12461ac5b0ffdc27e29444be72770f9df57198f95fbadd339875c041a6b690430be0ac945e3ebf0a212f5d117e42e8c6aacd8c017ddb812be5434263e38a0ed30a6377d1e015456eca262496fba7c20888b9a0b28c99aa85f76716091c0af1bccebbd143fb6543fee824e406dea6f2fccc20a2a879138c5d0af2a3ec5407ec50f27f79dca66f4b404f5fc093d4759a87cf2a447c6ac73f9a44f2e2adb8934deb71d33f932a65ebd0d6d436652ef283474ad69e1b208246f8ee80d3a1b5ef2a8865604de02aee69394a83d8d96fa77bdea89cc03f46cb07db544ea46638d170d0a8351b1b0767890388f16d8cb0d43ddbe6b4e32d5bb96c07c88bf6f28cba55308025715812fdde2f94bd480b81052e4b7677f751e9d228230d99cf28f0adce1de01b96cb3e30fd06cea66effe226c55a11f56302b0b80432bb22be57a4b049607f8790bbb528ac7457b08cfb613cd64704311f3a7008c08949ae2065090e955e641a7e9a8f86b0ef414b9eae0e03f2fac78019419f42c036c9ff38e2da2f88132e342312e3e06112f8839efdf5c343c6a162e0cb1ff47e84c0f483dc0ed2b6fd0d81c03987bc01907d4046637c2198248f72b3083972d3b58659f69e23f682c25dcdd96abff4d63f5b8feabc7c54d7a71394bbfda7314559fa224857eb04fef19a146e50bfcdc5647682ae244d8c1870c52a7702ce79bf912f3816594558ef3f63b7f58e94446a56e5647b988644c49576e160cd75ed45720d7986d273858de20ee5e9881d00c368ebfb2b8dc37edf95304a07345feefff5037d4328270e4d1014ad80d9c7da571a514dd3af44bb6d545d36140d4937124de5f9445e9fae277c99e60bc0e041cc5a09b9d3e05aeac228cec33fd8c50589ca7c8974c4295a011d9e359b3281ec18d696b08f377e89410738e83b9630800ef1d3a8ab86edce3ade47ca94af9c2ac79d3356935e7ce612df8da9cb267e140b20919a52c1dd5b1f671c8819d277df39ac668cd44381a55a28a0ebc2155fee5f746cc21cfcee5cb02d2a6b4d84371dea7152ab18d7912e97f493ff74954b52eda698a94ebaef4b8c866d19ea90ffa688963099dae75699de495cf680aa1645dfa7f3df8c0f914705761cad448be20471cd9f1beb8740ea719ad79daba0df2232183c4d05bdc0933a1510188b8d73056ec378260c30a8997a38e6ba089d2a79b6e6b31266d4a347e855a95aa5621bbb5233347e741cd589bc3f595da3c198ee4fbe8a8e8b4e6041a53c4817d273d89102799c47e58ec6993be81592a9ee133d1d64bf0d08971ca64cf104b47540e02a9579b5e902e1a9d081716ee2044b2e3485b928503dea80f462a687bef6487fa5f4ec2a735116eed067e03b2b9b67a6d5e4aee12d988f22d087958dca6f02404822f688a0ee8dff845ae9be030d3ec6d20e3e002debfcae6f35e4241f1adbf8b0355ab7b97faeda421c787eed277b94b1b4e57ced42e0a4ffa454dfc1b66752fee73b22492f6935ae2d40e8c7456c4dc2fe1e85625f5c54ff47da221f9514620a4392545d4c86248c96934352f1a871ecb73ad3983299263f9740e96910c6e1f4f17744a0d4eeea579e2d4f6899d464bf7e95788c0dd1a03472c2943b51fe57becbc2cd2d0c17dcf665a2ff8a1ab63f697f3ee743eb32b020db7cd44339ca63827b0ee4114156d4c29e8073d530c9f841a2effafc5b06872a237e1cd972416b00fb3966c320a21d18e07107bbd4b8251f2b3513f7c604ce5d2ad094e6c55d9f0b618d26d17e9dbcc9b9905861a3d4bd1cbed3bc9b15ceb30b9e88f0e1c365c7bf8ae6a56930e7fbfb1bf266a0fb086cba58cea57ef413c614cee250da1120c722dfa104d8e6278e6ff8330513d03e6ca8c3e4c67068955f355a945c05806f1b97eb49fd3cb7cdf717234886affaf4769b5c319726a755402f551b9ad43411e972af42d89be732bd76ca71358fd3c81e90c9219261c9f9ad9fbd33784e2be4e7e1c24900278a26d513c5e5b637c19999a4cac04cab2cd151e466ad693ba9db9e2ef872f55c6a7448c0df2572a348d7af73d9cecd025a6753badb157dd970403b33c00cbc40c5848a47b230e33247d49e5bde05c88f7ee842e643089575b93551c3909af2f4c22edccecc7ace13d3a09e5253949234c525baaeffe74629bedb082f4d914c8c4a03f969f89cfd5af11872662289fd73dee93325536dd61cb0c31ba90a97a0e60c822ceb7c5a8d27f9725e18c8e219753cb6fc8ebdd48d3573ed68595a60d66714f2231efa05342a8e3271a913ebf106123255d0420b7156a77681c5a5c441dcff011eeaacf18cfe8623ab0c9ebcc122a89d8987460a0393972471043415967d12e311651d23e72bb150b532fe28d01813a6f96a6a0bd181145a6750e02ce5a80bbe71c5a917af2e7523a01081601ebaa93b33683ebc976c092ebb5c5a70e7eeb5b48cfc69707cb8902170ad7e3c37ccc0c43b7ba52d13ff0308e793224e454ff6986915bd8ee24fe3d00eb824d9811163e8382c5f8ea5b8b632d576d4a77fc2bec12fc83cd58d56ed68ba679b86ce979d4a6ac3d7e33d8f0b4fca5ef0af7b5f27a14280045228668af1671d6dc3944996b532a8066c515d06a03cc5e01260901ce56c047661919f2af1cd411ac7bcbaf89bf49aa3081f23f3355df254502526c95c704cdbe4722140cf6641e939407d4b3beb7bb53a2f7186cf7388271ad84f36fad4e0e8e5b9c30da7987180bece47a626fe8618c6c6c57323b61e1320f66331626afd9b7d9d1ec11a406f3d23fc7edd0b6fbda20e24d468e09fc863a1cf9ec313f0c74b3dc1636df3bf63594edea44a25b89d9d6fdd35cddbe748b67cf23cf964d8e81190106116f8801abf5086090801ca1d68c380c3f6b8e356b5d4c3a4c9e2c99af9b429ae168cd99f030ad7a351cae741bd748268bedad8c3d10b2abd678fce6ac61ccdfacd74fd946829a4b194d8d0ad70c75226cee112d058952a4bb70da175c5992b4cdb3943488a81a156b816f95c4761b684e511f2e72fa332ade46f0ba2e61792e7540e7bea22212b84de552b245787b513c26483cb1750c5de54e6f0b93f134e34a56844f257ea476a5e2469202d83322bce92309a2e16ab1a07e37ee03ef496fe4e45f8653f40d8246824dfd15e9fc8e6e66f363c37270f3f8813547b24389c3670b1cb12b73fc2c0c16a72c96ba72c1d3d1826c9eb9f6ad554a23ed353c23d6fadfdd40a236b2ab99188fb9a33670f33363fea08927852f921bc837b2affe0c63792f6184eca10a24c2cdcb4cb1e2931adf2729931f2180825ca9993e5655f3f0495e43b03dd57222061035fc198d1904ff64f4ea6e2ed18db9cebc6106be75a3babc3133bc53e2f3ae9168bac36a689898a748b35e9cf9f810dcd7357aad7b1c468520f292842228cca02ad329cc632a45175ec7b0d2cc96489b6edf3cc98f735d08a28bfaef2862336624b235ca6944c7b75d1e520aa8d49ad8bb60b117c6643f6695a229105f165d33340d01d299dacd1a717c3fd2833a3b2b02e0b4a20bedd2fb386102b2039e4a23e4c8b113129cacf27471e43a948367876fb537b1f7c973ed3c001eb5e1f88e2d698a1db94e29258744affa875acfb28648a412191e7c67207b1a0aac643e7821ef2e1193827477d2a9212757d51851ef826081a180d80b6c36ef7a809b7d725aae7d79e54aee379dee2116d1ad75b3e58be674b03b7937b72d0bc1120a8664087e66e359890b62b69c7be3ce51e2575e197949cf64758b1598a391ff929e9376602d0e89da1359f38a5072cb8669007a29489ed19a43cd985ea637c1fefcc04cf3068f1d34ede53c7fce55848d1a4c2370911812b11c3a14c782891f7481a417c77cd0ded0996cb64a924a0f139695bab1db0ffe3c3faf10b9297801ddce48ec5ba8e95c2299a64fa08ae4b0f5319e667ba680d44bf2f1f3aba7ebeb5cb4f39ef183c789ca15a3ab9d2b279d7b4d7ef31f3cd2d59751abc9191a4c57f562ec11261663d356362f1e467f9dee77442f0b67d2c42768f1a7ee8dd0be6ac34053e959a2827c85d67f1eb0c2906e66444ff8e6140efd27617f94f65797a1d24c7ff87220eb7072ba1cb068857c9bcdad6ddba94a1095eda29669f803867e77122f047ad10ebc9641b15d8e26a5b2faad9ee044b2866a2c659341ae4cfc99a7421cc87b9384984da15db788378edc3c2b5e43d94a6234ead6b0e0dd22db982d945740d1dc5985df418b34ca5516bda44a471a365635096bc4214810450f3cf61196bdbfa98996eba081e7bbbe59c4cbce80e397b75ab65ef127d4b2a3c0b7eb6bac122396fc66882c345d93ac383f986fd610ddcd4f9f28d3eefae553aa3495973f9a41b57e8675010d45a6cf91f1e725ea9e03634b5730a8eb3c718a652902153df9c580612f29bb32dff611ab1b861b2acdb29bcd565dac04e655f0acfa79a7cf0427a503ab2c86ad78b64e27842df813159e7f225434fa0d4f023abd83d0c4f172059b8951472d704e6bfd4c184a8e81012264bb57ea6e7a1222b1459b5800834229aa0d6bcf8b70e806ca8f02b347a4e15525112b1853ecaf0dc584ce93fee448afa9b4cd5e0880b1628dce31a4c0232327a26cfe8e2de8a00045648d7f745152ba24237ae20a530ef17611ae94e8c8f4e9eaf8e11b3fa7c92a125255dda96f78f6714f8f0c1e1eada4c5399a53f025777a33f4a88ca28e5b4a6dac08615de6ff65d291594a5626e975783e447ad4c3c09604a37de7d85445754de0a72b2cad6a5a1ee454c9b5ed74b8360de323a03adb50bcfadec0d9a10715f7d3dec426bd30c8b367b9172ab934282ecf4837bb23908f1f5ee96e981befe5e198625e977b32436cc91d6fcd4d8bfb3d5c9b52b2f7b983cb388445bcfcceb34980b1a84e9bf6a71a8b13e38b0de6b3abd8636b3164ad3fae4bb670bb2ddb1feeeeead831fb0ace2326f6b3726a089f1e8fe0630c45b398346ef4b815b5a03565973d7fa231f916c712b2bfbfb6985dfe356cb6b0285164053be4b6c411db100403badbf70d368d0aee3963cd7c344db8dae6551ae077dcc8660d04ba943697e5c36ae1360da89f47c00293438556c84c99d8185e0","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"866d10a5c8fa1421f11baa3a03887662"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
